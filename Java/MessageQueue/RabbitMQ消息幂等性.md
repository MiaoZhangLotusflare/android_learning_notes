

# RabbitMQ 消息幂等性

## 1 幂等性概念

　　简单来说就是用户对于同一操作发起的一次请求或多次请求的结果是一致的。

　　可以类比数据库的乐观锁机制，在并发场景，为了性能和数据可靠性，会在更新时加上查询时的版本，并且更新这个版本的信息。执行更新语句，以 version 作为条件，UPDATE T_REPS SET COUNT = COUNT -1，VERSION = VERSION + 1 WHERE VERSION = 1，如果执行更新时有其他人先更新了这张表的数据，那么这个条件就不生效了，也就不回执行操作了，通过这种乐观锁的机制来保障幂等性。

## 2 出现非幂等性的情况

　　为了保证消息必达，一般会使用消息超时、重传和确认机制。而超时、重传、确认机制可能导致消息总线或者业务方收到重复的消息，从而对业务产生影响。

　　消息发送的过程：

![](image/消息发送.png)

1. 消息生产者（Producer）将消息发送给 RabbitMQ 服务器。
2. RabbitMQ 服务器收到消息，将消息放入队列中。
3. RabbitMQ 服务器发送确认消息给生产者。
4. RabbitMQ 服务器将消息发送给消息消费者（Consumer）。
5. 消息消费者发送确认消息给 RabbitMQ 服务器。
6. RabbitMQ 服务器将消息从队列中移除。

　　在 RabbitMQ 从消息创建到销毁这个过程中，会有两次确认接收的过程：一次是生产者确认发出的消息被服务器接收，一次是服务器确认消息者消费了发出的消息，而在这两个确认过程中如果出现异常就会重发：

1. 如果在第 3 步的时候由于网络不可达等原因，生产者没有收到确认消息，但是服务器已经成功的接收了消息，在网络重连后，重复向 RabbitMQ 发送消息，造成了服务器接收了重复的消息；
2. 如果在第 5 步的由于网络不可达、消费者故障或者异常等原因，消费者断开了，服务器没有收到确认消息，消息会重新发送给下一个消费者（有的话），或者在网络重连后再次发送消息给该消费者，但是消费者已经成功的消费了这条消息，造成了消费者消费了重复的消息。

## 3 解决方法

### 3.1 服务端实现幂等性

　　对于每一条消息，RabbitMQ 内部生成一个全局唯一、与业务无关的 ID：inner-msg-id。当服务器接收到消息时，吸纳根据 inner-msg-id 判断消息是否重复发送，再决定是否将消息发送到队列。这样，有了这个 inner-msg-id 作为去重的依据就能保证一条消息只能一次发送到绑定的队列。

### 3.2 消费端实现幂等性

　　消费者实现幂等性，就意味着，消息永远不会消费多次，即使收到了多条一样的消息。

　　业界主流的幂等性操作：

1. 唯一 ID + 指纹码机制，利用数据库主键去重

   思路就是首先需要根据消息生成一个全局唯一的 ID，然后还需要加上一个指纹码。

   唯一 ID：如数据库的主键 id。

   指纹码：业务规则标识唯一的。如时间戳 + 银行返回的唯一码。这个指纹码它并不一定是系统去生成的，而是一些外部的规则或者内部的业务规则去拼接，它的目的就是为了保障这次操作是绝对唯一的。

   为什么需要指纹码？为了应对用户在一瞬间的频繁操作。

   将 ID + 指纹码拼接好的值作为数据库主键，就可以进行去重了。即在消费消息之前，先去数据库查询这条消息的指纹码标识是否存在，没有就执行 insert 操作，如果有就代表已经被消费了，就不需要管了。

   优点：实现简单。就一个拼接，然后查询判断是否重复。

   缺点：高并发下有数据写入的性能瓶颈。

   缺点解决方案：对于高并发下的数据库性能瓶颈，可以跟进 ID 进行分库分表策略，采用一些路由算法去进行分压分流。应该保证 ID 通过这种算法，消息即使投递多次都落到同一个数据库分片上，这样就由单库数据库幂等变成多库的幂等，分摊数据流量压力，提高性能。

2. 利用 Redis 的原子性去实现

   redis 是 单线程的，并且性能也非常好，提供了很多原子性的命令，比如可以使用 setnx 命令。

   在接收到消息后将消息 ID 作为 key 执行 setnx 命令，如果执行成功就表示没有处理过这条消息，可以进行消费了，执行失败表示消息已经被消费了。

   使用 redis 的原子性去实现主要需要考虑两个点：

   * 是否要进行数据落库，如果落库的话，关键解决的问题是数据库和缓存如何做到原子性？数据库与缓存进行同步肯定要进行写操作，到底先写 redis 还是先写数据库，这是个问题，涉及到缓存更新与淘汰的问题。
   * 如果不进行落库，那么都存储在缓存中，如何设置定时同步的策略（ 同步到关系型数据库 ）？缓存又如何做到数据可靠性保障呢？

   关于不落库，定时同步的策略，目标主流方案有两种，第一种为双缓存模式，异步写入到缓存中，也可以异步写到数据库，但是最终会有一个回调函数检查，这样能保证最终一致性，不能保证 100% 的实时性。第二种是定时同步，比如 databus 同步。

　　对于非幂等性业务可不实现幂等性业务：权衡去重所花的代码决定是否需要实现幂等性，如：购买会员卡成功，向用户发送通知消息，发送一次或者多次影响不大，不做幂等性可以省掉写去重日志的操作。

## 4 参考文章

[RabbitMQ幂等性的主流解决方案](https://www.jianshu.com/p/d8042d7f62e1)

[MQ解决消息重发--做到幂等性](https://www.cnblogs.com/zhangxianming/p/8724590.html)