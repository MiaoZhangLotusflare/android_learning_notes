## 139. 互操作性与可空性

* Java 世界里所有对象都可能是 null，当一个 kotlin 函数返回 String 类型值，你不能想当然地认为它的返回值就符合 Kotlin 关于空置的规定。

```java
public class Jhava {

    public String utterGreeting(){
        return "HELLO";
    }

    public String determineFriendshipLevel(){
        return null;
    }
}

```

```kotlin
fun main() {
    val adversary = Jhava()
    println(adversary.utterGreeting()) // HELLO

    adversary.determineFriendshipLevel().toLowerCase() // Exception in thread "main" java.lang.IllegalStateException: adversary.determineFriendshipLevel() must not be null

    // level 的类型是 String! 平台类型
    val level = adversary.determineFriendshipLevel();
    level?.toLowerCase()
}
```

## 140. 类型映射

* 代码运行时，所有的映射类型都会重新映射回对应的 Java 类型。

```java
public class Jhava {

    public int hitPointes = 3232320;
}
```

```kotlin
fun main() {

    println(adversary.hitPointes.javaClass) // int
}
```

## 141. 属性访问

* 不需要调用相关 setter 方法，你可以使用赋值语法来设置一个 Java 字段值了。

```java
public class Jhava {

    private int hitPointes = 3232320;

    public int getHitPointes() {
        System.out.println("-------getHitPointes-------");
        return hitPointes;
    }
    
  	public void setHitPointes(int hitPointes) {
        this.hitPointes = hitPointes;
    }
}
```

```kotlin
fun main() {
    val adversary = Jhava()

    println(adversary.hitPointes) // 3232320
    adversary.hitPointes = 3
}
```

## 142. @JvmName



## 143. @JvmField



## 144. @JvmOverloads



## 145. @JvmStatic



## 146. @Throws



## 147. 函数类型操作



## 148. Android 开发使用 Kotlin









* 互操作性与可空性
* 属性、异常互操作