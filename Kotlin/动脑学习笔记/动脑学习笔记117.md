## 117. 定义扩展函数

* 扩展可以在不直接修改类定义的情况下增加类功能，扩展可以用于自定义类，也可以用于比如 List、String，以及 Kotlin 标准库里的其他类。和继承相似，扩展也能共享类行为，在你无法接触某个类定义，或者某个类没有使用 open 修饰符，导致你无法继承它时，扩展就是增加类功能的最好选择。

```kotlin
// 给字符串追加若干个感叹号
fun String.addExt(amount:Int = 1) = this + "!".repeat(amount)


fun main() {
    println("abc".addExt(2)) // abc!!
}
```

## 118. 超类上定义扩展函数

* 定义扩展函数和定义一般函数差不多，但有一点大不一样，除了函数定义，你还需要指定接受功能扩展的接收者类型。

```kotlin
// 给字符串追加若干个感叹号
fun String.addExt(amount:Int = 1) = this + "!".repeat(amount)

fun Any.easyPrint() = println(this) // 整个工程项目都有效

fun main() {
    println("abc".addExt(2)) // abc!!

    "abc".easyPrint() // abc

    15.easyPrint() // 15
}
```

## 119. 泛型扩展函数

* 如果想在调用 addExt 扩展函数之前和之后分别打印字符串怎么办？

```kotlin
"abc".easyPrint().addExt(2).easyPrint()
```

* 新的泛型扩展函数不仅可以支持任何类型的接受者，还保留了接收者的类型信息，使用泛型类型后，扩展函数能够支持更多类型的接收者，使用范围更广了。

```kotlin
// 给字符串追加若干个感叹号
fun String.addExt(amount:Int = 1) = this + "!".repeat(amount)

fun <T> T.easyPrint():T{
    println(this)
    return this
}

fun main() {
    "abc".easyPrint().addExt(2).easyPrint()// abc abc!!
}
```

// apply 函数

```kotlin
@kotlin.internal.InlineOnly
public inline fun <T> T.apply(block: T.() -> Unit): T {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    block()
    return this
}
```

## 120. 标准函数与泛型扩展函数

* 泛型扩展函数在 Kotlin 标准库里随处可见，例如 let 函数，let 函数被定义成了泛型扩展函数，所以能支持任何类型，它接收一个 lambda 表达式，这个 lambda 表达式接收者 T 作为值参，返回的 R-lambda 表达式返回的任何新类型。

## 121. 扩展属性

* 除了给类添加功能扩展函数外，你还可以给类定义扩展属性，给 String 类添加一个扩展，这个扩展属性可以统计字符串里有多少个元音字母。

```kotlin
val String.numVowels
    get() = count { "aeiou".contains(it) }


fun <T> T.easyPrint(): T {
    println(this)
    return this
}

fun main() {
   "The people's Republic of Chine.".numVowels.easyPrint() // 10
}
```

## 122. 可空类型扩展函数

* 你也可以定义扩展函数用户可空类型，在可空类型上定义扩展函数，你就可以直接在扩展函数体内解决可能出现的空值问题。

```kotlin
fun String?.printWithDefault(default:String) = print(this?:default)

fun main() {
    val nullableString:String? = null
    nullableString.printWithDefault("adb") // abc

    val msg:String = "efg"
    msg.printWithDefault("adb") // efg
}
```

## 123. infix 关键字

* infix 关键字适用于有单个参数的扩展和类函数，可以让你以更简洁的语法调用函数，如果一个函数定义使用了 infix 关键字，那么调用它时，接收者和函数之间的点操作以及参数的一对括号都饿可以不要。

```kotlin
infix fun String?.printWithDefault(default:String) = print(this?:default)

fun main() {
    val nullableString:String? = null
    nullableString printWithDefault "adb" // abc

    mapOf("jack" to 18)
}
```

## 124. 定义扩展文件

* 扩展函数需要在多个文件里面使用，可以将它定义在单独的文件，然后 import。

// 创建一个文件夹名为com.jason.kotlin.extension，在文件夹中写下面代码

```kotlin
package com.jason.kotlin.extension

fun <T> Iterable<T>.randomTake():T = this.shuffled().first()
```

```kotlin
import com.jason.kotlin.extension.randomTake

fun main() {
    val list = listOf("Jason","Jack","Tom")
    val set = setOf("Jason","Jack","Tom")

    list.randomTake()
    set.randomTake()

}
```

## 125. 重命名扩展

* 有时候，你想使用一个扩展或一个类，但它的名字不和你的意。

```kotlin
import com.jason.kotlin.extension.randomTake as randomizer // 别名

fun main() {
    val list = listOf("Jason","Jack","Tom")
    val set = setOf("Jason","Jack","Tom")

    list.randomizer()

}
```

## 126. apply 函数详解



## 127. DSL



## 128. 什么是函数式编程



