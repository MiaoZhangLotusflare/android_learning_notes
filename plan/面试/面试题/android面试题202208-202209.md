# 安卓面试题

## 1. retrofit

## 2. 做过哪些优化

## 3. gc

### 如何标记可回收的对象

1. 引用计数算法：在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为 1。当任何其它变量被赋值为这个对象的引用时，计数加 1（a = b,则 b 引用的对象实例的计数器 +1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减 1。任何引用计数器为 0 的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减 1。
2. 可达性分析算法：程序把所有的引用关系看作一张图，从一个节点 GC ROOT 开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。

  在 Java 语言中，可作为 GC Roots 的对象包括下面几种：

1. 虚拟机栈中引用的对象（栈帧中的本地变量表）；
2. 方法区中类静态属性引用的对象；
3. 方法区中常量引用的对象；
4. 本地方法栈中 JNI（Native方法）引用的对象。

## 4. 知道哪些锁

### 读写锁

## 5. TouchEvent 除了 down、move、up 还有哪些

MotionEvent的事件类型主要有：
public static final int ACTION_DOWN = 0;
public static final int ACTION_UP = 1;
public static final int ACTION_MOVE = 2;
public static final int ACTION_CANCEL = 3;
public static final int ACTION_OUTSIDE = 4;
public static final int ACTION_POINTER_DOWN = 5;
public static final int ACTION_POINTER_UP = 6;
①ACTION_DOWN：第一个手指按下时
②ACTION_MOVE：按住一点在屏幕上移动
③ACTION_UP：最后一个手指抬起时
④ACTION_CANCEL：不是由用户直接触发，而是由系统在需要的时候触发，例如子view接收到了down事件，但是在move的时候，父view通过onInterceptTouchEvent()返回true，拦截了该事件流，从子view拿回了处理事件的控制权，这时候子view就会收到一个ACTION_CANCEL事件，并且子view再也不会收到后续事件了，后续事件都交给父view来处理了。
简单来说，根据ViewGroup分发事件的机制，一般来说，如果一个子视图接收了父视图分发给它的ACTION_DOWN事件，那么与ACTION_DOWN事件相关的事件流就都要分发给这个子视图，但是如果父视图希望拦截其中的一些事件，不再继续转发事件给这个子视图的话，那么就需要给子视图一个ACTION_CANCEL事件。
⑤ACTION_OUTSIDE：表示用户触碰超出了正常的UI边界。
官方解释：A movement has happened outside of the normal bounds of the UI element. This does not provide a full gesture, but only the initial location of the movement/touch.
一个触摸事件在UI元素的正常范围之外发生。因此不再提供完整的手势，只提供 运动/触摸 的初始位置。
正常情况下，如果初始点击位置在该视图区域之外，该视图根本不可能会收到事件。然而，总有一些特殊情况，比如点击 Dialog 区域外关闭，Dialog就是一个特殊的视图(没有占满屏幕大小的窗口)，能够接收到视图区域外的事件(虽然在通常情况下你根本用不到这个事件)。
当然，想要接收到视图之外的事件需要一些特殊的设置，即设置视图的 WindowManager 布局参数的 flags为FLAG_WATCH_OUTSIDE_TOUCH ，这样点击事件发生在这个视图之外时，该视图就可以接收到一个 ACTION_OUTSIDE事件。
⑥ACTION_POINTER_DOWN：用户又使用一个手指触摸到屏幕上，也就是说，在已经有一个触摸点的情况下，又新出现了一个触摸点。
⑦ACTION_POINTER_UP：用户的一个手指离开了触摸屏，但是还有其他手指还在触摸屏上。也就是说，在多个触摸点存在的情况下，其中一个触摸点消失了。
它与ACTION_UP的区别就是，它是在多个触摸点中的一个触摸点消失时产生，而ACTION_UP是最后一个触摸点消失时产生。
⑧MotionEvent.ACTION_SCROLL：android3.1引入，非触摸滚动，主要是由鼠标、滚轮、轨迹球触发。

## 6. Bundle，one way 怎么理解

oneway 代表这个 binder 接口是异步调用。

## 7. 设计模式

## 8. window、Activity、View  讲一下

## 9. hashmap 的数据结构

## 10. java int、short 的字节数

Short: 2 个字节

Int：4 个字节

char: 2 个字节

float : 4 个字节

Long：8 个字节

Double：8 个字节

## 11. TCP 四次挥手的过程



## 12. 在项目开发中遇到的有挑战性的技术点

## 13. 设计 app 注意的点，如何架构

1. 使用 mvp 和 mvvm 架构

2. 模块之间的通信可以依赖抽象类或者接口，避免功能的改动影响使用。

3. 模块之间的功能单一，避免耦合

   

## 14. 性能优化

1. 打开速度优化
   * 数据缓存
   * UI 减少图层
   * 图片 oss 裁剪
   * 埋点上传放到线程中
2. 儿童内存优化
   * cpu 优化：1.刷新动画停止；2.banner 自动动画停止，3.跑马灯停止
   * listview 列表加载图片时，滚动列表时 glide 加载停止，如果没有在滚动则恢复加载

## 15. listview 嵌套处理。滑动冲突

父控件用 onintercepter 拦截事件，滑动的时候判断用户滑动的方向，上下滑动则父组件用 onintercepter 方法返回 true 拦截事件，如果是左右，则 onintercepter 方法返回 false 将事件交给子 view 处理。

## 16. 组件化

无

## 17. 音视频开始是否有经验？

无

## 18. hashmap 原理

扩容机制，1.8链表在什么时候转红黑树
HashMap 由数组 + 链表组成，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突的。

初始容量是 16，负载因子是 0.75，当容量超过阈值，则将数组扩容为原来的 2 倍。扩容后会重新调正位置。

1.8 中当链表超过 8 时，会将链表转换为红黑树，利用红黑树快速增删改查的特点提高 hashmap 的性能。当小于 6 的时候，会转回链表以达到性能的平衡。

## 19.责任链的使用场景

链接处理：有android 打开链接、小程序打开链接、h5 打开链接，可以用责任链分链接类型进行处理。

## 20. 工资期望







## 21. view 和 viewgroup 的绘制流程

主要分为三步：measure、layout、draw

measure 主要是测量。系统会先根据 xml 布局文件和代码中对控件属性的设置，来获取或者计算出每个 view 和 viewgroup 的尺寸，并将这些尺寸保存下来。

measure 会调用 onMeasure() 方法测量自身的大小，measuremode 有三个：Extracel 确定值，AT_MOST 尽可能大，unspecified 不确定的。

Layout 根据测量出的结构以及对应的参数，来确定每一个控件应该显示的位置，layout 确定自身的位置，onLayout() 会遍历所有子 view，调用子 view 的 layout() 方法确定子 view 的位置。

draw 绘制，确定好位置后，就将这些控件绘制到屏幕上，分4步绘制，1绘制背景，2绘制内容。3.绘制子view，4.绘制装饰，入滑动条。

## 22. 讲一个熟悉的模块架构

## 23. 讲一下装饰者模式的组成与项目中的实现

一般由两种方式可以实现给一个类或对象增加行为：

* 继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使用子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。
* 关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器。

装饰者以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。这就是装饰模式的模式动机。

装饰模式：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器，与适配器模式的别名相同，但它们适用于不同的场合。

装饰模式包含如下角色：

- Component: 抽象构件
- ConcreteComponent: 具体构件
- Decorator: 抽象装饰类
- ConcreteDecorator: 具体装饰类

![](/Users/miaomiao/Desktop/android/android_learning_notes/plan/面试/面试题/image/Decorator.jpg)

模式分析：

* 与继承关系相比，关联关系的主要优势在于不会破坏类的封装性，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得系统更加容易维护。当然，关联关系的缺点比继承关系要创建更多的对象。
* 使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。

优点：

* 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。
* 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。
* 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。
* 具体构建类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构建类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。

缺点：

* 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是他们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。
* 这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。

## 24. 组件化与插件化是否涉及

## 25. Kotlin 用过吗？讲一下 kotlin

## 26. 性能优化

1. 内存优化

2. UI 优化

   UI 优化主要包括布局优化和 view 的绘制优化。

   布局优化：屏幕上的某个像素在同一帧的事件内被绘制了多次，在多层次的 UI 结构里面，如果不可见的 UI 也在做绘制的操作，这就会导致某些像素区域被绘制了多次，这就浪费了大量的 CPU 以及 GPU 资源。

   优化方法：

   * 父控件有颜色，也有自己需要的颜色，那么就不必在子控件加背景颜色。
   * 如果子控件的颜色不要一样，而且可以完全覆盖父控件，那么就不需要在父控件上加背景颜色。
   * 尽量避免不必要的嵌套。
   * 能用 linearlayout 和 framelayout，就不要用 relative layout，因为 relatibelayour 控件相对比较复杂，测试也比较耗时。
   * 使用 Include 和 merge 增加复用，减少层级。
   * viewstub 按需加载，更加轻便
   * 复杂界面可选择 constraint layout，可有效减少层级。

   绘制优化：

   * onDraw 中不要创建新的布局对象
   * ondraw 中不要做耗时的任务，少使用循环

3. 内存泄漏优化

4. 其他优化

   1. listview 优化
   2. Bitmap 优化
   3. 线程优化，可以用线程池

## 27. 遇到过哪些内存泄漏？如何处理解决

1. 集合类泄漏，像是 list 添加元素后，仍引用着集合元素对象，导致该集合中的元素对象无法被回收，从而导致内存泄漏。

2. 单例/静态变量导致的内存泄漏，单例模式具有其静态特性，它的生命周期等于应用程序的生命周期，所以容易造成内存泄漏。

   context 和 toast 是容易出现内存泄漏的，如果生命周期长，可以用 application 的 context。

3. 匿名内部类/非静态内部类，如果非静态内部类的生命周期长于外部类，再加上自动持有外部类的强引用，就会发生内存泄漏。解决方法就是改为静态内部类。

   静态持有非静态类的引用，就会导致内存泄漏，解决方法是使用弱引用。

4. 资源未关闭造成的内存泄漏，像是网络、文件等流忘记关闭，手动注册广播忘记注销，service 执行完没有 stopself。

## 28. 创建多线程的方式

创建多线程有 4 种方式：

1. 继承于 Thread

   * 创建一个继承于 Thread 类的子类
   * 重写 Thread 类的 run() ->将此线程执行的操作声明在 run() 中
   * 创建 Thread 类的子类的对象
   * 通过此对象调用 start()

   ```java
   public class ThreadTest1 {
       public static void main(String[] args) {
           Thread1 test1 = new Thread1();
           Thread1 test2 = new Thread1();
           test1.start();
           test2.start();
       }
   }
   class Thread1 extends Thread{
   		//遍历100以内的整数
       @Override
       public void run() {
           for (int i = 0; i < 100; i++) {
           //调用getName()方法显示当前线程名，便于观察
               System.out.println(Thread.currentThread().getName() + ":" + i);
           }
       }
   }
   
   ```

2. 实现 Runnable 接口

   * 创建一个实现 Runnable 接口的类
   * 实现类去实现 Runnable 中的抽象方法：run()
   * 创建实现类的对象
   * 将此对象作为参数传递到 Thread 类的构造器中，创建 Thread 类的对象
   * 通过 Thread 类的对象调用 start()

   ```java
   public class ThreadTest2 {
       public static void main(String[] args) {
           Thread2 thread2 = new Thread2();
           Thread test1 = new Thread(thread2);
           Thread test2 = new Thread(thread2);
           test1.start();
           test2.start();
       }
   }
   
   class Thread2 implements Runnable{
       @Override
       public void run() {
           for (int i = 0; i < 100; i++) {
               System.out.println(Thread.currentThread().getName() + ":" + i);
           }
       }
   }
   
   ```

   比较浅两种方式：

   1. 实现的方式没有类的单继承性的局限性
   2. 实现的方式更适合处理多个线程有共享数据的情况。用继承则需要将数据 static 

   相同点：

   两种方式都需要重写 run()，将线程要执行的逻辑声明在 run() 中。

   方式一的问题在于，需要让当前类继承 Thread，而 java 又是一个单继承的，这样的话为了创建多线程就会导致无法继承其他的类了。

3. 方式三：实现 callable 接口

   * 创建一个实现 callable 的实现类
   * 实现 call 方法，将此线程需要执行的操作声明在 call 中
   * 创建 callable 接口实现类的对象
   * 将此 callable 的接口实现类的对象作为参数传递到 FutureTask 的构造器中，创建 FutureTask 的对象
   * 将 FutureTask 的对象作为参数传递到 Thread 的构造器中，创建 Thread 对象，并调用 start()
   * (可选)获取 callable 的 call 方法的返回值

   如何理解实现 callable 接口的方式创建多线程比实现 runnable 接口创建多线程方式强大？

   1. Call() 可以有返回值
   2. Call() 可以抛出异常，被外面的操作捕获，从而获取异常的信息
   3. Callback 是支持泛型的

4. 方式四：使用线程池

   提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。

   1. 提高了响应速度（减少创建新线程的事件）

   2. 降低资源消耗（重复利用线程池中的线程，不需要每次都创建）

   3. 便于线程管理

      1. Corepoolsize：线程池的大小
      2. Maximumpoolsize:最大线程数
      3. Keepalivetime：线程没有任务时最多保持多长时间会终止

      Executor service：真正的线程池接口

      Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池。

## 29. 是否经历过从 0-1 的项目架构

## 30. okhttp 和 retrofit

* okhttp 设计模式：责任链、外观模式、享元模式、建造者模式

  **建造者模式**：

  * 定义：将负责对象的构建与表示分离。建造者将一个复杂对象的创建过程封装起来，允许对象通过多个步骤来创建，在对象特别复杂、内部参数很多时，建造者模式就能发挥出它的优势。

    若源码中有 builder 这个词，大概率使用了建造者模式。

  * okhttpclient

    Okhttpclient 常用的就只有默认模式，但其内部包含很多复杂对象：超时时间、代理、缓存、分发器、拦截器等等。

    ```java
    public class OkHttpClient implements Cloneable, Call.Factory, WebSocketCall.Factory {
    
      // 构造函数1
      public OkHttpClient() {
        this(new Builder()); 
      }  
    
      // 构造函数2
      private OkHttpClient(Builder builder) {
        ......
      }  
    
      public Builder newBuilder() {
        return new Builder(this);
      }
    
      // Builder类
      public static final class Builder {  
    
        public Builder() { }   
    
        Builder(OkHttpClient okHttpClient) { }  
    
        //Builder类的OkHttpClient
        public OkHttpClient build() {
          return new OkHttpClient(this);
        }  
      }  
    
    }
    ```

    newbuilder 函数作用：利用建造者模式实例化 okhttpclient 对象：

    ```java
    // 实例化一个默认的HTTP客户端
    OkHttpClient client = new OkHttpClient();
    // 使用自定义设置创建HTTP客户端实例
    OkHttpClient client = new OkHttpClient.Builder()
                                    .addInterceptor(new HttpLoggingInterceptor())  //增加拦截器
                                    .cache(new Cache(cacheDir, cacheSize))  //设置用于读取和写入缓存响应的响应缓存。
                                    .build();
    //  实例化一个500毫秒则超时的HTTP客户端实例                         
    OkHttpClient eagerClient = client.newBuilder()
                                    .readTimeout(500, TimeUnit.MILLISECONDS)
                                    .build();   
    ```

  * request

    Request 类通过建造者模式通过 request.builder 生成实例，其中 url 代表这个 http 请求的 url，method 指的是 get/post 等请求，header 和 body 自然就是 http 请求的首部和请求体，cacheControl 是缓存控制。

    ![](https://images.xiaozhuanlan.com/photo/2021/e407fc57eccb6bab3a3f3cf929a9e037.png)

    ```java
    public final class Request {
    
      private Request(Builder builder) {
        ......
      }
    
      public Builder newBuilder() {
        return new Builder(this);
      }
    
      public static class Builder {   
        private HttpUrl url;
        public Builder() {
          ......
        }
        private Builder(Request request) {
          this.url = request.url;
          ......
        }
        public Builder url(HttpUrl url) {}
        public Builder header(String name, String value) {}
        ......
        public Request build() {
          if (url == null) throw new IllegalStateException("url == null");
          return new Request(this);             
        }
      }
    
    }
    ```

  * response 类

    类似 request

  将对象的创建与表示相分离，builder 负责组装各项配置参数，并且生成对象，目标对象则对外提供接口，符合类的单一原则。

  **Okhttp 中的工厂模式**

  Okhttp 中的工厂模式的使用有 cachestrategy.factory，这是一个简单工厂模式，主要也是用于生成一个 cachestrategy 对象。

  ```java
  public static class Factory {
      .........
    public static class Factory {
      final long nowMillis;
      final Request request;
      final Response cacheResponse;
      .........
  
      public Factory(long nowMillis, Request request, Response cacheResponse) {
        this.nowMillis = nowMillis;
        this.request = request;
        this.cacheResponse = cacheResponse;
  
        if (cacheResponse != null) {
          this.sentRequestMillis = cacheResponse.sentRequestAtMillis();
          this.receivedResponseMillis = cacheResponse.receivedResponseAtMillis();
          Headers headers = cacheResponse.headers();
          for (int i = 0, size = headers.size(); i < size; i++) {
            String fieldName = headers.name(i);
            String value = headers.value(i);
            if ("Date".equalsIgnoreCase(fieldName)) {
              servedDate = HttpDate.parse(value);
              servedDateString = value;
            } else if ("Expires".equalsIgnoreCase(fieldName)) {
              expires = HttpDate.parse(value);
            } else if ("Last-Modified".equalsIgnoreCase(fieldName)) {
              lastModified = HttpDate.parse(value);
              lastModifiedString = value;
            } else if ("ETag".equalsIgnoreCase(fieldName)) {
              etag = value;
            } else if ("Age".equalsIgnoreCase(fieldName)) {
              ageSeconds = HttpHeaders.parseSeconds(value, -1);
            }
          }
        }
   	}
   	
      public CacheStrategy get() {
        CacheStrategy candidate = getCandidate();
  
        if (candidate.networkRequest != null && request.cacheControl().onlyIfCached()) {
          // We're forbidden from using the network and the cache is insufficient.
          return new CacheStrategy(null, null);
        }
  
        return candidate;
      }
  
      /** Returns a strategy to use assuming the request can use the network. */
      private CacheStrategy getCandidate() {
        // No cached response.
        if (cacheResponse == null) {
          return new CacheStrategy(request, null);
        }
  
        // Drop the cached response if it's missing a required handshake.
        if (request.isHttps() && cacheResponse.handshake() == null) {
          return new CacheStrategy(request, null);
        }
  
        // If this response shouldn't have been stored, it should never be used
        // as a response source. This check should be redundant as long as the
        // persistence store is well-behaved and the rules are constant.
        if (!isCacheable(cacheResponse, request)) {
          return new CacheStrategy(request, null);
        }
  
        CacheControl requestCaching = request.cacheControl();
        if (requestCaching.noCache() || hasConditions(request)) {
          return new CacheStrategy(request, null);
        }
  		.......
  
        if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
          ......
          return new CacheStrategy(null, builder.build());
        }
  
        // Find a condition to add to the request. If the condition is satisfied, the response body
        // will not be transmitted.
        String conditionName;
        String conditionValue;
        if (etag != null) {
          .....
        } else {
          return new CacheStrategy(request, null); // No condition! Make a regular request.
        }
  	......
        return new CacheStrategy(conditionalRequest, cacheResponse);
      }
      .........
    }
   }
  }
  ```

  工厂模式和建造者模式区别？

  建造者模式和工厂模式都是用于生成一个对象，都属于创建型的设计模式，但是他们的侧重点是有所不同的。可以看到工厂模式的生成对象的过程更复杂，侧重于对象的生成过程，而建造者模式更侧重于各个参数配置的组合，生成过程反而不那么复杂。

  **外观模式（门面模式）**

  定义：提供一个统一的接口去访问多个子系统的多个不同的接口，它为子系统中的一组接口提供一个统一的高层接口。也称外观模式。

  简单说就是提供一个类提供一些接口供客户端使用，隐藏内部调用的复杂性。okhttp 中提供了一个类 okhttpclient 来供用户使用，其内部关联了大量的对象，以及处理细节，但是用户只需要根据 okhttpclient 提供的接口使用即可。

  **策略模式：**

  策略模式的基本定义：定义一系列的算法，把每一个算法封装起来，并且使他们可互相替换。

  在 cacheinterceptor 中，在响应数据的选择中使用了策略模式，选择缓存数据还是选择网络访问数据。

* 责任链的链，添加 head、Json 是在哪个链

  Addintereeptor:自定义责任链

  Retryandfollowupinterceptor：重试与重定向拦截器。

  Bridgeinterceptor：用于桥接 request 和 response，主要就是依据 http 协议配置请求头，然后通过 chain.proceed() 发出请求，待结果返回后再构建响应结果。获取请求信息，根据 http 配置请求头。

  Cacheinterceptor：缓存，在无网络的情况下，如果用户自己设置了缓存拦截器，则获取用户自己缓存的 response，否则从 cachestrategy 获取 cacheresponse 和 network request。如果无网无缓存则返回失败的信息，如果无网有缓存则返回缓存的信息。如果有网络，则执行下一个拦截器，也就是请求网络，责任链执行完毕后，会返回最终响应数据，如果缓存存在，则更新缓存，如果缓存不存在，则加入到缓存中去。

  okhttp 的缓存是封装了一个 cache 类来实现具体的缓存逻辑，它利用 disklrucache，用磁盘上的有限大小空间进行缓存，按照 lru 算法进行缓存淘汰。

  connectInterceptor：建立连接，找到一个可用的 real connection，再利用 real connection 的输入、输出（buffered source 和 bufferedsink）创建 httpcodec 对象，供后面步骤使用。

  Callserverinterceptor：网络请求，核磁你工作都是由 httpcodec 执行完成，而 httpcodec 实际上利用的是 okio，而 okio 实际上还是用的 socket。

  Interceptor 的设计是一种分层的思想，每个 interceptor 就是一层。为什么要套这么多层呢？分层的思想在 tcp/ip 协议中就体现的淋漓尽致，分层简化了每一层的逻辑，每层只需要关注自己的职责（单一原则思想也在此体现），而每层之间通过约定的接口/协议进行合作（面向接口编程思想），共同完成复杂的任务。

* 动态代理和静态代理的区别

  **静态代理**

  静态代理在使用时，需要定义接口或者父类，被代理对象与代理对象一起实现相同的接口或者是继承相同的父类。

  需要注意的是：代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法。

  在使用静态代理时，被代理对象与代理对象需要一起实现相同的接口或者是继承相同的父类，因此要定义一个接口或抽象类。

  接口:IUserDao.java

  ```java
  /**
   * 接口
   */
  public interface IUserDao {
      void save();
  }
  ```

  目标对象：UserDao.java

  ```java
  /**
   * 接口实现
   * 目标对象
   */
  public class UserDao implements IUserDao{
      @Override
      public void save() {
          System.out.println("----已经保存数据！----");
      }
  }
  ```

  代理对象：UserDaoProxy.java

  ```java
  /**
   * 代理对象，静态代理
   */
  public class UserDaoProxy implements IUserDao{
      // 接收保存目标对象
      private IUserDao target;
      public UserDaoProxy(IUserDao target){
          this.target = target;
      }
  
      @Override
      public void save(){
          System.out.println("开始事务...");
          target.save(); // 执行目标对象的方法
          System.out.println("提交事务...");
      }
  }
  ```

  测试类：

  ```java
      public static void main(String[] args) {
          // 目标对象
          UserDao target = new UserDao();
          //代理对象，把目标对象传给代理对象，建立代理关系
          UserDaoProxy proxy = new UserDaoProxy(target);
          proxy.save(); // 执行的是代理的方法
      }
  ```

  * 静态代理总结

    优点：可以做到不修改目标对象的功能前提下，对目标功能扩展。

    缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类，类太多。同时，一旦接口增加方法，目标对象与代理对象都要维护。

  **动态代理**

  动态代理的特点就是能够在程序运行时 jvm 才为被代理对象生成代理对象。

  动态代理特点：1.代理对象，不需要实现接口，2.代理对象的生成，是利用 JDK 的 API，动态的在内存中构建代理对象，需要执行创建代理对象/目标对象实现的接口的类型。

  ```java
  /**
   * 创建动态代理对象
   * 动态代理不需要实现接口，但是需要指定接口类型
   */
  public class ProxyFactory {
  
      // 维护一个目标对象
      private Object target;
  
      public ProxyFactory(Object target) {
          this.target = target;
      }
  
      // 给目标对象生成代理对象
      public Object getProxyInstance() {
          return Proxy.newProxyInstance(
                  target.getClass().getClassLoader(), // 定义代理类的类加载器
                  target.getClass().getInterfaces() // 代理类要实现的接口列表
            ,
                  new InvocationHandler() {
                      @Override
                      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                          System.out.println("开始事务...");
                          Object returnValue = method.invoke(target, args);
                          System.out.println("提交事务...");
                          return returnValue;
                      }
                  }
          );
      }
  }
  ```

  动态代理总结：代理对象不需要实现接口，但是目标对象一定要实现接口，否则不能用动态代理，因此这也算是这种方式的缺陷。

  **动态代理与静态代理的区别**

  1. 静态代理通常只代理一个类，动态代理是代理一个接口下的多个实现类。
  2. 静态代理事先知道要代理的是什么，而动态代理不知道要代理什么东西，只有在运行时才知道。
  3. 动态代理是实现 JDK 里的 invocationhandler 接口的 invoke 方法，但注意的是代理的是接口，也就是你的业务类必须要实现接口，通过 proxy 的 newProxyInstance 得到代理对象。
  4. 还有一种动态代理 cglib，代理的是类，不需要业务类继承接口，通过派生的子类来实现代理。通过在运行时，动态修改字节码达到修改类的目的。

  * 动态代理和静态代理相比较，最大的好处就是接口中声明的所有的方法都被转移到一个集中的方法中去处理，就是 invoke() 方法，这样在接口中声明的方法比较多的情况下我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。
  * 动态代理只能代理接口，代理类都需要实现 invocationhandler 类，实现 Invoke 方法，该 invoke 方法就是调用被代理接口的所有方法时需要调用的，该 invoke 方法的返回值是被代理接口的一个实现类。

  静态代理：某个对象提供一个代理，代理角色固定，以控制对这个对象的访问。代理类和委托类有共同的父类或父接口，这样在任何委托类对象的地方都可以用代理对象替代。代理类负责请求的预处理、过滤、将请求分派给委托类处理、以及委托类执行完请求后的后续处理。

  静态代理的特点：1.目标角色固定；2.在应用程序执行前就得到目标角色；3.代理对象会增强目标对象的行为；4.有可能存在多个代理引起“类爆炸”（缺点）。

  动态代理：相比于静态代理，动态代理在创建代理对象上更加的灵活，动态代理类的字节码在程序运行时，由 Java 反射机制动态产生。它会根据需要，通过反射机制在程序运行期，动态的为目标对象创建代理对象，无须程序员手动编写它的源代码。

  动态代理的特点：1.目标对象不固定；2.在应用程序执行时动态创建目标对象；3.代理对象会增加目标对象的行为。

okhttp



## 31. https 与 http 的区别

1. http 是超文本传输协议，信息是明文传输，数据都是未加密的，安全性较差，连接很简单，是无状态的。

   Https 协议是由 ssl+http 协议构建的具有安全性的 ssl 加密、身份认证的传输协议，数据传输过程是加密的，安全性较好。

2. 使用 https 协议需要到 ca(数字证书认证机构)申请证书，一般免费证书很少，因此需要一定费用。

3. http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。

4. http 页面响应速度比 https 快，主要是因为 http 使用 tcp 三次握手建立连接，客户端和服务端需要交换 3 个包，而 https 除了 tcp 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。

5. https 其实就是建构在 ssl/tls 之上的 http 协议，所以，https 要比 http 更好肥服务器资源。

* https 的过程

1. 长链接

   * 轮询操作，但是轮询一般及时性比较差，而且网络消耗与电量消耗比较多，因此一般推送功能都是通过长链接实现的。

   * 使用第三方的长链接服务

     可以通过接入极光推送、百度推送、友盟等第三方服务实现长链接。

     优势：简单、方便

     劣势：定制化程度不高

   * 使用 NIO 等方案实现长连接服务

     通过 NIO 的方式实现长连接，这种方式对技术要求程度比较高，基本都是通过 java API 实现长连接，实现心跳包，实现异常情况的容错等操作，可以说通过 NIO 实现长连接对技术要求很高，一般如果没有成行的技术方案步建议这么做，就算实现了长连接，后期连接的维护，对电量、流量的损耗等都需要持续的优化。

     优势：定制化比较高

     劣势：技术要求高，需要持续的维护

   * 使用 MINA 等第三方框架实现长连接

     MINA 是一个第三方的 NIO 框架，该框架实现了一整套的长连接机制，包括长连接的建立、心跳包的实现、异常机制的容错等。使用 MINA 实现长连接可以定制化的实现一些特定的功能，并且比 NIO 方案较为简单，因为其已经封装了一些长连接的特有机制，比如心跳包、容错等。

     优势：可定制，较 NIO 方法简单

     劣势：也需要一定的技术储备

   * 使用 websocket

## 32. 做过哪些优化

* UI 优化

## 33. 大图片加载怎么做

摆正图片的加载内存不超过 100M 即可。

可以通过设置 options 对象的 insamplesize 减少采样率（达到之前的几分之一）

也可以通过设置 options 对象的 inpreferredconfig 为 bitmap.config.rgb_565。

```java
    /**
     * 获取Bitmap对象
     *
     * @param res   Resource对象
     * @param resId 图片资源ID
     * @return 返回Bitmap对象
     */
    private Bitmap decodeSampledBitmapFromResource(Resources res, int resId) {

        BitmapFactory.Options options = new BitmapFactory.Options();

        //亮点：不加载像素,不占用内存
        options.inJustDecodeBounds = true; //超大图缩放一般都有这样设置，否则在底层占用大量内存
        BitmapFactory.decodeResource(res, resId, options); //不加载内存的情况下，无返回值
        int height = options.outHeight; //图片的宽
        int width = options.outWidth; //图片的高

        //做一些其他的判断和处理，根据图片的宽高和View的宽高的情况，设置一些参数

		//关键点： Calculate inSampleSize 几分之一
        options.inSampleSize = 4;
        options.inPreferredConfig = Bitmap.Config.RGB_565; //默认是RGB_888

        options.inJustDecodeBounds = false; //设置为false，才会从底层申请到内存

        return BitmapFactory.decodeResource(res, resId, options);
    }


```

RGB_888到RGB_565，其实也是减少了采样率，大概是原图的5/8.

所有的大图加载[框架](https://so.csdn.net/so/search?q=框架&spm=1001.2101.3001.7020)都是用到了上面这段代码的思想：
第一次在不占用内存的情况加载测量图片的宽高，根据情况适配参数，第二次真正加载并设置相关参数。

* glide 设置显示大图是否会发生崩溃Glide加载大图不会发生崩溃 Glide里面会加载两次图片 第一次读取配置，比如图片原生宽高，设置options.inJustDecodeBounds属性设置为true，不占用内存 第二次结合布局的宽高设置图片设置理想的采样率比例。

* 大图缩放滑动如何实现

  ```java
  1、写一个自定义View加载图片
  2、设置setImage方法设置图片，测量图片宽高
  3、调用requestLayout()重新加载图片
  4、在onMeasure(...)方法中对比图片宽高和View的宽高，
  5、定义使用区域解码器、手势对象、缩放手势，缩放因子等对象
      //区域解码器
      private BitmapRegionDecoder mDecode;
  	 //手势对象
      private GestureDetector mGestureDetector;
      //缩放功能
      ScaleGestureDetector mScaleGestureDetector;
      //滑动帮助类
      private Scroller mScroller;
      //需要显示的区域
      private Rect mRect;
  	//图片缩放因子
      private float mScale;
  	
  6、在onDraw(...)做对应的缩放和区域滑动
  具体参考demo项目代码。
  ```

  demo中手写的大图缩放功能，并不是非常完善，
  试了下，部分大图正常显示和放大缩小，宽度较大的图片显示有问题，
  谁有需求可以参考大图缩放框架自己完善下。

## 34. 组件化

## 35. glide 

glide 如何跟踪生命周期

有哪些缓存

## 36. recyclerview 有哪些缓存

## 37. mvvm 

## 38. DataBinding 与 ViewBinding

* ViewBinding

ViewBinding：通过视图绑定，系统会为模块中的每个 XML 布局文件生成一个绑定类，通过绑定类，可以直接操作控件 id，而不需要 findViewById，这样可以避免控件 id 无效出现的空指针问题。

在模块的 build.gradle 中开启视图绑定：

```java
viewBinding {
enabled = true
}
```

新建 MainActivity，对应的布局文件名为：activity_main，编译后，系统会自动生成名为 ActivityMainBinding，在 activity_main.xml 添加一个文本框和一个按钮：

```xml
<EditText
android:id="@+id/ed_input"
android:layout_width="match_parent"
android:layout_height="wrap_content" />
<Button
android:id="@+id/btn_save"
android:layout_width="match_parent"
android:layout_height="wrap_content"
android:text="保存" />
```

接下来 修改 MainActivity 中的代码：

```kotlin
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
ActivityMainBinding activityMainBinding = ActivityMainBinding.inflate(LayoutInflater.from(this));
setContentView(activityMainBinding.getRoot());
}
```

接下来就可以直接使用 id 对应的控件了：

```kotlin
activityMainBinding.btnSave.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
String content = activityMainBinding.edInput.getText().toString();
Toast.makeText(MainActivity.this, content, Toast.LENGTH_SHORT).show();
}
});
```

ViewBinding只是为了替代findViewById，优点就是空安全，不过有了kotlin-android-extensions之后，ViewBinding用的应该比较少了吧。

* DataBinding

  数据绑定，之前我们需要通过获取控件，通过控件设置数据，现在有了数据绑定我们可以直接在布局文件中直接绑定数据。

  和 viewbinding 一样，使用前，首先在 build.gradle 中配置

  ```groovy
  dataBinding {
  enabled = true
  }
  ```

  新建 Main2Activity，对应布局如下：

  ```xml
  <layout xmlns:android="http://schemas.android.com/apk/res/android"
  xmlns:tools="http://schemas.android.com/tools"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  tools:context=".Main2Activity">
  </layout>
  ```

  使用数据绑定的 xml 文件根布局必须是 layout 标签，新建一个 User 类，有姓名和性别字段

  ```java
  public class User {
  ....
  private String userName;
  private String userGender;
  ....
  }
  ```

  首先通过 data 标签导入要绑定的数据

  ```xml
  <data>
  <variable
  name="user"
  type="com.example.jetpackdemo.bean.User" />
  </data>
  ```

  在 xml 中加入两个 textView 用来显示用户姓名和性别

  ```xml
  <LinearLayout
  android:layout_width="match_parent"
  android:layout_height="wrap_content"
  android:orientation="vertical">
  <TextView
  android:layout_width="match_parent"
  android:layout_height="wrap_content"
  android:text="@{user.userName}"
  android:textSize="17sp" />
  <TextView
  android:layout_width="match_parent"
  android:layout_height="wrap_content"
  android:text="@{user.userGender}"
  android:textSize="17sp" />
  </LinearLayout>
  ```

  通过@{}的引用方式设置数据

  在Main2Activity中通过如下方法 设置数据源：

  ```java
  ActivityMain2Binding activityMain2Binding = DataBindingUtil.setContentView(this, R.layout.activity_main2);
  User user = new User("黄林晴", "男");
  activityMain2Binding.setUser(user);
  ```

  运行程序如下所示：

  如果我们现在把性别改为null，则性别会直接不显示

  如果我们现在要求当性别为null的时候显示“未设置”要怎么做呢,我们可以在xml中进行判断

  在data标签下导入TextUtil 

  ```xml
  <import type="android.text.TextUtils" />
  <TextView
  android:layout_width="match_parent"
  android:layout_height="wrap_content"
  android:text='@{TextUtils.isEmpty(user.userGender)? "未设置": user.userGender}'
  android:textSize="17sp" />
  ```

  除了数据绑定外，还有监听事件绑定等，就不详细举例了。我们当前做的是静态数据绑定，很多时候我们都需要动态绑定，那么如何在数据变化的时候自动更新呢？

* 使用可观察的数据对象

  修改 User 类字段属性如下：

  ```java
  public class User {
  public final ObservableField<String> userName = new ObservableField<>();
  public final ObservableField<String> userGender = new ObservableField<>();
  }
  ```

  注意 这里必须定义为final类型，在Main2Activity中如下所示：

  ```java
  ActivityMain2Binding activityMain2Binding = DataBindingUtil.setContentView(this, R.layout.activity_main2);
  User user = new User();
  user.userName.set("黄林晴-初始值");
  user.userGender.set("男");
  activityMain2Binding.setUser(user);
  ```

  可以添加一个按钮，在按钮中重新设置 user 中的数据

  ```java
  btnChanged = findViewById(R.id.btn_change);
  btnChanged.setOnClickListener(new View.OnClickListener() {
  @Override
  public void onClick(View v) {
  user.userName.set("黄林晴-改变后的值");
  }
  });
  ```

  如此一来数据变化的时候我们控件上的数据也就可以变化了。

  * 可观察集合

    可观察集合常用于动态数据结构，使用 ObservableArrayMAp 访问键值类似 HashMap 中的数据访问。

  * 可观察对象

    和可观察数据字段和集合相比，我们最喜欢的应该是可观察对象了，这样我们就不需要受原有访问数据方法的限制。

  ```java
  public class User extends BaseObservable {
  private String userName;
  private String userGender;
  public User(String userName, String userGender) {
  this.userName = userName;
  this.userGender = userGender;
  }
  @Bindable
  public String getUserName() {
  return userName;
  }
  public void setUserName(String userName) {
  this.userName = userName;
  notifyPropertyChanged(BR.userName);
  }
  @Bindable
  public String getUserGender() {
  return userGender;
  }
  public void setUserGender(String userGender) {
  this.userGender = userGender;
  notifyPropertyChanged(BR.userGender);
  }
  }
  ```

  我们让 User 类继承自 BaseObservable，使用 Bindable 注解注册通知，当值改变的时候通过 notifyPropertyChanged() 发送通知，为 BR 类是数据绑定生成的一个用于数据绑定的资源的 ID 的类。在 Main2Activity 中同样的设置初始值，点击按钮改变值：

  ```java
  ActivityMain2Binding activityMain2Binding = DataBindingUtil.setContentView(this, R.layout.activity_main2);
  User user = new User("黄林晴-可变对象", "男");
  activityMain2Binding.setUser(user);
  btnChanged = findViewById(R.id.btn_change);
  btnChanged.setOnClickListener(new View.OnClickListener() {
  @Override
  public void onClick(View v) {
  user.setUserName("黄林晴-数据更新");
  }
  });
  ```

  Android Studio 3.1 及更高版本允许用 LiveData 对象替换可观察字段，结合 JetPack 的使用，数据通知都推荐使用 LiveData 了。

* 区别

  1. 目的不同。ViewBinding 的出现仅仅是为了帮开发人员省去写 findViewById 的步骤；而 DataBinding 是用于绑定数据的，能够把视图的数据和代码变量绑定起来，并且实现自动更新。这个特性使得 DataBinding 能和 MVVM 框架进行很好的配合。
  2. 初始化方式不同。ViewBinding 通过生成的 Binding 类的 inflate 方法来加载布局，然后还需要用 Activity 的 setContentView() 方法来绑定。而 DataBinding 则是通过 DataBindingUtil.setContentView() 来绑定的。
  3. 包含关系。DataBinding 也有 ViewBinding 的功能，也可以省去 findViewById() 方法。

## 39. 内存抖动

## 40. 如何适配

## 41. 常用动画有哪些？

## 42. IPC 方式

## 43. Kotlin

## 44. 常用的设计模式

工厂模式、观察者模式、责任链模式、单例模式、适配器模式、装饰者模式

## 45. 网络协议知道哪些

Tcp：传输控制协议，是一种面向连接的、可靠的、基于字节流的通信协议，通过三次握手建立连接，通讯完成时要断开连接，由于 TCP 是面向连接的所以只能用于端到端的通讯。

Udp：用户数据报协议，是面向无连接的通讯协议，可以实现广播发送。

tcp 和 udp 都是传输层协议。

Ip 协议提供不可靠、无连接的传动服务。网络层协议。ip 协议的主要功能有：无连接数据包传输、数据报路由选择和差错控制。

http 超文本传输协议，https:超文本传输安全协议。

## 46. 弱网状态如何判断

## 47. 内存泄漏与内存溢出

内存溢出是指当对象的内存占用已经超过可分配内存的空间大小，系统不能满足需求，这时未经处理的异常就会抛出。

内存溢出的原因：

1. 内存泄漏
2. 保存了多个占用内存较多的对象，比如加载单个超大的图片。

如果避免 oom：

1. 减少对象的内存占用，尽量使用更加轻量的对象，比如使用 arraymap 代替 hashmap，使用 insamplesize 缩放比例和 decode format 减少 Bitmap 对象的内存占用
2. 内存对象的重复利用，复用系统自带资源，listview 和 gridview 使用 covertview 复用，避免在 ondraw 方法里面执行对象的创建
3. 避免对象的内存泄漏

## 48. view 绘制流程

## 49. java 设计模式的 7 个法则

1. 单一职责：一个类应该只负责一项职责。

2. 接口隔离原则：客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。
3. 依赖倒置原则：抽象不应该依赖细节，细节应该依赖抽象，高层模块不应该依赖底层底层模块，二者都应该依赖其抽象
4. 里氏替换原则：所有引用基类的地方必须能透明地使用其子类的对象。
5. 开闭原则：对扩展开发，对修改关闭
6. 迪米特法则：一个对象应该对其他对象保持最少的了解。
7. 合成复用原则：尽量使用合成/集成的方式，而不是使用集成。

## 50. 如何做 app 实时数据变更

## 51. webview 的优化

## 52. 什么是反射，反射的优缺点

Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意方法和属性，这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。

反射就是把 Java 类中各个部分，映射成一个个的 java 对象，拿到这些对象后可以做一些事情。

优点：反射提高了程序的灵活性和扩展性，降低耦合性，提高自适应能力。它允许程序创建和控制任何类的对象，无须提前硬编码目标类。

缺点：

1. 性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和扩展性要求很高的系统框架上，普通程序不建议使用。
2. 使用反射会模糊程序内部逻辑：程序员希望在源代码中看到程序的逻辑，反射等绕过了源代码的技术，因而会带来维护问题。反射代码比相应的直接代码更复杂。至于执行效率的话，还可以，因为他是一种强类型语言，执行效率不错。不过，建议将反射过后，保存进 cache 中。

性能：反射包括了一些动态类型，所以 jvm 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低的多。应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。

安全：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 applet，那么这就是个问题了。

成员的内部暴露：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用 -- 代码有功能上的错误，降低可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。

## 53. Retrofit 优点

* 功能强大：支持同步 & 异步、支持多种数据的解析 & 序列化格式、支持 rxjava。
* 简洁易用：通过注解配置网络请求参数、采用大量设计模式简化使用
* 可扩展性好：功能模块高度封装、解耦彻底，如自定义 converters（自定义转换器）等等。

## 54. okhttp 核心，拦截的使用

## 55. contentprovider 



## 56. AIDL 的通信流程

* AIDL 文件编译

  AIDL 文件 IMyAidlInterface.aidl 在客户端和服务端都有，编译时，都会在 “build\generated\aidl_source_output_dir\debug\out\kim\hs\aidl_demo” 目录生成 IMyAidlInterface.java 源文件。

  这样在客户端与服务端都可以调用 IMyAidlInterface.Stub 类的相关方法，主要是 asInterface 方法，用于获取远程服务或代理。

* 注册服务

  在应用中，通过绑定 service 注册服务

  ```java
  // 通过 Action 和 包名 , 绑定远程服务
          Intent intent = new Intent("android.intent.action.MyService");
          intent.setPackage("kim.hsl.aidl_demo");
          bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);
  ```

* IMyAidlInterface.Stub.asInterface 方法获取远程服务

  开启一个 ServiceConnection，在 serviceConnection 的 onserviceconnected 方法中，调用 IMyAidlInterface.asInterface 方法，在 IMyAidlInterface.Stub.asInterface 方法中，传入我们需要的 service 远程服务，这里涉及到跨进程调用，拿到的是一个代理。

  stub 中定义了 asinterface 方法，该方法的作用是将 android.os.IBinder 对象转为 AIDL 接口对象；传入的 DESCRIPTOR 描述符，用于描述用户想要哪个 binder，android.os.ibinder 对象调用 queryLocalInterface 方法，检查本地服务是否存在。

  如果可以找到本地服务对应的接口，可以直接返回本地服务；

  如果没有找到本地服务，就会返回一个 stub 代理。

  详细的过程参考下面的代码：

  ```java
  /**
       * 将IBinder对象强制转换为kim.hsl.aidl_demo.IMyAidlInterface接口，必要时生成代理。
       */
      public static kim.hsl.aidl_demo.IMyAidlInterface asInterface(android.os.IBinder obj)
      {
        if ((obj==null)) {
          return null;
        }
        // 传入 DESCRIPTOR 描述符 , 用于描述用户想要哪个 Binder
        // android.os.IBinder 对象调用 queryLocalInterface 方法 , 检查本地服务
        android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
        // 如果可以找到本地服务对应的接口 , 可以直接返回本地服务 
        if (((iin!=null)&&(iin instanceof kim.hsl.aidl_demo.IMyAidlInterface))) {
          return ((kim.hsl.aidl_demo.IMyAidlInterface)iin);
        }
        // 如果没有找到本地服务 , 就会返回一个 Stub 代理 
        return new kim.hsl.aidl_demo.IMyAidlInterface.Stub.Proxy(obj);
      }
  ```

* IMyAidlInterface.Stub.Proxy 代理类

上述 IMyAidlInterface.Stub.asInterface 方法 , 最终返回一个代理 , 代理如下 :

在 IMyAidlInterface.java 中的代理中 , 实现了 3 个 AIDL 接口方法 ;

```java
private static class Proxy implements kim.hsl.aidl_demo.IMyAidlInterface
    {
      private android.os.IBinder mRemote;
      Proxy(android.os.IBinder remote)
      {
        mRemote = remote;
      }
      @Override public android.os.IBinder asBinder()
      {
        return mRemote;
      }
      public java.lang.String getInterfaceDescriptor()
      {
        return DESCRIPTOR;
      }
      /**
           * Demonstrates some basic types that you can use as parameters
           * and return values in AIDL.
           */
      @Override public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException
      {
      }
      /**
           * in 写入, out 输出, inout 写入和输出
           */
      @Override public void addStudent(kim.hsl.aidl_demo.Student student) throws android.os.RemoteException
      {
      }
      /**
           * 获取 Student 集合
           */
      @Override public java.util.List<kim.hsl.aidl_demo.Student> getStudents() throws android.os.RemoteException
      {
        return _result;
      }
    }
```

* IMyAidlInterface.stub.proxy 代理类方法执行

在主应用中，调用 IMyAidlInterface aid 也就是 IMyAidlInterface.Stub.asInterface 方法返回的代理对象的 addStudent 方法，分析代理中的该方法，寿险生成输入和输出数据，传参和反参都会传入 mRemote.transact 方法中，这时 Binder 的方法：

```java
/**
           * in 写入, out 输出, inout 写入和输出
           */
      @Override public void addStudent(kim.hsl.aidl_demo.Student student) throws android.os.RemoteException
      {
        // 通过 Parcel 池获得两个对象 , 分别用于输入和输出
        // 输入对象
        android.os.Parcel _data = android.os.Parcel.obtain();
        // 输出对象
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          if ((student!=null)) {
            _data.writeInt(1);
            student.writeToParcel(_data, 0);
          }
          else {
            _data.writeInt(0);
          }
          // 调用 Binder 的 transact 方法 
          boolean _status = mRemote.transact(Stub.TRANSACTION_addStudent, _data, _reply, 0);
          if (!_status && getDefaultImpl() != null) {
            getDefaultImpl().addStudent(student);
            return;
          }
          _reply.readException();
          if ((0!=_reply.readInt())) {
            student.readFromParcel(_reply);
          }
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
```

* binder.transact 方法执行

Binder 中的 transact 方法执行后 , 会回调 IMyAidlInterface.java 中的 Stub 内部类的 onTransact 方法 ,Binder 的 transact 方法 ; 进入该方法后 , 会将原来的线程挂起 , 直到返回 , 原来的线程才会继续执行 , 这里非常容易出现 ANR ;

```java
/**
 * 远程对象的基类，由{@link IBinder}定义的轻量级远程过程调用机制的核心部分。
 * 此类是IBinder的一个实现，它提供了此类对象的标准本地实现。
 *
 * <p>大多数开发人员不会直接实现这个类，
 * 而是使用<a href=“{@docRoot}guide/components/aidl.html”>aidl</a>工具来描述所需的接口，
 * 让它生成适当的Binder子类。
 * 然而，您可以直接从Binder派生来实现您自己的定制RPC协议，
 * 或者直接实例化一个原始Binder对象，将其用作可以跨进程共享的令牌。
 *
 * <p>这个类只是一个基本的IPC原语；
 * 它对应用程序的生命周期没有影响，并且只有创建它的进程继续运行时才有效。
 * 要正确使用此功能，您必须在顶级应用程序组件（a{@link android.app.Service}、
 * {@link android.app.Activity}或{@link android.content.ContentProvider}）
 * 的上下文中执行此操作，该组件应保持运行。</p>
 *
 * <p>您必须记住流程可能会消失的情况，因此需要稍后重新创建新的活页夹，
 * 并在流程再次启动时重新附加它。
 * 例如，如果您在{@link android.app.Activity}中使用此函数，
 * 则您的活动的进程可能会在活动未启动时被终止；
 * 如果以后重新创建活动，则需要创建新的活页夹，
 * 并再次将其交回正确的位置；
 * 您需要注意的是，您的流程可能由于其他原因（例如接收广播）而启动，
 * 这将不涉及重新创建活动，因此运行其代码以创建新的绑定。</p>
 *
 * @see IBinder
  */
public class Binder implements IBinder {
    /**
     * 默认实现回放地块并调用onTransact。在远程端，transact调用绑定器来执行IPC。
     */
    public final boolean transact(int code, @NonNull Parcel data, @Nullable Parcel reply,
            int flags) throws RemoteException {
        if (false) Log.v("Binder", "Transact: " + code + " to " + this);
        if (data != null) {
            data.setDataPosition(0);
        }
        boolean r = onTransact(code, data, reply, flags);
        if (reply != null) {
            reply.setDataPosition(0);
        }
        return r;
    }
}
```

* IMyAidlInterface.Stub.onTransact 方法执行

  在 IMyAidlInterface.Stub.onTransact 方法中，通过方法对应的 ID 常量值匹配方法，在该方法中就会调用 IMyAidlInterface.Stub 中没有实现的抽象方法。

  ```java
  @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException
      {
        java.lang.String descriptor = DESCRIPTOR;
        switch (code)
        {
          case INTERFACE_TRANSACTION:
          {
            reply.writeString(descriptor);
            return true;
          }
          case TRANSACTION_basicTypes:
          {
            return true;
          }
          case TRANSACTION_addStudent:
          {
            return true;
          }
          case TRANSACTION_getStudents:
          {
            return true;
          }
          default:
          {
            return super.onTransact(code, data, reply, flags);
          }
        }
      }
  ```

* 调用 service 中实现的 IMyAidlInterface.Stub 抽象方法

  IMyAidlInterface.Stub 中的抽象方法，在 service 中实现：

```java
/**
     * 创建 IMyAidlInterface.Stub 抽象类子类对象 , 实现其中的 3 个抽象方法
     * Binder 调用 transact 方法时 , 会调用 IMyAidlInterface.Stub 的 onTransact 方法
     * 在 IMyAidlInterface.Stub.onTransact 方法中会调用下面实现的抽象方法
     */
    private IMyAidlInterface.Stub stub = new IMyAidlInterface.Stub() {
        @Override
        public void basicTypes(int anInt, long aLong,
                               boolean aBoolean, float aFloat, double aDouble,
                               String aString) throws RemoteException {
            Log.i(TAG, "anInt=" + anInt + " , aLong=" + aLong +
                    " , aBoolean=" + aBoolean + " , aFloat=" + aFloat +
                    " , aDouble=" + aDouble + " , aString=" + aString);
        }
        @Override
        public void addStudent(Student student) throws RemoteException {
            if (students != null) {
                students.add(student);
            }
        }
        @Override
        public List<Student> getStudents() throws RemoteException {
            return students;
        }
    };
```



## 57. 对 AMS 的理解

## 58. 对 Application 的理解

## 59. 做项目中遇到的难点

## 60. 类加载器 classloader 

* PathClassLoader 和 DexClassLoader 的区别

* 类加载的双亲委托机制

  类加载器 classloader 接收到类加载任务之后，自己不会先进行加载，反而将该类加载任务委托父类类加载器执行。

  父类类加载器接收到该类加载任务之后，也会委托父类的父类类加载执行。

  委托操作会一直传递到最顶层的启动类加载器 bootstrap classloader。

  如果启动类加载器 bootstrap classloader 完成了类加载操作，返回加载的类。

  如果启动类加载器 bootstrap classloader 无法完成类加载操作，就会将类加载任务委托给子类完成。

  同理，父类委托给子类的类加载任务，如果子类类加载器可以完成加载，成功返回，如果子类类加载无法完成加载，就在此将类加载任务委托给子类的子类，继续向下传递。

  向上委托：每个儿子都不想加载类，类加载任务到来后，优先将任务委托父类去做，父类又交给父类的父类去做。

  向下委托：加入父类无法加载类，则再交给儿子去做，儿子尝试加载，如果也无法加载，儿子再交给孙子去做。

  双亲委派模式优点：

  * 避免了类重复加载：如果某 class 已经加载过了，通过该机制，可以直接读取出已经加载的类。
  * 安全性强：系统类无法被替代，系统类只能由启动类加载器 bootstrap classloader 加载，应用类加载器加载被篡改的 java 核心类是无效的。

* 类加载步骤

  * 装载：加载某个类时，首先要查找并导入 class 字节码文件。
  * 链接：该阶段可以分为以下 3 个子阶段：
    * 验证：验证字节码文件是否正确
    * 准备：为静态变量划分内存空间，并进行默认值赋值
    * 解析：将“常量池”中的“符号引用”转为“直接引用”
  * 初始化：调用 Clint 函数，初始化静态变量、静态代码块。

  ![](https://img-blog.csdnimg.cn/ea081467c8c345c6b170af7999f2b983.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Z-p5puZ5Lqu,size_20,color_FFFFFF,t_70,g_se,x_16)

* Android 中的八大类加载器

  ![](https://img-blog.csdnimg.cn/fcd9efc5182b4b10bc700ee47036b0c3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Z-p5puZ5Lqu,size_20,color_FFFFFF,t_70,g_se,x_16)

  * ClassLoader 抽象类

    ClassLoader 是抽象类，是所有类加载 classloader 的父亲。

  * BootClassLoader

    BootClassLoader 是 ClassLoader 子类，与 Java 虚拟机中的 BootstrapLoader 启动类加载器作用相同，用于加载 Java 核心类库。

    BootClassLoader 是单例类，全局唯一。

    BootClassLoader 是由 Java 代码实现的，这与 JVM 中的启动类加载器不同。

  * BaseDevClassLoader

    加载 Dex 字节码文件的业务逻辑就是在 BaseDexClassLoader 中实现的。

    BaseDexClassLoader 的 3 个子类：

    * InMemoryDexClassLoader
    * PathClassLoader
    * DexClassLoader

    没有实现核心业务逻辑，只是调用父类的方法，进行不同类型的操作。

  * PathClassLoader

    PathClassLoader 是 BaseDexClassLoader 子类，应用中的类，都是由 PathClassLoader 进行加载。

    Android 系统相关的类，如四大组件、Android 自带类，都是由 PathCladdLoader 加载的。

    PathClassLoader 用来加载系统 APK 和被安装到手机中 APK 内的 dex 文件。

  * DexClassLoader

    DexClassLoader 是 BaseDexClassLoader 的子类，该类可以加载任意目录下的 DEX 或 JAR 格式的字节码文件。

    热修复就是加载 SD 卡中的 DEX 文件，插件化也是加载 SD 卡中的APK 文件中的 DEX 文件。

    DexClassLoader 在动态字节码技术、热修复、插件化、DEX 加固等方面使用广泛。

    对比 PathClassLoader 只能加载已安装的 apk 或者 dex 文件，DexClassLoader 则没有此限制。可以从 sdcard 上加载 .apk 和 .dex 文件，这也是热修复和插件化的基础。在不需要安装应用的情况下，完成需要使用的 dex 加载。

  * InMemoryDexClassLoader

    InMemoryDexClassLoader 类加载器继承了 BaseDexClassLoader 类。

    主要用在加载内存中的 Dex 字节码文件，在 Android 8.0 中加入到系统中。

  * SecureClassLoader

    SecureClassLoader 继承了 ClassLoader 抽象类，该类主要实现了一些权限相关的功能。

  * URLClassLoader

    URLClassLoader 是 SecureClassLoader 的子类，其可以使用 url 路径加载 JAR 文件中的类。

  

## 61. handler 发送延迟 1 秒的消息，调整手机时间到1分钟后，会不会立即收到消息

不影响，Handler 的延迟消息计算是通过 SystemClock 类来计算的，跟系统时间没有任何关系，这是根据 Handler 自启动以来非睡眠正常运行时间的毫秒数和代码指定的 postDelayed 的时间来计算的。

## 62. kotlin

## 63. mvp 与 mvvm 的优缺点

## 64. Okhttp、retrofit 

okhttp 在网络上的优化，请求参数减少网络请求的性能。

https://blog.csdn.net/m0_70083062/article/details/124643493

DNS 不仅支持 UDP，它还支持 TCP，但是大部分标准的 DNS 都是基于 UDP 与 DNS 服务器的，



## 65. kotlin

## 66. 多线程与多进程

多线程的使用：下载安装使用的线程池，

线程池的使用，有什么优化吗？

进程之间的通信有什么方式？

## 67. 调用微信登陆的通信方式

广播

## 68. 常用的设计模式

Okhttp 参数的创建使用了什么设计模式？构建者模式

## 69. 内存优化

## 70. Https 如何确定公钥的安全性？

数字证书内容包括了加密后服务器的公钥、权威机构的信息、服务器域名，还有经过 CA 私钥签名之后的证书内容（经过先通过 hash 函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名）、签名计算方法以及证书对应的域名。

* 验证证书安全性过程

  1. 当客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务器的公钥和证书的数字签名，数字签名经过 CA 公钥解密得到证书信息摘要。
  2. 然后证书签名的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过，因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。

  那第三方攻击者能够让自己的证书显示出来的信息也是服务端呢？（伪装服务器一样的配置）显然这个是不行的，因为当第三方攻击者去 CA 那边寻求认证的时候 CA 会要求其提供域名的 whoid 信息，域名管理邮箱等证明是服务端域名的拥有者，而第三方攻击者是无法提供这些信息，所以就无法骗 CA 拥有服务端的域名。

* 对客户端的验证

  对于非常重要的保密数据，服务端还需要对客户端进行验证，以保证数据传送给了安全的合法的客户端。服务端可以向客户端发出 cerficate request 消息，要求客户端发送证书给客户端的合法性进行验证。比如，金融机构往往只允许认证客户端连入自己的网络，就会向正式客户端提供 USB 密钥，里面就包含了一张客户端证书。

## 71. 对 GC 的理解，如何保证对象不再使用后能够快速的垃圾回收掉（弱引用）

## 72. UI 适配除了常规方式，还有哪些特别的方法

## 73. 反射的应用

一个类中的每个成员都可以用相应的反射 API 的一个实例对象来表示-反射机制。

可以利用反射机制在 Java 程序中，动态的去调用一些 protected 甚至是 private 的方法会类，这样可以很大程度上满足一些比较特殊的需求。例如 Activity 的启动过程中 Activity 的对象的创建。

Java 的动态加载的机制就是通过 ClassLoader 来实现的，ClassLoader 也是实现反射的基石。ClassLoader 是 Java 提供的一个类，用来加载 Class 文件到 JVM，以供程序使用的。

## 74. 组件化通信方式

## 75. 面向对象，多态的实现

多态：不同子类的相同属性的值不同、相同方法的实现不同（通过方法的重写）。

好处：避免子类的发展被多态限制。

## 76. ArrayList 与 LinkedList 区别，是否是线程安全的，如果保证线程安全

区别：

* ArrayList 是基于动态数组的数据结构，LinkedList 是基于链表的数据结构。ArrayList 数据满的时候需要扩容，但 LinkedList 不需要。

* 对于随机访问 get 和 set，ArrayList 要优于 LinkedList，因为 LinkedList 要移动指针；对于新增和删除操作 add 和 remove，LinkedList 比较占优势，因为 ArrayList 要移动数据。

  对于随机访问，ArrayList 是线性表（数组），get() 直接获取第几个下标，时间负责度 o(1)，linkedlist 是链表的操作，get() 获取第几个元素，依次遍历，时间复杂度为 o(n)。

  而对于增加和删除，ArrayList add(E) 添加元素，直接在后面添加，时间复杂度为 o(1)，add(intde,e)添加元素，在第几个元素后面插入，后面的元素需要向后移动，复杂度 o(n)，remove() 删除元素，后面的元素需要逐个移动，时间复杂度为 o(n)。

  对于增加和删除，LinkedList add(E)添加到末尾，时间复杂度为 o(1)，add(index,e) 添加第几个元素后，需要先查找到第几个元素，直接指针指向操作，复杂度为 o(n)，remove() 删除元素，直接指针指向操作，复杂度为 o(1)。

* ArrayList 的内存浪费主要体现在在 List 列表的结尾预留一定的容量空间，而 LinkedList 的内存浪费体现在它的每一个元素都需要消耗相当的空间（指向前后的指针）。

* 如果能预估 ArrayList 大概长度，设置默认容量，防止频繁扩容，优先使用 ArrayList，此时查询、新增性能都比较好，但如果存在频繁删除操作时优先使用 LinkedList。

是否是线程安全的：不安全

如何实现线程安全：

* 继承 ArrayList，然后重写或按要求编写自己的方法，这些方法要写成 synchronized，在这些 synchronized 的方法中调用 ArrayList 的方法。
* 使用 Collections.synchronizedList() 使用方法如下：

```java
// 假如你创建的代码如下：List<Map<String,Object>> data=new ArrayList<Map<String,Object>>();

// 那么为了解决这个线程安全问题你可以这么使用Collections.synchronizedList()，如：

List<Map<String,Object>> data=Collections.synchronizedList(new ArrayList<Map<String,Object>>());
```

## 77. 反射，反射的作用

java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意方法和属性，这种动态获取信息以及动态调用对象方法的功能称为 java 语言的反射机制。

## 78. 内存模型，堆与栈

* 程序计数器

  程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

* java 虚拟机栈

  java 虚拟机栈是线程私有的，它的生命周期和线程相同。虚拟机栈描述的是 java 方法执行的线程内存模型：每个方法被执行的时候，java 虚拟机都会同步创建一个栈帧（stack frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

  局部变量表存放了编译器可知的各种 java 虚拟机基本数据类型（boolean、byte、char、）、对象应用和 returnAddress 类型。

* 本地方法栈

  本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则是为虚拟机使用到的本地方法服务。

* Java 堆

  Java 堆是虚拟机所管理的内存中最大的一块。

  Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。

  此内存区域的唯一目的就是存放对象实例。

* 方法区

  方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

* 运行时常量池

  运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译器生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

  

## 79. 响应式编程，Rxjava，map 和 flapMap 的区别

Map 可以将一类型 A 转换为另一个人一类型 B，而 flatmap 只能转化为发送事件序列的 Observable 对象。

Map 直接将数据类型 A 转为数据类型 B，而 flatmap 转换为 observable 对象后会发送相应的事件，所以 map 在下游中接收到的就是数据类型 B，而 flatmap 在下游中接收到的是转化后的 Observable 对象发送的事件序列。

## 80. 动态代理，代理模式

代理是一种设计模式。提供了间接对目标对象进行访问的方式，即通过代理对象访问目标对象。这样做恶的好处是：可以在目标对象实现的基础上，增加额外的功能操作，即扩展目标对象的功能。



## 81. 常用的设计模式

## 82. 讲一下快排的思想

快速排序是一种分治法思想在排序算法上的典型应用。

快速排序的主要思想是：在待排序的序列中选择一个称为主元的元素，将数组分为两部分，使得第一部分中的所有元素都小于火等于主元，而第二部分中的所有元素都大于主元，而第二部分中的所有元素都大于主元，然后对两部分递归地应用快速排序算法，这个歌排序过程可以递归进行，以此达到整个数据变成有序序列。

## 83. 数据库

## 84. 讲一个项目

## 85. mvp、mvvm

如何绑定监听：livedata。observer

mvp:

mvp 彻底解决了 MVC 中 View 和 Controller 傻傻分不清楚的问题，但是随着业务逻辑的增加，一个页面可能会非常复杂，UI 的改变是非常大的，会有非常多的 case，这样就会造成 View 接口会很庞大。

mvvm：

Model：进行数据的获取、网络请求、数据库操作等。数据的获取、存储、数据状态变化都是 mdeol 层的任务。model 包括实体模型（Bean）、获取网络数据接口，本地存储（增删改查）接口，数据变化监听的。model 提供数据获取接口供 ViewModel 调用。

```kotlin
class MyModel {

    fun changNumber(current: Int, up: Boolean, callback: ModelDataCallBack<Int>) {
        callback.onSucceed(if (up) current + 1 else current - 1)
    }


    interface ModelDataCallBack<T> {

        fun onSucceed(data: T)

        fun onFailed(failedMsg: String, failedCode: String)
    }
}
```

ViewModel 层：数据的整体封装处理，为 UI 层提供相应数据。比如获取到的数据根据相应条件进行过滤、对数据进行业务操作处理等。

ViewModel 只做和业务逻辑和业务数据相关的事，不做任何和 UI 相关的事情，ViewModel 层不会持有任何控件的引用，更不会在 ViewModel 中通过 UI 控件的引用去做更新 UI 的事情。

```java
class MyViewModel : ViewModel(){

    private val _changeNumber = MutableLiveData<Int>()
    val changeNumber: LiveData<Int>
        get() = _changeNumber

    private val model = lazy { MyModel() }

    fun getNumber(currentNumber: Int, up: Boolean) {
        model.value.changNumber(currentNumber, up, object : MyModel.ModelDataCallBack<Int> {
            override fun onSucceed(data: Int) {
                _changeNumber.value = data
            }

            override fun onFailed(failedMsg: String, failedCode: String) {
            }

        })
    }
}
```

View 层：View 层则为相应的 Activity、Fragment，主要进行数据的展示，把数据填充到 UI 上，在 View 层中不做任何的数据处理，ViewModel 层传递什么数据过来就使用什么数据，尽量降低耦合。View 层不做任何业务逻辑、不涉及操作数据、不处理数据，UI 和数据严格的分开。

```kotlin
class ActivityDemo : AppCompatActivity(){

    private lateinit var mViewModel: MyViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_demo)
        mViewModel = ViewModelProvider(this)[MyViewModel::class.java]
        //mViewModel = MyViewModel()
        initObserver()
        initEvent()
    }

    //初始化注册观察者
    private fun initObserver() {
        mViewModel.changeNumber.observe(this, Observer {
            demo_tv.text = it.toString()
        })
    }

    private fun initEvent() {
        demo_btn_down.setOnClickListener {
            mViewModel.getNumber(demo_tv.text.toString().toInt(), false)
        }
        demo_btn_up.setOnClickListener {
            mViewModel.getNumber(demo_tv.text.toString().toInt(), true)
        }
    }
}
```

优点：

* ViewModel 跟随 Activity、Fragment 生命周期，ViewModel 的生命周期如下，所以即使 Activity 异常重建的时候，ViewModel 也不会被销毁。
* 搭配 LiveData 可实现的观察者模式与生命周期绑定观察，能够解决以往的内存泄漏问题。（一些由持有 Context、Activity 所引起的内存泄漏）
* UI 层与业务逻辑层分离，各自不影响，耦合低。
* 进行单元测试可以针对 ViewModel 进行测试。

## 86. 打开优化做了什么

## 87. constraintLayout， group 

![](/Users/miaomiao/Desktop/android/android_learning_notes/plan/面试/面试题/image/ConstraintLayout.png)

## 88. Room 讲一下，升级什么做的，其他升级方式知道吗

Room 简介：Room 持久性在 SQLite 的基础上提供了一个抽象层，让用户能够在充分利用 SQLite 的强大功能的同时，获享更强健的数据库访问机制。

升级方式：

第一种方式：

* 创建 Migration

  ```
      private static final Migration MIGRATION_1_2 = new Migration(1, 2) {
          @Override
          public void migrate(@NonNull SupportSQLiteDatabase database) {
              //在这里做升级操作，比如增加或者减少表中的字段
              database.execSQL("ALTER TABLE emperor_table ADD COLUMN gender TEXT");
          }
      };
  
  ```

* 添加到构建数据库的实例中

  ```java
  .addMigrations(MIGRATION_1_2)//可以添加多个参数，以便从1->2,2->3,1->3
  ```

* 最新版本号指定

  ```java
  @Database(entities = {Emperor.class}, version = 2)
  ```

自动升级数据库

https://www.jianshu.com/p/7ce5b2c3c301

* 设置 room 数据库生成表的 sql 语句，这一步非常重要

  ```groovy
  defaultConfig {
          javaCompileOptions {
              annotationProcessorOptions {
                  arguments += [
                          "room.schemaLocation":"$projectDir/schemas".toString(),
                          "room.incremental":"true",
                          "room.expandProjection":"true"]
              }
          }
      }
  ```

* 基本的配置好了以后就可以正常的来增加注解来配置数据的哭的自动升级了

  ```java
  @Database(entities = {UserBean.class, SchoolsBean.class},
          exportSchema = true,
          version = 8,
          autoMigrations = {
                  @AutoMigration(from = 4, to = 5),//数据库升级版本注解
                  @AutoMigration(from = 5, to = 6),
                  @AutoMigration(from = 6, to = 7),
                  @AutoMigration(from = 7, to = 8),
          }
  )
  public abstract class MainDatabase extends RoomDatabase {
  ```

* 如果需要在表里中新增一个字段如 test 字段，只需要增加一个 @ColumnInfo 注解，并为其赋一个默认值

  ```java
  @Entity(tableName = "t_user")
  public class UserBean {
  
      @PrimaryKey(autoGenerate = true)
      private long _id;
      private String name;
      private int age;
      private String info;
  
      @ColumnInfo(defaultValue = "0")
      private int test;
      .....
  }
  ```

  配置完成后，项目中会存在多个 json 文件，这个事本地数据库各个版本的 sql 语句，请注意，这些 json 文件需要保存不能删除，否则下次升级会找不到上一个数据库的文件，导致自动升级失败。

## 89. EventBus

Broadcast 是否也可以实现

* EventBUs 能做的 BroadcastReceiver 都能做到，两个都是属于发布/订阅模式。

  EventBus 设计之处是用于同一进程的消息发送和接收，BroadcastReceiver 可以在不同进程间发送和接收消息。

  EventBus 在同一线程中发布和接收是同步调用，如果发布和订阅在不同线程间调用是异步的。BroadcastReceiver 则都属于异步调用。

  EventBus 通过反射来调用订阅方法有些性能的缺失，但是对于同一进程的消息传递的方便和代码解耦来说还是值得一用的。

* 本地广播是相对消耗时间、空间最多的一种方式，系统级的事件都是通过广播来通知的，比如说网络的变化、电量的变化、短信发送和接收的状态，所以，如果与 android 系统进行相关的通知，还是要选择本地广播；在 broadcastReceiver 的 onReceive 方法中，可以获得 context、intent 参数，这两个参数可以调用许多的 sdk 中的方法，而 eventbus 获得这两个参数相对比较困难；因此广播相对于其他的方式而言，广播是重量级的、消耗资源较多的方式。他的优势体现在与 sdk 连接紧密，如果需要同 android 交互的时候，广播的便捷性会抵消掉它过多的资源消耗，但是如果不同 android 交互，或者说，只做很少的交互，使用广播是一种浪费。

EventBus 作为 Android 开发中常用的框架，拥有者许多优点：

* 调度灵活。不依赖于 context，使用时不需像广播一样关注 context 的注入与传递。父类对于通知的监听和处理可以继承给子类，这对于简化代码至关重要；通知的优先级，能够保证 Subcriber 关注最重要的通知；粘滞事件（sticky events）能够保证通知不会因 Subsctiber 的不在场而忽略。可继承、优先级、粘滞，是 EventBus 比之于广播、观察者等方式最大的优点，它们使得创建结构良好组织紧密的通知系统成为可能。

* 使用简单。EventBus 的 Subscriber 注册非常简单，调用 eventBus 对象的 register 方法即可，如果不想创建 eventBus 还可以直接调用静态方法 EventBus.getDefault() 获取默认实例，Subcriber 接收到通知之后的操作放在 onEvent 方法里就行了。成为 Publisher 的过程就更简单了，只需要调用合适的 eventBus（自己创建的或是默认的）的 post 方法即可。

* 快速且轻量。作为 github 的明星项目之一，EventBus 的源代码中许多技巧来改善性能，eventBus 的缺点是他的代码逻辑不是很清楚，在 subscriber 注册的时候，Subscriber 中的方法会被遍历查找以 onEvent  开头的 public 方法。这将带来一些问题，一旦对代码进行混淆，就无法查找到了。好消息是 EventBus 已经打算使用注解来实现了，这应该能够解决代码混淆的问题。

  但有一个缺点是观察者独有的，那就是观察者可能会造成接口的膨胀。特别是当程序要求大量形成各异的通知，而程序员没有作出良好的抽象时，代码中会包含大量的接口，接口数量的增加又会带来命名、注释等等一大堆问题。本质上说观察者要求程序员从零开始实现事件的产生、分发与处理过程，这就要求参与者必须对整个通知过程有着良好的理解。当程序代码适量时，这是一个合理的要求，然而当程序太大时，这将成为一种负担。

EventBus 是一个发布 / 订阅的事件总线。简单点说，就是两人约定好怎么通信，一人发布消息，另外一个约定好的人立马接收到你发的消息。EventBus 就可以帮减少很多事，不管你在任何地方任何位置发布一个事件，接收者都能立马接收到你的消息，不用你考虑 android 子线程操作 UI 线程的问题。

## 90. 讲一下四大组件

## 91. 重载和重写，实现了java 的什么特性

## 92. handler

### 1. 简述 handler



### 2. 一个线程只有一个 handler 吗？只有一个 looer 吗？

一个线程可以有多个 handler，只有一个 looper。



### 3. loop() 方法死循环，UI 线程没有 ANR？

因为 looper 获取消息的时候会阻塞等待，有新消息来的时候会唤醒。

### 4. sendMessageDelay 与 sendMessageAtTime 的区别

這兩句是等效的，都是延時1秒將消息加入列隊

msgHandle.sendMessageAtTime(msg, SystemClock.uptimeMillis()+1000);

msgHandle.sendMessageDelayed(msg, 1000)

sendMessageAtTime的uptimeMillis是相對系統開機時間的絕對時間，SystemClock.uptimeMillis()是當前開機時間。

sendMessageAtTime 使用的uptimeMillis依赖的是系统以开机时间的绝对时间；

而sendMessageDelayed使用的delayMillis依赖的是系统以开机时间的相对时间。

啥意思呢：就是说delayMillis使用的时候要加一个SystemClock.uptimeMillis(),

也就是sendMessageAtTime等于snedMessageDelayed的情况为uptimeMillis == delayMillis - SystemClock.uptimeMillis()[这是一个相对时间].
SystemClock.uptimeMillis()是获取系统从开机启动到现在的时间,期间不包括休眠的时间,这里获得到的时间是一个相对的时间,而不是通过获取当前的时间(绝对时间)。

而之所以使用这种方式来计算时间，而不是获得当前currenttime来计算，在于handler会受到阻塞，挂起状态，睡眠等，这些时候是不应该执行的；如果使用绝对时间的话，就会抢占资源来执行当前handler的内容，显然这是不应该出现的情况，所以要避免。

查看源码：

```java
    /**
     * Enqueue a message into the message queue after all pending messages
     * before (current time + delayMillis). You will receive it in
     * {@link #handleMessage}, in the thread attached to this handler.
     *  
     * @return Returns true if the message was successfully placed in to the 
     *         message queue.  Returns false on failure, usually because the
     *         looper processing the message queue is exiting.  Note that a
     *         result of true does not mean the message will be processed -- if
     *         the looper is quit before the delivery time of the message
     *         occurs then the message will be dropped.
     */
    public final boolean sendMessageDelayed(Message msg, long delayMillis)
    {
        if (delayMillis < 0) {
            delayMillis = 0;
        }
        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
    }
```

```java
    /**
     * Enqueue a message into the message queue after all pending messages
     * before the absolute time (in milliseconds) <var>uptimeMillis</var>.
     * <b>The time-base is {@link android.os.SystemClock#uptimeMillis}.</b>
     * You will receive it in {@link #handleMessage}, in the thread attached
     * to this handler.
     * 
     * @param uptimeMillis The absolute time at which the message should be
     *         delivered, using the
     *         {@link android.os.SystemClock#uptimeMillis} time-base.
     *         
     * @return Returns true if the message was successfully placed in to the 
     *         message queue.  Returns false on failure, usually because the
     *         looper processing the message queue is exiting.  Note that a
     *         result of true does not mean the message will be processed -- if
     *         the looper is quit before the delivery time of the message
     *         occurs then the message will be dropped.
     */
    public boolean sendMessageAtTime(Message msg, long uptimeMillis)
    {
        boolean sent = false;
        MessageQueue queue = mQueue;
        if (queue != null) {
            msg.target = this;
            sent = queue.enqueueMessage(msg, uptimeMillis);
        }
        else {
            RuntimeException e = new RuntimeException(
                this + " sendMessageAtTime() called with no mQueue");
            Log.w("Looper", e.getMessage(), e);
        }
        return sent;
    }
```



### 5. 介绍一下 ThreadLocal



## 93. view 的绘制流程



## 94. postInvalidate、invalidate、requestLayout

●  requestLayout()：该方法会递归调用父窗口的requestLayout()方法，直到触发ViewRootImpl的performTraversals()方法，此时mLayoutRequested为true，会触发onMesaure()与onLayout()方法，不一定会触发onDraw()方法。

●  invalidate()：该方法递归调用父View的invalidateChildInParent()方法，直到调用ViewRootImpl的invalidateChildInParent()方法，最终触发ViewRootImpl的performTraversals()方法，此时mLayoutRequested为false，不会触发onMesaure()与onLayout()方法，但是会触发onDraw()方法。

●  postInvalidate()：该方法功能和invalidate()一样，只是它可以在非UI线程中调用。

一般来说需要重新布局就调用requestLayout()方法，需要重新绘制就调用invalidate()方法。

一、invalidate和postInvalidate

　　这两个方法都是在重绘当前控件的时候调用的。invalidate在UI线程中调用，postInvalidate在非UI线程中调用。因为android的UI线程是非线程安全的，所以在非UI线程中，需要使用postInvalidate来使View重绘。view调用invalidate将导致当前view的重绘（draw调用），view的父类将不会执行draw方法；viewGroup调用invalidate会使viewGroup的子view调用draw，也就是viewGroup内部的子view进行重绘；

 

二、requestLayout

　　requestLayout方法只会导致当前view的measure和layout，而draw不一定被执行，只有当view的位置发生改变才会执行draw方法，因此如果要使当前view重绘需要调用invalidate。

 

三、onLayout

　　在很多情况下requestLayout是不需要被调用的。例如，我们把一个AbsoluteLayout里面的childView挪动一下位置。我们仅仅需要调用的可能就是重新布局当前AbsoluteLayout，然后调用invalidate方法进行重绘。而不是从当前View向上的整个View树形结构都要重新layout，onLayout，measure，onMeasure一次。在这种情况下可以直接调用onLayout。然后调用invalidate进行重绘。很明显可以提升绘制效率。由于父View的layout实现中对会通知布局的listener。但是由于无法得到listener，因此调用onlayout的时候无法对其进行通知，这也是这种实现的缺陷。

requestLayout：

从方法名字可以知道，“请求布局”，那就是说，如果调用了这个方法，那么对于一个子View来说，应该会重新进行布局流程。但是，真实情况略有不同，如果子View调用了这个方法，其实会从**View树重新进行一次测量、布局、绘制这三个流程**，最终就会显示子View的最终情况。

invalidate：

当子View调用了invalidate方法后，会为该View添加一个标记位，同时不断向父容器请求刷新，父容器通过计算得出自身需要重绘的区域，直到传递到ViewRootImpl中，最终触发performTraversals方法，进行开始View树重绘流程(只绘制需要重绘的视图)。

![](https://images2015.cnblogs.com/blog/554581/201706/554581-20170622000240538-1481075813.png)

postInvalidate：

postInvalidate是在非UI线程中调用，invalidate则是在UI线程中调用。 

## 95. view 布局刷新的方式

https://www.jianshu.com/p/497d6897c989

反射调用 invalidateInternal 传递 上下左右四个坐标进行刷新。

## 96. view 的事件分发

核心三个方法：dispatchTouchEvent 、onInterceptTouchEvent、onTouchEvent

Window.CallBack接口中包含了 dispatchTouchEvent 和 onTouchEvent 方法，Activity和Dialog都实现了Window.CallBack接口，因此都实现了该方法。

**1、dispatchTouchEvent**

1.1、事件分发的核心方法，事件分发的逻辑都是在这个方法中实现;
 1.2、View、以及 ViewGroup、其他的实现类都重写了该方法；
 1.3、如果成功处理则返回true，处理失败则返回false，表示事件没有被处理。
 1.4、在view的相关类中，该方法的主要作用是消费触摸事件。
 1.5、在viewGroup相关类中，该方法的主要作用是把事件分发到该viewGroup所拥有的子view，如果子view没有处理则自己处理；

**2、onInterceptTouchEvent**

2.1、方法只存在于viewGroup中，当一个事件需要被分发到子view时，viewGroup会调用此方法检查是否要进行拦截。如果拦截则自己处理，而如果不拦截才会调用子view的 dispatchTouchEvent 方法分发事件；
 2.2、方法返回true表示拦截事件，返回false表示不拦截；

**3、onTouchEvent**

3.1、方法返回true表示消费事件，返回false表示不消费事件；
 3.2、viewGroup分发事件时，如果没有一个子view消费事件，那么会调用viewGroup自身的onTouchEvent方法来处理事件。
 3.3、View的dispatchTouchEvent方法中，先调用onTouchListener判断是否消费；如果onTouchListener没有消费事件，才会调用onTouchEvent来处理事件；



一个触控点的事件序列只能给一个view消费，除非发生异常情况；

![](https://upload-images.jianshu.io/upload_images/1659355-4e34c92bac04410d.png)



#### onTouch 和onTouchEvent 的区别

onTouchListener的onTouch方法优先级比onTouchEvent高，会先触发。
 假如onTouch方法返回false，会接着触发onTouchEvent，反之onTouchEvent方法不会被调用。
 内置诸如click事件的实现等等都基于onTouchEvent，假如onTouch返回true，这些事件将不会被触发。

#### 事件是先到DecorView还是先到Window

ViewRootImpl -> DecorView -> Activity -> PhoneWindow -> DecorView -> ViewGroup

## 97. SharedPreferences

### 存储对象的方法

1. 可以使用gson保存和检索对象列表将用户定义对象的列表保存到SharedPreferences

2. SharedPreferences 存储对象是将对象转化为字节流，然后写入本地xml文件中； 读取时，从xml文件中读取字节流然后转化为对象。

   存储对象流程：

   1. 对象必须实现 Serializable 序列化，不能使用 Parcelable 序列化，因为 out.writeObject 无法写入 Parcelable 序列化的对象
   2. 将序列化的对象转为字节流
   3. 通过将字对象进行用Base64转码，写入sp中
   4. 通过key读取到编码后的字节流，并进行Base64解码
   5. 将解码后的 String 反序列化，返回对象

### SharedPreferences 是否支持多进程，如果实现多进程的使用

Context类中的getSharedPreferences()

接收两个参数，第一个参数指定存储数据的文件，若指定文件不存在，则新建该文件，存放目录为"/data/data/package_name/shared_prefs/"，其中package_name为包名。

第二个参数则为操作模式，主要有两种：

MODE_PRIVATE：私有模式，默认情况下的模式，与直接传入0作为参数效果一样，表示只有当前程序可对这个文件进行操作。

MODE_MULTI_PROCESS：多进程模式，允许多个进程对该文件进行操作。

### commit 和 apply 的区别

Android提供了一个简单快捷的保存键值对到文件的类SharedPreferences。通过SharedPreferences读写参数会遇到一些问题：

API25中，apply方法的注释。大致意思就是apply是一个原子请求(不需要担心多线程同步问题)。commit将同步的把数据写入磁盘和内存缓存。而apply会把数据同步写入内存缓存，然后异步保存到磁盘，可能会执行失败，失败不会收到错误回调。如果你忽略了commit的返回值，那么可以使用apply替换任何commit的实例。
简单说就是除非你需要关心xml是否写入文件成功，否则你应该在所有调用commit的地方改用apply。
SharedPreferences是个单例，所以任意Context拿到的都是同一个实例。
SharedPreferences在实例化的时候会把SharedPreferences对应的xml文件内容全部读取到内存。
对于非多进程兼容的SharedPreferences的读操作是从内存读取的，不涉及IO操作。写入的时候由于内存已经保存了完整的xml数据，然后新写入的数据也会同步更新到内存，所以无论是用commit还是apply都不会影响立即读取。
我们需要对SharedPreferences在包装一层内存缓存来提高性能吗？完全不需要，因为SharedPreferences本身已经做了内存缓存。

## 98. 设计模式

### 适配器优缺点，项目中的使用

　　适配器模式包含如下角色：

* Target：目标抽象类
* Adapter：适配器类
* Adaptee：适配者类
* Client：客户类

**优点**

* 将目标类和适配者类解耦，通过引入一个适配器类来重现现有的适配者类，而无须修改原有代码。
* 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户款来说是透明的，而且提高了适配者的复用性。
* 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。

　　**类适配器模式还具有如下优点：**由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。

　　**对象适配器模式还具有如下优点：**一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。

**缺点：**

　　**类适配器模式的缺点：**对于 Java 、C# 等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口。

　　**对象适配器模式的缺点如下：**与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。

## 99. 内存优化，性能优化

### 如何寻找内存优化的点和性能优化的点



## 100. retrofit 的原理

## 101. retrofit



## 102. 做过哪些优化



## 103. gc

### 如何标记可回收的对象

1. 引用计数算法：在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为 1。当任何其它变量被赋值为这个对象的引用时，计数加 1（a = b,则 b 引用的对象实例的计数器 +1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减 1。任何引用计数器为 0 的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减 1。
2. 可达性分析算法：程序把所有的引用关系看作一张图，从一个节点 GC ROOT 开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。

  在 Java 语言中，可作为 GC Roots 的对象包括下面几种：

1. 虚拟机栈中引用的对象（栈帧中的本地变量表）；
2. 方法区中类静态属性引用的对象；
3. 方法区中常量引用的对象；
4. 本地方法栈中 JNI（Native方法）引用的对象。



## 104. 知道哪些锁



### 读写锁



## 105. TouchEvent 除了 down、move、up 还有哪些

MotionEvent的事件类型主要有：
public static final int ACTION_DOWN = 0;
public static final int ACTION_UP = 1;
public static final int ACTION_MOVE = 2;
public static final int ACTION_CANCEL = 3;
public static final int ACTION_OUTSIDE = 4;
public static final int ACTION_POINTER_DOWN = 5;
public static final int ACTION_POINTER_UP = 6;
①ACTION_DOWN：第一个手指按下时
②ACTION_MOVE：按住一点在屏幕上移动
③ACTION_UP：最后一个手指抬起时
④ACTION_CANCEL：不是由用户直接触发，而是由系统在需要的时候触发，例如子view接收到了down事件，但是在move的时候，父view通过onInterceptTouchEvent()返回true，拦截了该事件流，从子view拿回了处理事件的控制权，这时候子view就会收到一个ACTION_CANCEL事件，并且子view再也不会收到后续事件了，后续事件都交给父view来处理了。
简单来说，根据ViewGroup分发事件的机制，一般来说，如果一个子视图接收了父视图分发给它的ACTION_DOWN事件，那么与ACTION_DOWN事件相关的事件流就都要分发给这个子视图，但是如果父视图希望拦截其中的一些事件，不再继续转发事件给这个子视图的话，那么就需要给子视图一个ACTION_CANCEL事件。
⑤ACTION_OUTSIDE：表示用户触碰超出了正常的UI边界。
官方解释：A movement has happened outside of the normal bounds of the UI element. This does not provide a full gesture, but only the initial location of the movement/touch.
一个触摸事件在UI元素的正常范围之外发生。因此不再提供完整的手势，只提供 运动/触摸 的初始位置。
正常情况下，如果初始点击位置在该视图区域之外，该视图根本不可能会收到事件。然而，总有一些特殊情况，比如点击 Dialog 区域外关闭，Dialog就是一个特殊的视图(没有占满屏幕大小的窗口)，能够接收到视图区域外的事件(虽然在通常情况下你根本用不到这个事件)。
当然，想要接收到视图之外的事件需要一些特殊的设置，即设置视图的 WindowManager 布局参数的 flags为FLAG_WATCH_OUTSIDE_TOUCH ，这样点击事件发生在这个视图之外时，该视图就可以接收到一个 ACTION_OUTSIDE事件。
⑥ACTION_POINTER_DOWN：用户又使用一个手指触摸到屏幕上，也就是说，在已经有一个触摸点的情况下，又新出现了一个触摸点。
⑦ACTION_POINTER_UP：用户的一个手指离开了触摸屏，但是还有其他手指还在触摸屏上。也就是说，在多个触摸点存在的情况下，其中一个触摸点消失了。
它与ACTION_UP的区别就是，它是在多个触摸点中的一个触摸点消失时产生，而ACTION_UP是最后一个触摸点消失时产生。
⑧MotionEvent.ACTION_SCROLL：android3.1引入，非触摸滚动，主要是由鼠标、滚轮、轨迹球触发。

## 106. Bundle，one way 怎么理解

oneway 代表这个 binder 接口是异步调用。

## 107. 设计模式



## 108. window、Activity、View  讲一下



## 109. hashmap 的数据结构



## 110. java int、short 的字节数

Short: 2 个字节

Int：4 个字节

char: 2 个字节

float : 4 个字节

Long：8 个字节

Double：8 个字节

## 111. TCP 四次挥手的过程

## 112. 熟悉的 Java 设计模式

### 1. 讲一下构建者模式，创建构建者模式

## 113. AppStore 

## 114. 单例模式

## 115. voliate 的实现原理



## 116. handle 机制，消息如何区别是谁发出的



## 117. 自定义 view

## 118. ANR timeout 分类

## 119. APP 优化，UI 优化

## 120. 熟悉的布局

## 121. hashmap，以及它的默认大小

## 122. Java 存储变量

静态变量，布局变量的区别，存储在哪里（栈还是堆）

## 123. jetpack

## 124. 了解的存储有哪些

Acahce,sql,mmkv?

## 125. 布局优化如何做

## 126. 布局由两个线性布局组成，用 Relativelayout 还是 linearlayout

## 127. Image 的展示

## 128. mvvm

livedata 生命周期如何获取？

## 129. surfaceVuew 了解吗

## 130. surface 与 activity 的关系

## 131. mvp

## 132. web 调用 android 和 android 调用 web

## 133. 设计模式

## 134. Activity 的 singleinstance

## 135. Intent 大小限制，aidl 传递数据的发小限制

## 136. 实现定时任务的方式

Rxjava，handle，

### 1. 20ms 执行一次，需要时间精确，用什么实现？

## 137. Window、decorview 的关系，window 是一个 activity 吗？

## 138. 热修复

## 139. dex 文件

## 140. hashmap 与 hashTable 的区别

## 141. stringbuilder、stringbuffer

## 142. https 证书里面有什么信息

## 143. listview 与 recyclerview 的区别

## 144. Git pull rebase

## 145. webview

## 146.websocket

## 147. glide 内存缓存大小

## 148. bundle 的原理，用什么做的内存映射

## 149. Java rn,flutter

## 150. 方法执行过程的内存

## 151. 渲染系统，机制

## 152. so 动态路、静态库

