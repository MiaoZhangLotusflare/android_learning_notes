## 学习资料

C# 教程：[https://www.runoob.com/csharp/csharp-operators.html](https://www.runoob.com/csharp/csharp-operators.html)

## C# 运算符

运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C# 有丰富的内置运算符，分类如下：

- 算术运算符 +、-、*、/、%、++、--
- 关系运算符 ==、!=、>、<、>=、<=
- 逻辑运算符 &&、||、!
- 位运算符 &、|、^、~、<<、>>
- 赋值运算符 =、+=、-=、*=、/=、%=、<<=、>>=、&=、^=、|=
- 其他运算符 sizeof()、typeof()、&、*、?:、is、as
  
  | 运算符                                   | 描述                  | 实例                                          |
  | ------------------------------------- | ------------------- | ------------------------------------------- |
  | sizeof()                              | 返回数据类型的大小。          | sizeof(int)，将返回 4.                          |
  | typeof()                              | 返回 class 的类型。       | typeof(StreamReader);                       |
  | &                                     | 返回变量的地址。            | &a; 将得到变量的实际地址。                             |
  | *                                     | 变量的指针。              | *a; 将指向一个变量。                                |
  | ? :                                   | 条件表达式               | 如果条件为真 ? 则为 X : 否则为 Y                       |
  | is                                    | 判断对象是否为某一类型。        | If( Ford is Car) // 检查 Ford 是否是 Car 类的一个对象。 |
  | as                                    | 强制转换，即使转换失败也不会抛出异常。 | Object obj = new StringReader("Hello");     |
  | StringReader r = obj as StringReader; |                     |                                             |

## C# 判断

判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。
判断语句：if 语句、if...else 语句、嵌套 if 语句、switch 语句、嵌套 switch 语句。
?:运算符：Exp1？Exp2：Exp3，可用来替代 if...else 语句。

## C# 循环

循环语句允许我们多次执行一个语句或语句组。
循环类型：while 循环、for/foreach 循环、do...while 循环、嵌套循环
循环控制语句：break 语句、continue 语句
无限循环：如果条件永远不为假，则循环将变成无限循环。**for** 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。

## C# 封装

**封装** 被定义为"把一个或多个项目封闭在一个物理的或者逻辑的包中"。在面向对象程序设计方法论中，封装是为了防止对实现细节的访问。
抽象和封装是面向对象程序设计的相关特性。抽象允许相关信息可视化，封装则使开发者_实现所需级别的抽象_。
C# 封装根据具体的需要，设置使用者的访问权限，并通过 **访问修饰符** 来实现。
一个 **访问修饰符** 定义了一个类成员的范围和可见性。C# 支持的访问修饰符如下所示：

- public：所有对象都可以访问；
- private：对象本身在对象内部可以访问；
- protected：只有该类对象及其子类对象可以访问
- internal：同一个程序集的对象可以访问；
- protected internal：访问限于当前程序集或派生自包含类的类型。

默认访问修饰符为 private。

## C# 方法

一个方法是把一些相关的语句组织在一起，用来执行一个任务的语句块。每一个 C# 程序至少有一个带有 Main 方法的类。

### 参数传递

当调用带有参数的方法时，您需要向方法传递参数。在 C# 中，有三种向方法传递参数的方式：

| 方式   | 描述                                                                               |
| ---- | -------------------------------------------------------------------------------- |
| 值参数  | 这种方式复制参数的实际值给函数的形式参数，实参和形参使用的是两个不同内存中的值。在这种情况下，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全。 |
| 引用参数 | 这种方式复制参数的内存位置的引用给形式参数。这意味着，当形参的值发生改变时，同时也改变实参的值。                                 |
| 输出参数 | 这种方式可以返回多个值。                                                                     |

在 C# 中，使用 **ref** 关键字声明引用参数。使用 out 关键字声明输出参数。

## C# 可空类型

### C# 单问号 ? 与双问号 ??

**?** 单问号用于对 **int、double、bool** 等无法直接赋值为 null 的数据类型进行 null 的赋值，意思是这个数据类型是 Nullable 类型的。

```java
int? i = 3;
```

等同于：

```java
Nullable<int> i = new Nullable<int>(3);
```

```java
int i; //默认值0 
int? ii; //默认值null
```

**??** 双问号用于判断一个变量在为 null 的时候返回一个指定的值。

### C# 可空类型（Nullable）

C# 提供了一个特殊的数据类型，**nullable** 类型（可空类型），可空类型可以表示其基础值类型正常范围内的值，再加上一个 null 值。
例如，Nullable< Int32 >，读作"可空的 Int32"，可以被赋值为 -2,147,483,648 到 2,147,483,647 之间的任意值，也可以被赋值为 null 值。类似的，Nullable< bool > 变量可以被赋值为 true 或 false 或 null。
在处理数据库和其他包含可能未赋值的元素的数据类型时，将 null 赋值给数值类型或布尔型的功能特别有用。例如，数据库中的布尔型字段可以存储值 true 或 false，或者，该字段也可以未定义。

### Null 合并运算符（??）

Null 合并运算符用于定义可空类型和引用类型的默认值。Null 合并运算符为类型转换定义了一个预设值，以防可空类型的值为 Null。Null 合并运算符把操作数类型隐式转换为另一个可空（或不可空）的值类型的操作数的类型。
如果第一个操作数的值为 null，则运算符返回第二个操作数的值，否则返回第一个操作数的值。

```java
num3 = num1 ?? 5.34;      // num1 如果为空值则返回 5.34
```

## C# 数组（Array）

数组是一个存储相同类型元素的固定大小的顺序集合。数组是用来存储数据的集合，通常认为数组是一个同一类型变量的集合。
所有的数组都是由连续的内存位置组成的。最低的地址对应第一个元素，最高的地址对应最后一个元素。
当您创建一个数组时，C# 编译器会根据数组类型隐式初始化每个数组元素为一个默认值。例如，int 数组的所有元素都会被初始化为 0。

## C# 字符串

在 C# 中，您可以使用字符数组来表示字符串，但是，更常见的做法是使用 **string** 关键字来声明一个字符串变量。string 关键字是 **System.String** 类的别名。

### C# string.Format 格式化日期

```java
DateTime dt = new DateTime(2017,4,1,13,16,32,108);
string.Format("{0:y yy yyy yyyy}",dt); //17 17 2017 2017
string.Format("{0:M MM MMM MMMM}", dt);//4  04 四月 四月
string.Format("{0:d dd ddd dddd}", dt);//1  01 周六 星期六
string.Format("{0:t tt}", dt);//下 下午
string.Format("{0:H HH}", dt);//13 13
string.Format("{0:h hh}", dt);//1  01
string.Format("{0:m mm}", dt);//16 16
string.Format("{0:s ss}", dt);//32 32
string.Format("{0:F FF FFF FFFF FFFFF FFFFFF FFFFFFF}", dt);//1 1  108 108  108   108    108
string.Format("{0:f ff fff ffff fffff ffffff fffffff}", dt);//1 10 108 1080 10800 108000 1080000
string.Format("{0:z zz zzz}", dt);//+8 +08 +08:00

string.Format("{0:yyyy/MM/dd HH:mm:ss.fff}",dt);　　//2017/04/01 13:16:32.108
string.Format("{0:yyyy/MM/dd dddd}", dt);　　　　　　//2017/04/01 星期六
string.Format("{0:yyyy/MM/dd dddd tt hh:mm}", dt); //2017/04/01 星期六 下午 01:16
string.Format("{0:yyyyMMdd}", dt);　　　　　　　　　//20170401
string.Format("{0:yyyy-MM-dd HH:mm:ss.fff}", dt);　//2017-04-01 13:16:32.108
```

除去string.Format()可以对日期进行格式化之外，DateTime.ToString()也可以实现相同的效果。

## C# 结构体

在 C# 中，结构体是值类型数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。**struct** 关键字用于创建结构体。
为了定义一个结构体，您必须使用 struct 语句。struct 语句为程序定义了一个带有多个成员的新的数据类型。
例如，您可以按照如下的方式声明 Book 结构：

```java
struct Books
{
   public string title;
   public string author;
   public string subject;
   public int book_id;
};  
```

### C# 结构的特点

您已经用了一个简单的名为 Books 的结构。在 C# 中的结构与传统的 C 或 C++ 中的结构不同。C# 中的结构有以下特点：

- 结构可带有方法、字段、索引、属性、运算符方法和事件。

- 结构可定义构造函数，但不能定义析构函数。但是，您不能为结构定义无参构造函数。无参构造函数(默认)是自动定义的，且不能被改变。

- 与类不同，结构不能继承其他的结构或类。

- 结构不能作为其他结构或类的基础结构。

- 结构可实现一个或多个接口。

- 结构成员不能指定为 abstract、virtual 或 protected。

- 当您使用 **New** 操作符创建一个结构对象时，会调用适当的构造函数来创建结构。与类不同，结构可以不使用 New 操作符即可被实例化。

- 如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。
  
  ### 类 vs 结构
  
  类和结构有以下几个基本的不同点：

- 类是引用类型，结构是值类型。

- 结构不支持继承。

- 结构不能声明默认的构造函数。

C# 中结构类型和类类型在语法上非常相似，他们都是一种数据结构，都可以包括数据成员和方法成员。
**结构和类的区别：**

- 1、结构是值类型，它在栈中分配空间；而类是引用类型，它在堆中分配空间，栈中保存的只是引用。
- 2、结构类型直接存储成员数据，让其他类的数据位于堆中，位于栈中的变量保存的是指向堆中数据对象的引用。

C# 中的简单类型，如int、double、bool等都是结构类型。如果需要的话，甚至可以使用结构类型结合运算符运算重载，再为 C# 语言创建出一种新的值类型来。
由于结构是值类型，并且直接存储数据，因此在一个对象的主要成员为数据且数据量不大的情况下，使用结构会带来更好的性能。
因为结构是值类型，因此在为结构分配内存，或者当结构超出了作用域被删除时，性能会非常好，因为他们将内联或者保存在堆栈中。当把一个结构类型的变量赋值给另一个结构时，对性能的影响取决于结构的大小，如果结构的数据成员非常多而且复杂，就会造成损失，接下来使用一段代码来说明这个问题。
结构和类的适用场合分析：

- 1、当堆栈的空间很有限，且有大量的逻辑对象时，创建类要比创建结构好一些；
- 2、对于点、矩形和颜色这样的轻量对象，假如要声明一个含有许多个颜色对象的数组，则CLR需要为每个对象分配内存，在这种情况下，使用结构的成本较低；
- 3、在表现抽象和多级别的对象层次时，类是最好的选择，因为结构不支持继承。
- 4、大多数情况下，目标类型只是含有一些数据，或者以数据为主，使用结构比较好。
  
  ## C# 枚举
  
  枚举是一组命名整型常量。枚举类型是使用 **enum** 关键字声明的。
  C# 枚举是值类型。换句话说，枚举包含自己的值，且不能继承或传递继承。

## C# 类

当你定义一个类时，你定义了一个数据类型的蓝图。这实际上并没有定义任何的数据，但它定义了类的名称意味着什么，也就是说，类的对象由什么组成及在这个对象上可执行什么操作。对象是类的实例。构成类的方法和变量称为类的成员。
类的默认访问标识符是 **internal**，成员的默认访问标识符是 **private**。

### C# 中的析构函数

类的 **析构函数** 是类的一个特殊的成员函数，当类的对象超出范围时执行。
析构函数的名称是在类的名称前加上一个波浪形（~）作为前缀，它不返回值，也不带任何参数。
析构函数用于在结束程序（比如关闭文件、释放内存等）之前释放资源。析构函数不能继承或重载。

## C# 继承

继承是面向对象程序设计中最重要的概念之一。继承允许我们根据一个类来定义另一个类，这使得创建和维护应用程序变得更容易。同时也有利于重用代码和节省开发时间。
当创建一个类时，程序员不需要完全重新编写新的数据成员和成员函数，只需要设计一个新的类，继承了已有的类的成员即可。这个已有的类被称为的**基类**，这个新的类被称为**派生类**。
继承的思想实现了 **属于（IS-A）** 关系。

### C# 多重继承

多重继承指的是一个类别可以同时从多于一个父类继承行为与特征的功能。与单一继承相对，单一继承指一个类别只可以继承自一个父类。
**C# 不支持多重继承**。但是，您可以使用接口来实现多重继承。

## C# 多态性

多态是同一个行为具有多个不同表现形式或形态的能力。
**多态性**意味着有多重形式。在面向对象编程范式中，多态性往往表现为"一个接口，多个功能"。
多态性可以是静态的或动态的。在**静态多态性**中，函数的响应是在编译时发生的。在**动态多态性**中，函数的响应是在运行时发生的。
在 C# 中，每个类型都是多态的，因为包括用户定义类型在内的所有类型都继承自 Object。多态就是同一个接口，使用不同的实例而执行不同操作。

### 静态多态性

在编译时，函数和对象的连接机制被称为早期绑定，也被称为静态绑定。C# 提供了两种技术来实现静态多态性。分别为：

- 函数重载

- 运算符重载
  
  ### 函数重载
  
  您可以在同一个范围内对相同的函数名有多个定义。函数的定义必须彼此不同，可以是参数列表中的参数类型不同，也可以是参数个数不同。不能重载只有返回类型不同的函数声明。
  
  ### 动态多态性
  
  C# 允许您使用关键字 **abstract** 创建抽象类，用于提供接口的部分类的实现。当一个派生类继承自该抽象类时，实现即完成。**抽象类**包含抽象方法，抽象方法可被派生类实现。派生类具有更专业的功能。
  请注意，下面是有关抽象类的一些规则：

- 您不能创建一个抽象类的实例。

- 您不能在一个抽象类外部声明一个抽象方法。

- 通过在类定义前面放置关键字 **sealed**，可以将类声明为**密封类**。当一个类被声明为 **sealed** 时，它不能被继承。抽象类不能被声明为 sealed。

当有一个定义在类中的函数需要在继承类中实现时，可以使用**虚方法**。
虚方法是使用关键字 **virtual** 声明的。
虚方法可以在不同的继承类中有不同的实现。
对虚方法的调用是在运行时发生的。
动态多态性是通过 **抽象类** 和 **虚方法** 实现的。

## C# 运算符重载

您可以重定义或重载 C# 中内置的运算符。因此，程序员也可以使用用户自定义类型的运算符。重载运算符是具有特殊名称的函数，是通过关键字 **operator** 后跟运算符的符号来定义的。与其他函数一样，重载运算符有返回类型和参数列表。

### 可重载和不可重载运算符

| 运算符                                   | 描述                     |
| ------------------------------------- | ---------------------- |
| +, -, !, ~, ++, --                    | 这些一元运算符只有一个操作数，且可以被重载。 |
| +, -, *, /, %                         | 这些二元运算符带有两个操作数，且可以被重载。 |
| ==, !=, <, >, <=, >=                  | 这些比较运算符可以被重载。          |
| &&, &#124;&#124;                      | 这些条件逻辑运算符不能被直接重载。      |
| +=, -=, *=, /=, %=                    | 这些赋值运算符不能被重载。          |
| =, ., ?:, ->, new, is, sizeof, typeof | 这些运算符不能被重载。            |

运算符只能采用值参数，不能采用 ref 或 out 参数。
C# 要求成对重载比较运算符。如果重载了==，则也必须重载!=，否则产生编译错误。同时，比较运算符必须返回bool类型的值，这是与其他算术运算符的根本区别。
C# 不允许重载=运算符，但如果重载例如+运算符，编译器会自动使用+运算符的重载来执行+=运算符的操作。
运算符重载的其实就是函数重载。首先通过指定的运算表达式调用对应的运算符函数，然后再将运算对象转化为运算符函数的实参，接着根据实参的类型来确定需要调用的函数的重载，这个过程是由编译器完成。

## C# 接口（Interface）

接口定义了所有类继承接口时应遵循的语法合同。接口定义了语法合同 **"是什么"** 部分，派生类定义了语法合同 **"怎么做"** 部分。
接口定义了属性、方法和事件，这些都是接口的成员。接口只包含了成员的声明。成员的定义是派生类的责任。接口提供了派生类应遵循的标准结构。
接口使得实现接口的类或结构在形式上保持一致。
抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。
接口本身并不实现任何功能，它只是和声明实现该接口的对象订立一个必须实现哪些行为的契约。
抽象类不能直接实例化，但允许派生出具体的，具有实际功能的类。

## C# 命名空间（Namespace）

**命名空间**的设计目的是提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。

### 定义命名空间

命名空间的定义是以关键字 **namespace** 开始，后跟命名空间的名称，如下所示：

```java
namespace namespace_name
{
   // 代码声明
}
```

为了调用支持命名空间版本的函数或变量，会把命名空间的名称置于前面，如下所示：

```java
namespace_name.item_name;
```

### using 关键字

**using** 关键字表明程序使用的是给定命名空间中的名称。
您也可以使用 **using** 命名空间指令，这样在使用的时候就不用在前面加上命名空间名称。该指令告诉编译器随后的代码使用了指定命名空间中的名称。

### using 的用法

**1. using指令：引入命名空间**
这是最常见的用法，例如：

```csharp
using System;
using Namespace1.SubNameSpace;
```

**2. using static 指令：指定无需指定类型名称即可访问其静态成员的类型**

```csharp
using static System.Math;var = PI; // 直接使用System.Math.PI
```

**3. 起别名**

```csharp
using Project = PC.MyCompany.Project;
```

**4. using语句：将实例与代码绑定**

```csharp
using (Font font3 = new Font("Arial", 10.0f),
            font4 = new Font("Arial", 10.0f))
{
    // Use font3 and font4.
}
```

代码段结束时，自动调用font3和font4的Dispose方法，释放实例。

## C# 预处理器指令

预处理器指令指导编译器在实际编译开始之前对信息进行预处理。
所有的预处理器指令都是以 # 开始。且在一行上，只有空白字符可以出现在预处理器指令之前。预处理器指令不是语句，所以它们不以分号（;）结束。
C# 编译器没有一个单独的预处理器，但是，指令被处理时就像是有一个单独的预处理器一样。在 C# 中，预处理器指令用于在条件编译中起作用。与 C 和 C++ 不同的是，它们不是用来创建宏。一个预处理器指令必须是该行上的唯一指令。

### C# 预处理器指令列表

下表列出了 C# 中可用的预处理器指令：

| 预处理器指令     | 描述                                                        |
| ---------- | --------------------------------------------------------- |
| #define    | 它用于定义一系列成为符号的字符。                                          |
| #undef     | 它用于取消定义符号。                                                |
| #if        | 它用于测试符号是否为真。                                              |
| #else      | 它用于创建复合条件指令，与 #if 一起使用。                                   |
| #elif      | 它用于创建复合条件指令。                                              |
| #endif     | 指定一个条件指令的结束。                                              |
| #line      | 它可以让您修改编译器的行数以及（可选地）输出错误和警告的文件名。                          |
| #error     | 它允许从代码的指定位置生成一个错误。                                        |
| #warning   | 它允许从代码的指定位置生成一级警告。                                        |
| #region    | 它可以让您在使用 Visual Studio Code Editor 的大纲特性时，指定一个可展开或折叠的代码块。 |
| #endregion | 它标识着 #region 块的结束。                                        |

### #define 预处理器

#define 预处理器指令创建符号常量。
#define 允许您定义一个符号，这样，通过使用符号作为传递给 #if 指令的表达式，表达式将返回 true。它的语法如下：

```csharp
#define symbol
```

下面的程序说明了这点：

```csharp
#define PI
using System;
namespace PreprocessorDAppl
{
   class Program
   {
      static void Main(string[] args)
      {
         #if (PI)
            Console.WriteLine("PI is defined");
         #else
            Console.WriteLine("PI is not defined");
         #endif
         Console.ReadKey();
      }
   }
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```csharp
PI is defined
```

### 条件指令

您可以使用 #if 指令来创建一个条件指令。条件指令用于测试符号是否为真。如果为真，编译器会执行 #if 和下一个指令之间的代码。
条件指令的语法：

```csharp
#if symbol [operator symbol]...
```

其中，_symbol_ 是要测试的符号名称。您也可以使用 true 和 false，或在符号前放置否定运算符。
常见运算符有：

- == (等于)
- != (不等于)
- && (与)
- || (或)

您也可以用括号把符号和运算符进行分组。条件指令用于在调试版本或编译指定配置时编译代码。一个以 **#if** 指令开始的条件指令，必须显示地以一个 **#endif** 指令终止。
下面的程序演示了条件指令的用法：

```csharp
#define DEBUG
#define VC_V10
using System;
public class TestClass
{
   public static void Main()
   {

      #if (DEBUG && !VC_V10)
         Console.WriteLine("DEBUG is defined");
      #elif (!DEBUG && VC_V10)
         Console.WriteLine("VC_V10 is defined");
      #elif (DEBUG && VC_V10)
         Console.WriteLine("DEBUG and VC_V10 are defined");
      #else
         Console.WriteLine("DEBUG and VC_V10 are not defined");
      #endif
      Console.ReadKey();
   }
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```csharp
DEBUG and VC_V10 are defined
```

### 预处理指令的用途

在程序调试和运行上有重要的作用。比如预处理器指令可以禁止编译器编译代码的某一部分，如果计划发布两个版本的代码，即基本版本和有更多功能的企业版本，就可以使用这些预处理器指令来控制。在编译软件的基本版本时，使用预处理器指令还可以禁止编译器编译于额外功能相关的代码。另外，在编写提供调试信息的代码时，也可以使用预处理器指令进行控制。总的来说和普通的控制语句（if等）功能类似，方便在于预处理器指令包含的未执行部分是不需要编译的。

### 其他预处理器指令

#### #warning 和 #error

当编译器遇到它们时，会分别产生警告或错误。如果编译器遇到 #warning 指令，会给用户显示 #warning 指令后面的文本，之后编译继续进行。如果编译器遇到 #error 指令，就会给用户显示后面的文本，作为一条编译错误消息，然后会立即退出编译。使用这两条指令可以检查 #define 语句是不是做错了什么事，使用 #warning 语句可以提醒自己执行某个操作。

```csharp
#if DEBUG && RELEASE  
#error "You've defined DEBUG and RELEASE simultaneously!"  
#endif  
#warning "Don't forget to remove this line before the boss tests the code!"  
Console.WriteLine("*I hate this job.*");
```

#### #region 和 #endregion

#region 和 #endregion 指令用于把一段代码标记为有给定名称的一个块，如下所示:

```csharp
#region Member Field Declarations
int x;
double d;
Currency balance;
#endregion
```

这看起来似乎没有什么用，它不影响编译过程。这些指令的优点是它们可以被某些编辑器识别，包括 Visual Studio .NET 编辑器。这些编辑器可以使用这些指令使代码在屏幕上更好地布局。

#### #line

#line 指令可以用于改变编译器在警告和错误信息中显示的文件名和行号信息，不常用。
如果编写代码时，在把代码发送给编译器前，要使用某些软件包改变输入的代码，就可以使用这个指令，因为这意味着编译器报告的行号或文件名与文件中的行号或编辑的文件名不匹配。#line 指令可以用于还原这种匹配。也可以使用语法 #line default 把行号还原为默认的行号：

```csharp
#line 164 "Core.cs" // 在文件的第 164 行
// Core.cs, before the intermediate
// package mangles it.
// later on
#line default // 恢复默认行号
```

#### #pragma

#pragma 指令可以抑制或还原指定的编译警告。与命令行选项不同，#pragma 指令可以在类或方法级别执行，对抑制警告的内容和抑制的时间进行更精细的控制。如下：

```csharp
#pragma warning disable 169    // 取消编号 169 的警告（字段未使用的警告）
public class MyClass
{
    int neverUsedField;       // 编译整个 MyClass 类时不会发出警告
}
#pragma warning restore 169   // 恢复编号 169 的警告
```

## C# 正则表达式

**正则表达式** 是一种匹配输入文本的模式。
.Net 框架提供了允许这种匹配的正则表达式引擎。
模式由一个或多个字符、运算符和结构组成。

### 定义正则表达式

下面列出了用于定义正则表达式的各种类别的字符、运算符和结构。

- 字符转义
- 字符类
- 定位点
- 分组构造
- 限定符
- 反向引用构造
- 备用构造
- 替换
- 杂项构造
  
  #### 字符转义
  
  正则表达式中的反斜杠字符（\）指示其后跟的字符是特殊字符，或应按原义解释该字符。
  下表列出了转义字符：

| 转义字符            | 描述                                         | 模式                                  | 匹配                                        |
| --------------- | ------------------------------------------ | ----------------------------------- | ----------------------------------------- |
| **\\a**         | 与报警 (bell) 符 \\u0007 匹配。                   | \\a                                 | "Warning!" + '\\u0007' 中的 "\\u0007"       |
| **\\b**         | 在字符类中，与退格键 \\u0008 匹配。                     | [\\b]{3,}                           | "\\b\\b\\b\\b" 中的 "\\b\\b\\b\\b"          |
| **\\t**         | 与制表符 \\u0009 匹配。                           | (\\w+)\\t                           | "Name\\tAddr\\t" 中的 "Name\\t" 和 "Addr\\t" |
| **\\r**         | 与回车符 \\u000D 匹配。（\\r 与换行符 \\n 不是等效的。）      | \\r\\n(\\w+)                        | "\\r\\nHello\\nWorld." 中的 "\\r\\nHello"   |
| **\\v**         | 与垂直制表符 \\u000B 匹配。                         | [\\v]{2,}                           | "\\v\\v\\v" 中的 "\\v\\v\\v"                |
| **\\f**         | 与换页符 \\u000C 匹配。                           | [\\f]{2,}                           | "\\f\\f\\f" 中的 "\\f\\f\\f"                |
| **\\n**         | 与换行符 \\u000A 匹配。                           | \\r\\n(\\w+)                        | "\\r\\nHello\\nWorld." 中的 "\\r\\nHello"   |
| **\\e**         | 与转义符 \\u001B 匹配。                           | \\e                                 | "\\x001B" 中的 "\\x001B"                    |
| **\\ nnn**      | 使用八进制表示形式指定一个字符（nnn 由二到三位数字组成）。            | \\w\\040\\w                         | "a bc d" 中的 "a b" 和 "c d"                 |
| **\\x nn**      | 使用十六进制表示形式指定字符（nn 恰好由两位数字组成）。              | \\w\\x20\\w                         | "a bc d" 中的 "a b" 和 "c d"                 |
| **\\c X \\c x** | 匹配 X 或 x 指定的 ASCII 控件字符，其中 X 或 x 是控件字符的字母。 | \\cC                                | "\\x0003" 中的 "\\x0003" (Ctrl-C)           |
| **\\u nnnn**    | 使用十六进制表示形式匹配一个 Unicode 字符（由 nnnn 表示的四位数）。  | \\w\\u0020\\w                       | "a bc d" 中的 "a b" 和 "c d"                 |
| **\\**          | 在后面带有不识别的转义字符时，与该字符匹配。                     | \\d+[\\+-x\\*]\\d+\\d+[\\+-x\\*\\d+ | "(2+2) * 3*9" 中的 "2+2" 和 "3*9"            |

#### 字符串

字符类与一组字符中的任何一个字符匹配。
下表列出了字符类：

| 字符类                                           | 描述                                                                 | 模式                               | 匹配                                   |
| --------------------------------------------- | ------------------------------------------------------------------ | -------------------------------- | ------------------------------------ |
| **[character_group]**                         | 匹配 character_group 中的任何单个字符。 默认情况下，匹配区分大小写。                        | [mn]                             | "mat" 中的 "m"，"moon" 中的 "m" 和 "n"     |
| **[^character_group]**                        | 非：与不在 character_group 中的任何单个字符匹配。 默认情况下，character_group 中的字符区分大小写。 | [^aei]                           | "avail" 中的 "v" 和 "l"                 |
| **[ first - last ]**                          | 字符范围：与从 first 到 last 的范围中的任何单个字符匹配。                                | [b-d]                            | [b-d]irds 可以匹配 Birds、 Cirds、 Dirds   |
| **.**                                         | 通配符：与除 \\n 之外的任何单个字符匹配。                                            |                                  |                                      |
| 若要匹配原意句点字符（. 或 \\u002E），您必须在该字符前面加上转义符 (\\.)。 | a.e                                                                | "have" 中的 "ave"， "mate" 中的 "ate" |                                      |
| **\\p{ name }**                               | 与 _name_ 指定的 Unicode 通用类别或命名块中的任何单个字符匹配。                           | \\p{Lu}                          | "City Lights" 中的 "C" 和 "L"           |
| **\\P{ name }**                               | 与不在 _name_ 指定的 Unicode 通用类别或命名块中的任何单个字符匹配。                         | \\P{Lu}                          | "City" 中的 "i"、 "t" 和 "y"             |
| **\\w**                                       | 与任何单词字符匹配。                                                         | \\w                              | "Room#1" 中的 "R"、 "o"、 "m" 和 "1"      |
| **\\W**                                       | 与任何非单词字符匹配。                                                        | \\W                              | "Room#1" 中的 "#"                      |
| **\\s**                                       | 与任何空白字符匹配。                                                         | \\w\\s                           | "ID A1.3" 中的 "D "                    |
| **\\S**                                       | 与任何非空白字符匹配。                                                        | \\s\\S                           | "int __ctr" 中的 " _"                  |
| **\\d**                                       | 与任何十进制数字匹配。                                                        | \\d                              | "4 = IV" 中的 "4"                      |
| **\\D**                                       | 匹配不是十进制数的任意字符。                                                     | \\D                              | "4 = IV" 中的 " "、 "="、 " "、 "I" 和 "V" |

#### 定位点

定位点或原子零宽度断言会使匹配成功或失败，具体取决于字符串中的当前位置，但它们不会使引擎在字符串中前进或使用字符。
下表列出了定位点：

| 断言      | 描述                                    | 模式           | 匹配                                        |
| ------- | ------------------------------------- | ------------ | ----------------------------------------- |
| **^**   | 匹配必须从字符串或一行的开头开始。                     | ^\\d{3}      | "567-777-" 中的 "567"                       |
| **$**   | 匹配必须出现在字符串的末尾或出现在行或字符串末尾的 **\\n** 之前。 | -\\d{4}$     | "8-12-2012" 中的 "-2012"                    |
| **\\A** | 匹配必须出现在字符串的开头。                        | \\A\\w{4}    | "Code-007-" 中的 "Code"                     |
| **\\Z** | 匹配必须出现在字符串的末尾或出现在字符串末尾的 **\\n** 之前。   | -\\d{3}\\Z   | "Bond-901-007" 中的 "-007"                  |
| **\\z** | 匹配必须出现在字符串的末尾。                        | -\\d{3}\\z   | "-901-333" 中的 "-333"                      |
| **\\G** | 匹配必须出现在上一个匹配结束的地方。                    | \\G\\(\\d\\) | "(1)(3)(5)[7](9)" 中的 "(1)"、 "(3)" 和 "(5)" |
| **\\b** | 匹配一个单词边界，也就是指单词和空格间的位置。               | er\\b        | 匹配"never"中的"er"，但不能匹配"verb"中的"er"。        |
| **\\B** | 匹配非单词边界。                              | er\\B        | 匹配"verb"中的"er"，但不能匹配"never"中的"er"。        |

#### 分组构造

分组构造描述了正则表达式的子表达式，通常用于捕获输入字符串的子字符串。
下表列出了分组构造：

| 分组构造                                 | 描述                            | 模式                                                                        | 匹配                                                           |
| ------------------------------------ | ----------------------------- | ------------------------------------------------------------------------- | ------------------------------------------------------------ |
| **( subexpression )**                | 捕获匹配的子表达式并将其分配到一个从零开始的序号中。    | (\\w)\\1                                                                  | "deep" 中的 "ee"                                               |
| **(?< name >subexpression)**         | 将匹配的子表达式捕获到一个命名组中。            | (?< double>\\w)\\k< double>                                               | "deep" 中的 "ee"                                               |
| **(?< name1 -name2 >subexpression)** | 定义平衡组定义。                      | (((?'Open'\\()[^\\(\\)]*)+((?'Close-Open'\\))[^\\(\\)]*)+)*(?(Open)(?!))$ | "3+2^((1-3)*(3-1))" 中的 "((1-3)*(3-1))"                       |
| **(?: subexpression)**               | 定义非捕获组。                       | Write(?:Line)?                                                            | "Console.WriteLine()" 中的 "WriteLine"                         |
| **(?imnsx-imnsx:subexpression)**     | 应用或禁用 _subexpression_ 中指定的选项。 | A\\d{2}(?i:\\w+)\\b                                                       | "A12xl A12XL a12xl" 中的 "A12xl" 和 "A12XL"                     |
| **(?= subexpression)**               | 零宽度正预测先行断言。                   | \\w+(?=\\.)                                                               | "He is. The dog ran. The sun is out." 中的 "is"、 "ran" 和 "out" |
| **(?! subexpression)**               | 零宽度负预测先行断言。                   | \\b(?!un)\\w+\\b                                                          | "unsure sure unity used" 中的 "sure" 和 "used"                  |
| **(?<=subexpression)**               | 零宽度正回顾后发断言。                   | (?<=19)\\d{2}\\b                                                          | "1851 1999 1950 1905 2003" 中的 "99"、"50"和 "05"                |
| **(?<! subexpression)**              | 零宽度负回顾后发断言。                   | (?<!wo)man\\b                                                             | "Hi woman Hi man" 中的 "man"                                   |
| **(?> subexpression)**               | 非回溯（也称为"贪婪"）子表达式。             | [13579](?>A+B+)                                                           | "1ABB 3ABBC 5AB 5AC" 中的 "1ABB"、 "3ABB" 和 "5AB"               |

#### 限定符

限定符指定在输入字符串中必须存在上一个元素（可以是字符、组或字符类）的多少个实例才能出现匹配项。 限定符包括下表中列出的语言元素。
下表列出了限定符：

| 限定符            | 描述                             | 模式          | 匹配                                                              |
| -------------- | ------------------------------ | ----------- | --------------------------------------------------------------- |
| *****          | 匹配上一个元素零次或多次。                  | \\d*\\.\\d  | ".0"、 "19.9"、 "219.9"                                           |
| **+**          | 匹配上一个元素一次或多次。                  | "be+"       | "been" 中的 "bee"， "bent" 中的 "be"                                 |
| **?**          | 匹配上一个元素零次或一次。                  | "rai?n"     | "ran"、 "rain"                                                   |
| **{ n }**      | 匹配上一个元素恰好 n 次。                 | ",\\d{3}"   | "1,043.6" 中的 ",043"， "9,876,543,210" 中的 ",876"、 ",543" 和 ",210" |
| **{ n ,}**     | 匹配上一个元素至少 n 次。                 | "\\d{2,}"   | "166"、 "29"、 "1930"                                             |
| **{ n , m }**  | 匹配上一个元素至少 n 次，但不多于 m 次。        | "\\d{3,5}"  | "166"， "17668"， "193024" 中的 "19302"                             |
| ***?**         | 匹配上一个元素零次或多次，但次数尽可能少。          | \\d*?\\.\\d | ".0"、 "19.9"、 "219.9"                                           |
| **+?**         | 匹配上一个元素一次或多次，但次数尽可能少。          | "be+?"      | "been" 中的 "be"， "bent" 中的 "be"                                  |
| **??**         | 匹配上一个元素零次或一次，但次数尽可能少。          | "rai??n"    | "ran"、 "rain"                                                   |
| **{ n }?**     | 匹配前导元素恰好 n 次。                  | ",\\d{3}?"  | "1,043.6" 中的 ",043"， "9,876,543,210" 中的 ",876"、 ",543" 和 ",210" |
| **{ n ,}?**    | 匹配上一个元素至少 n 次，但次数尽可能少。         | "\\d{2,}?"  | "166"、 "29" 和 "1930"                                            |
| **{ n , m }?** | 匹配上一个元素的次数介于 n 和 m 之间，但次数尽可能少。 | "\\d{3,5}?" | "166"， "17668"， "193024" 中的 "193" 和 "024"                       |

#### 反向引用构造

反向引用允许在同一正则表达式中随后标识以前匹配的子表达式。
下表列出了反向引用构造：

| 反向引用构造          | 描述                 | 模式                      | 匹配             |
| --------------- | ------------------ | ----------------------- | -------------- |
| **\\ number**   | 反向引用。 匹配编号子表达式的值。  | (\\w)\\1                | "seek" 中的 "ee" |
| **\\k< name >** | 命名反向引用。 匹配命名表达式的值。 | (?< char>\\w)\\k< char> | "seek" 中的 "ee" |

#### 备用构造

备用构造用于修改正则表达式以启用 either/or 匹配。
下表列出了备用构造：

| 备用构造                                | 描述                                                                          | 模式                                         | 匹配                                                               |
| ----------------------------------- | --------------------------------------------------------------------------- | ------------------------------------------ | ---------------------------------------------------------------- |
| **&#124;**                          | 匹配以竖线 (&#124;) 字符分隔的任何一个元素。                                                 | th(e&#124;is&#124;at)                      | "this is the day. " 中的 "the" 和 "this"                            |
| **(?( expression )yes &#124; no )** | 如果正则表达式模式由 expression 匹配指定，则匹配 _yes_；否则匹配可选的 _no_ 部分。 expression 被解释为零宽度断言。 | (?(A)A\\d{2}\\b&#124;\\b\\d{3}\\b)         | "A10 C103 910" 中的 "A10" 和 "910"                                  |
| **(?( name )yes &#124; no )**       | 如果 name 或已命名或已编号的捕获组具有匹配，则匹配 _yes_；否则匹配可选的 _no_。                            | (?< quoted>")?(?(quoted).+?"&#124;\\S+\\s) | "Dogs.jpg "Yiska playing.jpg"" 中的 Dogs.jpg 和 "Yiska playing.jpg" |

#### 替换

替换是替换模式中使用的正则表达式。
下表列出了用于替换的字符：

| 字符              | 描述                     | 模式                                        | 替换模式              | 输入字符串      | 结果字符串        |
| --------------- | ---------------------- | ----------------------------------------- | ----------------- | ---------- | ------------ |
| **$**number     | 替换按组 _number_ 匹配的子字符串。 | \\b(\\w+)(\\s)(\\w+)\\b                   | $3$2$1            | "one two"  | "two one"    |
| **${**name**}** | 替换按命名组 _name_ 匹配的子字符串。 | \\b(?< word1>\\w+)(\\s)(?< word2>\\w+)\\b | ${word2} ${word1} | "one two"  | "two one"    |
| **$$**          | 替换字符"$"。               | \\b(\\d+)\\s?USD                          | $$$1              | "103 USD"  | "$103"       |
| **$&**          | 替换整个匹配项的一个副本。          | (\\$*(\\d*(\\.+\\d+)?){1})                | **$&              | "$1.30"    | "**$1.30**"  |
| **$`**          | 替换匹配前的输入字符串的所有文本。      | B+                                        | $`                | "AABBCC"   | "AAAACC"     |
| **$'**          | 替换匹配后的输入字符串的所有文本。      | B+                                        | $'                | "AABBCC"   | "AACCCC"     |
| **$+**          | 替换最后捕获的组。              | B+(C+)                                    | $+                | "AABBCCDD" | AACCDD       |
| **$_**          | 替换整个输入字符串。             | B+                                        | $_                | "AABBCC"   | "AAAABBCCCC" |

#### 杂项构造

下表列出了各种杂项构造：

| 构造                 | 描述                          | 实例                                                   |
| ------------------ | --------------------------- | ---------------------------------------------------- |
| **(?imnsx-imnsx)** | 在模式中间对诸如不区分大小写这样的选项进行设置或禁用。 | \\bA(?i)b\\w+\\b 匹配 "ABA Able Act" 中的 "ABA" 和 "Able" |
| **(?#注释)**         | 内联注释。该注释在第一个右括号处终止。         | \\bA(?#匹配以A开头的单词)\\w+\\b                             |
| **# **[行尾]         | 该注释以非转义的 # 开头，并继续到行的结尾。     | (?x)\\bA\\w+\\b#匹配以 A 开头的单词                          |

### Regex 类

Regex 类用于表示一个正则表达式。
下表列出了 Regex 类中一些常用的方法：

| 序号                                                      | 方法 & 描述                                                        |
| ------------------------------------------------------- | -------------------------------------------------------------- |
| 1                                                       | **public bool IsMatch( string input )**                        |
| 指示 Regex 构造函数中指定的正则表达式是否在指定的输入字符串中找到匹配项。                |                                                                |
| 2                                                       | **public bool IsMatch( string input, int startat )**           |
| 指示 Regex 构造函数中指定的正则表达式是否在指定的输入字符串中找到匹配项，从字符串中指定的开始位置开始。 |                                                                |
| 3                                                       | **public static bool IsMatch( string input, string pattern )** |
| 指示指定的正则表达式是否在指定的输入字符串中找到匹配项。                            |                                                                |
| 4                                                       | **public MatchCollection Matches( string input )**             |
| 在指定的输入字符串中搜索正则表达式的所有匹配项。                                |                                                                |
| 5                                                       | **public string Replace( string input, string replacement )**  |
| 在指定的输入字符串中，把所有匹配正则表达式模式的所有匹配的字符串替换为指定的替换字符串。            |                                                                |
| 6                                                       | **public string[] Split( string input )**                      |
| 把输入字符串分割为子字符串数组，根据在 Regex 构造函数中指定的正则表达式模式定义的位置进行分割。     |                                                                |

## C# 异常处理

异常是在程序执行期间出现的问题。C# 中的异常是对程序运行时出现的特殊情况的一种响应，比如尝试除以零。
异常提供了一种把程序控制权从某个部分转移到另一个部分的方式。C# 异常处理时建立在四个关键词之上的：**try**、**catch**、**finally** 和 **throw**。

- **try**：一个 try 块标识了一个将被激活的特定的异常的代码块。后跟一个或多个 catch 块。
- **catch**：程序通过异常处理程序捕获异常。catch 关键字表示异常的捕获。
- **finally**：finally 块用于执行给定的语句，不管异常是否被抛出都会执行。例如，如果您打开一个文件，不管是否出现异常文件都要被关闭。
- **throw**：当问题出现时，程序抛出一个异常。使用 throw 关键字来完成。
  
  ## C# 文件的输入与输出
  
  一个 **文件** 是一个存储在磁盘中带有指定名称和目录路径的数据集合。当打开文件进行读写时，它变成一个 **流**。
  从根本上说，流是通过通信路径传递的字节序列。有两个主要的流：**输入流** 和 **输出流**。**输入流**用于从文件读取数据（读操作），**输出流**用于向文件写入数据（写操作）。
  
  ### C# I/O 类
  
  System.IO 命名空间有各种不同的类，用于执行各种文件操作，如创建和删除文件、读取或写入文件，关闭文件等。
  下表列出了一些 System.IO 命名空间中常用的非抽象类：

| I/O 类          | 描述                |
| -------------- | ----------------- |
| BinaryReader   | 从二进制流读取原始数据。      |
| BinaryWriter   | 以二进制格式写入原始数据。     |
| BufferedStream | 字节流的临时存储。         |
| Directory      | 有助于操作目录结构。        |
| DirectoryInfo  | 用于对目录执行操作。        |
| DriveInfo      | 提供驱动器的信息。         |
| File           | 有助于处理文件。          |
| FileInfo       | 用于对文件执行操作。        |
| FileStream     | 用于文件中任何位置的读写。     |
| MemoryStream   | 用于随机访问存储在内存中的数据流。 |
| Path           | 对路径信息执行操作。        |
| StreamReader   | 用于从字节流中读取字符。      |
| StreamWriter   | 用于向一个流中写入字符。      |
| StringReader   | 用于读取字符串缓冲区。       |
| StringWriter   | 用于写入字符串缓冲区。       |

### FileStream 类

System.IO 命名空间中的 **FileStream** 类有助于文件的读写与关闭。该类派生自抽象类 Stream。
您需要创建一个 **FileStream** 对象来创建一个新的文件，或打开一个已有的文件。创建 **FileStream** 对象的语法如下：

```csharp
FileStream <object_name> = new FileStream( <file_name>,
<FileMode Enumerator>, <FileAccess Enumerator>, <FileShare Enumerator>);
```

例如，创建一个 FileStream 对象 **F** 来读取名为 **sample.txt** 的文件：

```csharp
FileStream F = new FileStream("sample.txt", FileMode.Open, FileAccess.Read, FileShare.Read);
```

| 参数       | 描述                                           |
| -------- | -------------------------------------------- |
| FileMode | **FileMode** 枚举定义了各种打开文件的方法。FileMode 枚举的成员有： |

- **Append**：打开一个已有的文件，并将光标放置在文件的末尾。如果文件不存在，则创建文件。
- **Create**：创建一个新的文件。如果文件已存在，则删除旧文件，然后创建新文件。
- **CreateNew**：指定操作系统应创建一个新的文件。如果文件已存在，则抛出异常。
- **Open**：打开一个已有的文件。如果文件不存在，则抛出异常。
- **OpenOrCreate**：指定操作系统应打开一个已有的文件。如果文件不存在，则用指定的名称创建一个新的文件打开。
- **Truncate**：打开一个已有的文件，文件一旦打开，就将被截断为零字节大小。然后我们可以向文件写入全新的数据，但是保留文件的初始创建日期。如果文件不存在，则抛出异常。
  |
  | FileAccess | **FileAccess** 枚举的成员有：**Read**、**ReadWrite** 和 **Write**。 |
  | FileShare | **FileShare** 枚举的成员有：
- **Inheritable**：允许文件句柄可由子进程继承。Win32 不直接支持此功能。
- **None**：谢绝共享当前文件。文件关闭前，打开该文件的任何请求（由此进程或另一进程发出的请求）都将失败。
- **Read**：允许随后打开文件读取。如果未指定此标志，则文件关闭前，任何打开该文件以进行读取的请求（由此进程或另一进程发出的请求）都将失败。但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。
- **ReadWrite**：允许随后打开文件读取或写入。如果未指定此标志，则文件关闭前，任何打开该文件以进行读取或写入的请求（由此进程或另一进程发出）都将失败。但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。
- **Write**：允许随后打开文件写入。如果未指定此标志，则文件关闭前，任何打开该文件以进行写入的请求（由此进程或另一进过程发出的请求）都将失败。但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。
- **Delete**：允许随后删除文件。
  |

## C# 特性（Attribute）

**特性（Attribute）**是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。您可以通过使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号（[ ]）来描述的。
特性（Attribute）用于添加元数据，如编译器指令和注释、描述、方法、类等其他信息。.Net 框架提供了两种类型的特性：_预定义_特性和_自定义_特性。

### 规定特性（Attribute）

规定特性（Attribute）的语法如下：

```csharp
[attribute(positional_parameters, name_parameter = value, ...)]
element
```

特性（Attribute）的名称和值是在方括号内规定的，放置在它所应用的元素之前。positional_parameters 规定必需的信息，name_parameter 规定可选的信息。

### 预定义特性（Attribute）

.Net 框架提供了三种预定义特性：

- AttributeUsage

- Conditional

- Obsolete
  
  #### AttributeUsage
  
  预定义特性 **AttributeUsage** 描述了如何使用一个自定义特性类。它规定了特性可应用到的项目的类型。
  规定该特性的语法如下：
  
  ```csharp
  [AttributeUsage(
   validon,
   AllowMultiple=allowmultiple,
   Inherited=inherited
  )]
  ```
  
  其中：

- 参数 validon 规定特性可被放置的语言元素。它是枚举器 _AttributeTargets_ 的值的组合。默认值是 _AttributeTargets.All_。

- 参数 _allowmultiple_（可选的）为该特性的 _AllowMultiple_ 属性（property）提供一个布尔值。如果为 true，则该特性是多用的。默认值是 false（单用的）。

- 参数 _inherited_（可选的）为该特性的 _Inherited_ 属性（property）提供一个布尔值。如果为 true，则该特性可被派生类继承。默认值是 false（不被继承）。

例如：

```csharp
[AttributeUsage(AttributeTargets.Class |
AttributeTargets.Constructor |
AttributeTargets.Field |
AttributeTargets.Method |
AttributeTargets.Property, 
AllowMultiple = true)]
```

#### Conditional

这个预定义特性标记了一个条件方法，其执行依赖于指定的预处理标识符。
它会引起方法调用的条件编译，取决于指定的值，比如 **Debug** 或 **Trace**。例如，当调试代码时显示变量的值。
规定该特性的语法如下：

```csharp
[Conditional(
   conditionalSymbol
)]
```

例如：

```csharp
[Conditional("DEBUG")]
```

下面的实例演示了该特性：

```csharp
#define DEBUG
using System;
using System.Diagnostics;
public class Myclass
{
    [Conditional("DEBUG")]
    public static void Message(string msg)
    {
        Console.WriteLine(msg);
    }
}
class Test
{
    static void function1()
    {
        Myclass.Message("In Function 1.");
        function2();
    }
    static void function2()
    {
        Myclass.Message("In Function 2.");
    }
    public static void Main()
    {
        Myclass.Message("In Main function.");
        function1();
        Console.ReadKey();
    }
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```csharp
In Main function
In Function 1
In Function 2
```

#### Obsolete

这个预定义特性标记了不应被使用的程序实体。它可以让您通知编译器丢弃某个特定的目标元素。例如，当一个新方法被用在一个类中，但是您仍然想要保持类中的旧方法，您可以通过显示一个应该使用新方法，而不是旧方法的消息，来把它标记为 obsolete（过时的）。
规定该特性的语法如下：

```csharp
[Obsolete(
   message
)]
[Obsolete(
   message,
   iserror
)]
```

其中：

- 参数 _message_，是一个字符串，描述项目为什么过时以及该替代使用什么。
- 参数 _iserror_，是一个布尔值。如果该值为 true，编译器应把该项目的使用当作一个错误。默认值是 false（编译器生成一个警告）。

下面的实例演示了该特性：

```csharp
using System;
public class MyClass
{
   [Obsolete("Don't use OldMethod, use NewMethod instead", true)]
   static void OldMethod()
   {
      Console.WriteLine("It is the old method");
   }
   static void NewMethod()
   {
      Console.WriteLine("It is the new method");
   }
   public static void Main()
   {
      OldMethod();
   }
}
```

当您尝试编译该程序时，编译器会给出一个错误消息说明：

```csharp
 Don't use OldMethod, use NewMethod instead
```

### 创建自定义特性（Attribute）

.Net 框架允许创建自定义特性，用于存储声明性的信息，且可在运行时被检索。该信息根据设计标准和应用程序需要，可与任何目标元素相关。
创建并使用自定义特性包含四个步骤：

- 声明自定义特性
- 构建自定义特性
- 在目标程序元素上应用自定义特性
- 通过反射访问特性

最后一个步骤包含编写一个简单的程序来读取元数据以便查找各种符号。元数据是用于描述其他数据的数据和信息。该程序应使用反射来在运行时访问特性。

#### 声明自定义特性

一个新的自定义特性应派生自 **System.Attribute** 类。例如：

```csharp
// 一个自定义特性 BugFix 被赋给类及其成员
[AttributeUsage(AttributeTargets.Class |
AttributeTargets.Constructor |
AttributeTargets.Field |
AttributeTargets.Method |
AttributeTargets.Property,
AllowMultiple = true)]

public class DeBugInfo : System.Attribute
```

在上面的代码中，我们已经声明了一个名为 _DeBugInfo_ 的自定义特性。

## C# 反射（Reflection）

反射指程序可以访问、检测和修改它本身状态或行为的一种能力。
程序集包含模块，而模块包含类型，类型又包含成员。反射则提供了封装程序集、模块和类型的对象。
您可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。然后，可以调用类型的方法或访问其字段和属性。

#### 优缺点

优点：

- 1、反射提高了程序的灵活性和扩展性。
- 2、降低耦合性，提高自适应能力。
- 3、它允许程序创建和控制任何类的对象，无需提前硬编码目标类。

缺点：

- 1、性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。

- 2、使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。
  
  ### 反射（Reflection）的用途
  
  反射（Reflection）有下列用途：

- 它允许在运行时查看特性（attribute）信息。

- 它允许审查集合中的各种类型，以及实例化这些类型。

- 它允许延迟绑定的方法和属性（property）。

- 它允许在运行时创建新类型，然后使用这些类型执行一些任务。
  
  ### 查看元数据
  
  我们已经在上面的章节中提到过，使用反射（Reflection）可以查看特性（attribute）信息。
  **System.Reflection** 类的 **MemberInfo** 对象需要被初始化，用于发现与类相关的特性（attribute）。
  
  ## C# 属性（Property）
  
  **属性（Property）** 是类（class）、结构（structure）和接口（interface）的命名（named）成员。类或结构中的成员变量或方法称为 **域（Field）**。属性（Property）是域（Field）的扩展，且可使用相同的语法来访问。它们使用 **访问器（accessors）** 让私有域的值可被读写或操作。
  属性（Property）不会确定存储位置。相反，它们具有可读写或计算它们值的 **访问器（accessors）**。
  例如，有一个名为 Student 的类，带有 age、name 和 code 的私有域。我们不能在类的范围以外直接访问这些域，但是我们可以拥有访问这些私有域的属性。
  
  ### 访问器（Accessors）
  
  属性（Property）的**访问器（accessor）**包含有助于获取（读取或计算）或设置（写入）属性的可执行语句。访问器（accessor）声明可包含一个 get 访问器、一个 set 访问器，或者同时包含二者。
  
  ## 抽象属性（Abstract Properties）
  
  抽象类可拥有抽象属性，这些属性应在派生类中被实现。
  
  ## C# 索引器（Indexer）
  
  **索引器（Indexer）** 允许一个对象可以像数组一样使用下标的方式来访问。
  当您为类定义一个索引器时，该类的行为就会像一个 **虚拟数组（virtual array）** 一样。您可以使用数组访问运算符 **[ ]** 来访问该类的的成员。
  
  ### 语法
  
  一维索引器的语法如下：
  
  ```csharp
  element-type this[int index]
  {
   // get 访问器
   get
   {
      // 返回 index 指定的值
   }
  
   // set 访问器
   set
   {
      // 设置 index 指定的值
   }
  }
  ```
  
  ### 索引器（Indexer）的用途
  
  索引器的行为的声明在某种程度上类似于属性（property）。就像属性（property），您可使用 **get** 和 **set** 访问器来定义索引器。但是，属性返回或设置一个特定的数据成员，而索引器返回或设置对象实例的一个特定值。换句话说，它把实例数据分为更小的部分，并索引每个部分，获取或设置每个部分。
  定义一个属性（property）包括提供属性名称。索引器定义的时候不带有名称，但带有 **this** 关键字，它指向对象实例。下面的实例演示了这个概念：
  
  ```csharp
  using System;
  namespace IndexerApplication
  {
   class IndexedNames
   {
      private string[] namelist = new string[size];
      static public int size = 10;
      public IndexedNames()
      {
         for (int i = 0; i < size; i++)
         namelist[i] = "N. A.";
      }
      public string this[int index]
      {
         get
         {
            string tmp;
  
            if( index >= 0 && index <= size-1 )
            {
               tmp = namelist[index];
            }
            else
            {
               tmp = "";
            }
  
            return ( tmp );
         }
         set
         {
            if( index >= 0 && index <= size-1 )
            {
               namelist[index] = value;
            }
         }
      }
  
      static void Main(string[] args)
      {
         IndexedNames names = new IndexedNames();
         names[0] = "Zara";
         names[1] = "Riz";
         names[2] = "Nuha";
         names[3] = "Asif";
         names[4] = "Davinder";
         names[5] = "Sunil";
         names[6] = "Rubic";
         for ( int i = 0; i < IndexedNames.size; i++ )
         {
            Console.WriteLine(names[i]);
         }
         Console.ReadKey();
      }
   }
  }
  ```
  
  当上面的代码被编译和执行时，它会产生下列结果：
  
  ```csharp
  Zara
  Riz
  Nuha
  Asif
  Davinder
  Sunil
  Rubic
  N. A.
  N. A.
  N. A.
  ```
  
  ### 重载索引器（Indexer）
  
  索引器（Indexer）可被重载。索引器声明的时候也可带有多个参数，且每个参数可以是不同的类型。没有必要让索引器必须是整型的。C# 允许索引器可以是其他类型，例如，字符串类型。
  
  ## C# 委托（Delegate）
  
  C# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针。**委托（Delegate）** 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。
  委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 **System.Delegate** 类。
  
  ### 声明委托（Delegate）
  
  委托声明决定了可由该委托引用的方法。委托可指向一个与其具有相同标签的方法。
  例如，假设有一个委托：
  
  ```csharp
  public delegate int MyDelegate (string s);
  ```
  
  上面的委托可被用于引用任何一个带有一个单一的 _string_ 参数的方法，并返回一个 _int_ 类型变量。
  声明委托的语法如下：
  
  ```csharp
  delegate <return type> <delegate-name> <parameter list>
  ```
  
  ### 实力化委托（Delegate）
  
  一旦声明了委托类型，委托对象必须使用 **new** 关键字来创建，且与一个特定的方法有关。当创建委托时，传递到 **new** 语句的参数就像方法调用一样书写，但是不带有参数。例如：
  
  ```csharp
  public delegate void printString(string s);
  ...
  printString ps1 = new printString(WriteToScreen);
  printString ps2 = new printString(WriteToFile);
  ```
  
  下面的实例演示了委托的声明、实例化和使用，该委托可用于引用带有一个整型参数的方法，并返回一个整型值。
  
  ```csharp
  using System;
  ```

delegate int NumberChanger(int n);
namespace DelegateAppl
{
   class TestDelegate
   {
      static int num = 10;
      public static int AddNum(int p)
      {
         num += p;
         return num;
      }

      public static int MultNum(int q)
      {
         num *= q;
         return num;
      }
      public static int getNum()
      {
         return num;
      }
    
      static void Main(string[] args)
      {
         // 创建委托实例
         NumberChanger nc1 = new NumberChanger(AddNum);
         NumberChanger nc2 = new NumberChanger(MultNum);
         // 使用委托对象调用方法
         nc1(25);
         Console.WriteLine("Value of Num: {0}", getNum());
         nc2(5);
         Console.WriteLine("Value of Num: {0}", getNum());
         Console.ReadKey();
      }

   }
}

```
当上面的代码被编译和执行时，它会产生下列结果：
​```csharp
Value of Num: 35
Value of Num: 175
```

### 委托的多播（Multicasting of a Delegate）

委托对象可使用 "+" 运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。"-" 运算符可用于从合并的委托中移除组件委托。
使用委托的这个有用的特点，您可以创建一个委托被调用时要调用的方法的调用列表。这被称为委托的 **多播（multicasting）**，也叫组播。下面的程序演示了委托的多播：

```csharp
using System;

delegate int NumberChanger(int n);
namespace DelegateAppl
{
   class TestDelegate
   {
      static int num = 10;
      public static int AddNum(int p)
      {
         num += p;
         return num;
      }

      public static int MultNum(int q)
      {
         num *= q;
         return num;
      }
      public static int getNum()
      {
         return num;
      }

      static void Main(string[] args)
      {
         // 创建委托实例
         NumberChanger nc;
         NumberChanger nc1 = new NumberChanger(AddNum);
         NumberChanger nc2 = new NumberChanger(MultNum);
         nc = nc1;
         nc += nc2;
         // 调用多播
         nc(5);
         Console.WriteLine("Value of Num: {0}", getNum());
         Console.ReadKey();
      }
   }
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```csharp
Value of Num: 75
```

### 委托（Delegate）的用途

下面的实例演示了委托的用法。委托 _printString_ 可用于引用带有一个字符串作为输入的方法，并不返回任何东西。
我们使用这个委托来调用两个方法，第一个把字符串打印到控制台，第二个把字符串打印到文件：

```csharp
using System;
using System.IO;

namespace DelegateAppl
{
   class PrintString
   {
      static FileStream fs;
      static StreamWriter sw;
      // 委托声明
      public delegate void printString(string s);

      // 该方法打印到控制台
      public static void WriteToScreen(string str)
      {
         Console.WriteLine("The String is: {0}", str);
      }
      // 该方法打印到文件
      public static void WriteToFile(string s)
      {
         fs = new FileStream("c:\\message.txt", FileMode.Append, FileAccess.Write);
         sw = new StreamWriter(fs);
         sw.WriteLine(s);
         sw.Flush();
         sw.Close();
         fs.Close();
      }
      // 该方法把委托作为参数，并使用它调用方法
      public static void sendString(printString ps)
      {
         ps("Hello World");
      }
      static void Main(string[] args)
      {
         printString ps1 = new printString(WriteToScreen);
         printString ps2 = new printString(WriteToFile);
         sendString(ps1);
         sendString(ps2);
         Console.ReadKey();
      }
   }
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```csharp
The String is: Hello World
```

## C# 事件（Event）

**事件（Event）** 基本上说是一个用户操作，如按键、点击、鼠标移动等等，或者是一些提示信息，如系统生成的通知。应用程序需要在事件发生时响应事件。例如，中断。
C# 中使用事件机制实现线程间的通信。

## 通过事件使用委托

事件在类中声明且生成，且通过使用同一个类或其他类中的委托与事件处理程序关联。包含事件的类用于发布事件。这被称为 **发布器（publisher）** 类。其他接受该事件的类被称为 **订阅器（subscriber）** 类。事件使用 **发布-订阅（publisher-subscriber）** 模型。
**发布器（publisher）** 是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器（publisher）类的对象调用这个事件，并通知其他的对象。
**订阅器（subscriber）** 是一个接受事件并提供事件处理程序的对象。在发布器（publisher）类中的委托调用订阅器（subscriber）类中的方法（事件处理程序）。

### 声明事件（Event）

在类的内部声明事件，首先必须声明该事件的委托类型。例如：

```csharp
public delegate void BoilerLogHandler(string status);
```

然后，声明事件本身，使用 **event** 关键字：

```csharp
// 基于上面的委托定义事件
public event BoilerLogHandler BoilerEventLog;
```

上面的代码定义了一个名为 _BoilerLogHandler_ 的委托和一个名为 _BoilerEventLog_ 的事件，该事件在生成的时候会调用委托。

### 实例

```csharp
using System;
namespace SimpleEvent
{
  using System;
  /***********发布器类***********/
  public class EventTest
  {
    private int value;

    public delegate void NumManipulationHandler();


    public event NumManipulationHandler ChangeNum;
    protected virtual void OnNumChanged()
    {
      if ( ChangeNum != null )
      {
        ChangeNum(); /* 事件被触发 */
      }else {
        Console.WriteLine( "event not fire" );
        Console.ReadKey(); /* 回车继续 */
      }
    }


    public EventTest()
    {
      int n = 5;
      SetValue( n );
    }


    public void SetValue( int n )
    {
      if ( value != n )
      {
        value = n;
        OnNumChanged();
      }
    }
  }


  /***********订阅器类***********/

  public class subscribEvent
  {
    public void printf()
    {
      Console.WriteLine( "event fire" );
      Console.ReadKey(); /* 回车继续 */
    }
  }

  /***********触发***********/
  public class MainClass
  {
    public static void Main()
    {
      EventTest e = new EventTest(); /* 实例化对象,第一次没有触发事件 */
      subscribEvent v = new subscribEvent(); /* 实例化对象 */
      e.ChangeNum += new EventTest.NumManipulationHandler( v.printf ); /* 注册 */
      e.SetValue( 7 );
      e.SetValue( 11 );
    }
  }
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```csharp
event not fire
event fire
event fire
```

### C# 集合

集合（Collection）类是专门用于数据存储和检索的类。这些类提供了对栈（stack）、队列（queue）、列表（list）和哈希表（hash table）的支持。大多数集合类实现了相同的接口。
集合（Collection）类服务于不同的目的，如为元素动态分配内存，基于索引访问列表项等等。这些类创建 Object 类的对象的集合。在 C# 中，Object 类是所有数据类型的基类。

### 各类集合类与它们的用法

下面是各种常用的 **System.Collection** 命名空间的类。点击下面的链接查看细节。

| 类                                                                                                                 | 描述和用法                          |
| ----------------------------------------------------------------------------------------------------------------- | ------------------------------ |
| [动态数组（ArrayList）](https://www.runoob.com/csharp/csharp-arraylist.html)                                            | 它代表了可被单独**索引**的对象的有序集合。        |
| 它基本上可以替代一个数组。但是，与数组不同的是，您可以使用**索引**在指定的位置添加和移除项目，动态数组会自动重新调整它的大小。它也允许在列表中进行动态内存分配、增加、搜索、排序各项。                     |                                |
| [哈希表（Hashtable）](https://www.runoob.com/csharp/csharp-hashtable.html)                                             | 它使用**键**来访问集合中的元素。             |
| 当您使用键访问元素时，则使用哈希表，而且您可以识别一个有用的键值。哈希表中的每一项都有一个**键/值**对。键用于访问集合中的项目。                                                |                                |
| [排序列表（SortedList）](https://www.runoob.com/csharp/csharp-sortedlist.html)                                          | 它可以使用**键**和**索引**来访问列表中的项。     |
| 排序列表是数组和哈希表的组合。它包含一个可使用键或索引访问各项的列表。如果您使用索引访问各项，则它是一个动态数组（ArrayList），如果您使用键访问各项，则它是一个哈希表（Hashtable）。集合中的各项总是按键值排序。 |                                |
| [堆栈（Stack）](https://www.runoob.com/csharp/csharp-stack.html)                                                      | 它代表了一个**后进先出**的对象集合。           |
| 当您需要对各项进行后进先出的访问时，则使用堆栈。当您在列表中添加一项，称为**推入**元素，当您从列表中移除一项时，称为**弹出**元素。                                             |                                |
| [队列（Queue）](https://www.runoob.com/csharp/csharp-queue.html)                                                      | 它代表了一个**先进先出**的对象集合。           |
| 当您需要对各项进行先进先出的访问时，则使用队列。当您在列表中添加一项，称为**入队**，当您从列表中移除一项时，称为**出队**。                                                 |                                |
| [点阵列（BitArray）](https://www.runoob.com/csharp/csharp-bitarray.html)                                               | 它代表了一个使用值 1 和 0 来表示的**二进制**数组。 |
| 当您需要存储位，但是事先不知道位数时，则使用点阵列。您可以使用**整型索引**从点阵列集合中访问各项，索引从零开始。                                                        |                                |

## C# 泛型（Generic）

**泛型（Generic）** 允许您延迟编写类或方法中的编程元素的数据类型的规范，直到实际在程序中使用它的时候。换句话说，泛型允许您编写一个可以与任何数据类型一起工作的类或方法。
您可以通过数据类型的替代参数编写类或方法的规范。当编译器遇到类的构造函数或方法的函数调用时，它会生成代码来处理指定的数据类型。
在声明泛型方法/泛型类的时候，可以给泛型加上一定的约束来满足我们特定的一些条件。
比如：

```csharp
using System;
using System.Web.Caching;

namespace Demo.CacheManager
{
   public class CacheHelper<T> where T:new()
   {

   }
}
```

泛型限定条件：

- T：结构（类型参数必须是值类型。可以指定除 Nullable 以外的任何值类型）

- T：类 （类型参数必须是引用类型，包括任何类、接口、委托或数组类型）

- T：new() （类型参数必须具有无参数的公共构造函数。当与其他约束一起使用时new() 约束必须最后指定）

- T：<基类名> 类型参数必须是指定的基类或派生自指定的基类

- T：<接口名称> 类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的。
  
  ### 泛型（Generic）的特性
  
  使用泛型是一种增强程序功能的技术，具体表现在以下几个方面：

- 它有助于您最大限度地重用代码、保护类型的安全以及提高性能。

- 您可以创建泛型集合类。.NET 框架类库在 _System.Collections.Generic_ 命名空间中包含了一些新的泛型集合类。您可以使用这些泛型集合类来替代 _System.Collections_ 中的集合类。

- 您可以创建自己的泛型接口、泛型类、泛型方法、泛型事件和泛型委托。

- 您可以对泛型类进行约束以访问特定数据类型的方法。

- 关于泛型数据类型中使用的类型的信息可在运行时通过使用反射获取。
  
  ## C# 匿名方法
  
  委托是用于引用与其具有相同标签的方法。换句话说，您可以使用委托对象调用可由委托引用的方法。
  **匿名方法（Anonymous methods）** 提供了一种传递代码块作为委托参数的技术。匿名方法是没有名称只有主体的方法。
  在匿名方法中您不需要指定返回类型，它是从方法主体内的 return 语句推断的。
  
  ### 编写匿名方法的语法
  
  匿名方法是通过使用 **delegate** 关键字创建委托实例来声明的。例如：
  
  ```csharp
  delegate void NumberChanger(int n);
  ...
  NumberChanger nc = delegate(int x)
  {
    Console.WriteLine("Anonymous Method: {0}", x);
  };
  ```
  
  代码块 **Console.WriteLine("Anonymous Method: {0}", x);** 是匿名方法的主体。
  委托可以通过匿名方法调用，也可以通过命名方法调用，即，通过向委托对象传递方法参数。
  **注意:** 匿名方法的主体后面需要一个 **;**。
  例如：
  
  ```csharp
  nc(10);
  ```
  
  ### 实例
  
  下面的实例演示了匿名方法的概念：
  
  ```csharp
  using System;
  ```

delegate void NumberChanger(int n);
namespace DelegateAppl
{
    class TestDelegate
    {
        static int num = 10;
        public static void AddNum(int p)
        {
            num += p;
            Console.WriteLine("Named Method: {0}", num);
        }

        public static void MultNum(int q)
        {
            num *= q;
            Console.WriteLine("Named Method: {0}", num);
        }
    
        static void Main(string[] args)
        {
            // 使用匿名方法创建委托实例
            NumberChanger nc = delegate(int x)
            {
               Console.WriteLine("Anonymous Method: {0}", x);
            };
    
            // 使用匿名方法调用委托
            nc(10);
    
            // 使用命名方法实例化委托
            nc =  new NumberChanger(AddNum);
    
            // 使用命名方法调用委托
            nc(5);
    
            // 使用另一个命名方法实例化委托
            nc =  new NumberChanger(MultNum);
    
            // 使用命名方法调用委托
            nc(2);
            Console.ReadKey();
        }
    }

}

```
当上面的代码被编译和执行时，它会产生下列结果：
​```csharp
Anonymous Method: 10
Named Method: 15
Named Method: 30
```

## C# 不安全代码

当一个代码块使用 **unsafe** 修饰符标记时，C# 允许在函数中使用指针变量。**不安全代码**或非托管代码是指使用了**指针**变量的代码块。

### 指针变量

**指针** 是值为另一个变量的地址的变量，即，内存位置的直接地址。就像其他变量或常量，您必须在使用指针存储其他变量地址之前声明指针。
指针变量声明的一般形式为：

```csharp
type* var-name;
```

下面是指针类型声明的实例：

| 实例        | 描述               |
| --------- | ---------------- |
| int* p    | p 是指向整数的指针。      |
| double* p | p 是指向双精度数的指针。    |
| float* p  | p 是指向浮点数的指针。     |
| int** p   | p 是指向整数的指针的指针。   |
| int*[] p  | p 是指向整数的指针的一维数组。 |
| char* p   | p 是指向字符的指针。      |
| void* p   | p 是指向未知类型的指针。    |

### 使用指针访问数组元素

在 C# 中，数组名称和一个指向与数组数据具有相同数据类型的指针是不同的变量类型。例如，int *p 和 int[] p 是不同的类型。您可以增加指针变量 p，因为它在内存中不是固定的，但是数组地址在内存中是固定的，所以您不能增加数组 p。
因此，如果您需要使用指针变量访问数组数据，可以像我们通常在 C 或 C++ 中所做的那样，使用 **fixed** 关键字来固定指针。
下面的实例演示了这点：

```csharp
using System;
namespace UnsafeCodeApplication
{
   class TestPointer
   {
      public unsafe static void Main()
      {
         int[]  list = {10, 100, 200};
         fixed(int *ptr = list)

         /* 显示指针中数组地址 */
         for ( int i = 0; i < 3; i++)
         {
            Console.WriteLine("Address of list[{0}]={1}",i,(int)(ptr + i));
            Console.WriteLine("Value of list[{0}]={1}", i, *(ptr + i));
         }
         Console.ReadKey();
      }
   }
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```csharp
Address of list[0] = 31627168
Value of list[0] = 10
Address of list[1] = 31627172
Value of list[1] = 100
Address of list[2] = 31627176
Value of list[2] = 200
```

### 编译不安全代码

为了编译不安全代码，您必须切换到命令行编译器指定 **/unsafe** 命令行。
例如，为了编译包含不安全代码的名为 prog1.cs 的程序，需在命令行中输入命令：

```csharp
csc /unsafe prog1.cs
```

如果您使用的是 Visual Studio IDE，那么您需要在项目属性中启用不安全代码。
步骤如下：

- 通过双击资源管理器（Solution Explorer）中的属性（properties）节点，打开**项目属性（project properties）**。

- 点击 **Build** 标签页。

- 选择选项"**Allow unsafe code**"。
  
  ## C# 多线程
  
  **线程** 被定义为程序的执行路径。每个线程都定义了一个独特的控制流。如果您的应用程序涉及到复杂的和耗时的操作，那么设置不同的线程执行路径往往是有益的，每个线程执行特定的工作。
  线程是**轻量级进程**。一个使用线程的常见实例是现代操作系统中并行编程的实现。使用线程节省了 CPU 周期的浪费，同时提高了应用程序的效率。
  到目前为止我们编写的程序是一个单线程作为应用程序的运行实例的单一的过程运行的。但是，这样子应用程序同时只能执行一个任务。为了同时执行多个任务，它可以被划分为更小的线程。
  
  ### 生命周期
  
  线程生命周期开始于 System.Threading.Thread 类的对象被创建时，结束于线程被终止或完成执行时。
  下面列出了线程生命周期中的各种状态：

- **未启动状态**：当线程实例被创建但 Start 方法未被调用时的状况。

- **就绪状态**：当线程准备好运行并等待 CPU 周期时的状况。

- **不可运行状态**：下面的几种情况下线程是不可运行的：
  
  - 已经调用 Sleep 方法
  - 已经调用 Wait 方法
  - 通过 I/O 操作阻塞

- **死亡状态**：当线程已完成执行或已中止时的状况。
  
  ### 主线程
  
  在 C# 中，**System.Threading.Thread** 类用于线程的工作。它允许创建并访问多线程应用程序中的单个线程。进程中第一个被执行的线程称为**主线程**。
  当 C# 程序开始执行时，主线程自动创建。使用 **Thread** 类创建的线程被主线程的子线程调用。您可以使用 Thread 类的 **CurrentThread** 属性访问线程。
