#  B树

## B 树基本概念

　　为什么要引入 B 树，二叉树不是很好吗？存在即合理，所以有存在的理由。B 树的时间复杂度与二叉树一样，均为 O(logN)。然而 B 树出现时因为磁盘 IO。IO 操作的效率很低，那么，当在大量数据存储中，查询时不能一下子把所有数据加载到内存中，只能逐一加载磁盘也，每个磁盘页对应树的节点。造成大量磁盘 IO 操作（最坏情况下为树的高度）。平衡二叉树由于树深度过大而造成磁盘 IO 读写过于频繁，进而导致效率低下。

　　为了减少磁盘 IO 的次数，就必须降低树的深度，将 “瘦高” 的树变得 “矮胖”。

　　B 树这种数据结构常常用于实现数据库索引，因为它的查找效率比较高。

### 磁盘 IO 与预读

　　磁盘读取依靠的是机械运动，分为寻道时间、旋转延迟、传输时间三个部分，这三个部分耗时相加就是依次磁盘 IO 的时间，大概 9ms 左右。这个成本是访问内存的十万倍左右；正是由于磁盘 IO 是非常昂贵的操作，所以计算机操作系统对此做了优化：预读；每一次 IO 时，不仅仅把当前磁盘地址的数据加载到内存，同时也把相邻数据页加载到内存缓冲区中。因为局部预读原理说明：当访问一个地址数据的时候，与其相邻的数据很快也会被访问到。每次磁盘 IO 读取的数据称之为一页（page）。一页的大小与操作系统有关，一般为 4K 或者 8K。这也就意味着读取一页数据的时候，实际上发生了一次磁盘 IO。

### B-Tree 与二叉查找树的对比

　　二叉查找树查询的时间复杂度是 O(logN)，查找速度最快和比较次数最少，既然性能已经如此优秀，但为什么实现索引是使用 B-Tree 而不是二叉查找树，关键因素是磁盘 IO 的次数。

　　数据库索引是存储在磁盘上，当表中的数据量比较大时，索引的大小也跟着增长，达到几个 G 甚至更多。当利用索引仅从查询的时候，不可能把索引全部加载到内存中，只能逐一加载每个磁盘页，这里的磁盘页就对应索引树的结点。

　　二叉树：

![](image/B树二叉树.png)

　　B 树：

![](image/B树示例.png)

#### 二叉树

　　二叉树以 2 为最大基准向下延伸，而 B 树则没有标准，所以它可以变得矮矮胖胖的。

　　B 树又叫平衡多路查找树。一棵 m 阶的 B 树（m 叉树）的特性如下：

* B 树中所有节点的孩子节点数中的最大值称为 B 树的阶，记为 M（重点）
* 树中的每个节点至少有 M 棵子树 - 即：如果定了 M，则这个 B 树中任何节点的子节点数量都不能超过 M。
* 若根节点不是终端节点，则至少有两棵子树。
* 除根节点和叶节点外，所有点至少有 m/2 棵子树（上溢）
* 所有的叶子节点都位于同一层。（比如上面的图片中没有了 11 13 15，那么 12 就没有存在的意义了，就需要调整整个树的布局）

　　根据 Knuth's 的定义，n 阶 B 树（a B-tree of order n）是具有以下性质：

* 每个点最多有 n 个孩子
* 每个非叶子节点（根节点除外）最多有 n/2 （向上取整）个孩子
* root 至少有 1 个子树，除非 root 的孩子是叶子节点
* k 个孩子的非叶子节点含有 k-1 个键值
* 所有的叶子接待你都在同一层，并且内部节点不携带任何信息。（B 树的阶指最大子节点树。优势，n 阶的 B 树节点定义为有 k 个键值和 k+1 个指针，其中 n<= k <= 2n，用于指定最少的子节点数）

　　注意：根节点为叶子节点，整棵树只有一个根节点。

　　二叉树查找时磁盘 IO 的次：定义一个树高为 4 的二叉树，查找值为 10：

![](image/二叉树查找磁盘IO1.png)

　　第一次磁盘 IO：

![](image/二叉树查找磁盘IO2.png)

　　第二次磁盘 IO：

![](image/二叉树查找磁盘IO3.png)

　　第三次磁盘 IO：

![](image/二叉树查找磁盘IO4.png)

　　第四次磁盘 IO：

![](image/二叉树查找磁盘IO5.png)

　　从二叉树的查找过程来看，树的高度和磁盘 IO 的次数都是 4，所以最坏的情况下磁盘 IO 的次数由树的高度来决定。

　　从前面分析情况来看，减少磁盘 IO 的次数就必须要压缩树的高度，让瘦高的树尽量变成矮胖的树，所以 B-Tree 就在这样的背景下诞生了。

#### B-Tree

　　m 阶 B-Tree 满足以下条件：

1. 每个节点最多拥有 m 个子树
2. 根节点至少有 2 个子树
3. 分支节点至少拥有 m/2 棵子树（除根节点和叶子节点外都是分支节点）
4. 所有叶子节点都在同一层、每个节点最多可以有 m-1 个 key，并且以升序排列

## B 树的查找操作

　　在 B 树上进行查找和二叉树的查找很相似，二叉树是每个节点上有一个关键字和两个分支。B 树上每个节点有 K 个关键字和 K+1 个分支。二叉树的查找只考虑向左还是向右走，而 B 树中需要由多个分支决定。

　　B 树的查找分两步，首先查找结点，由于 B 树通常是在磁盘上存储的所以这步需要进行磁盘 IO 操作。第二步时查找关键字，当找到某个节点后将该节点读入内存中然后通过顺序或者折半查找来查找关键字。若没有找到关键字，则需要判断大小来找到合适的分支继续查找。

　　如下有一个 3 阶的 B 树，观察查找元素 21 的过程：

![](image/三阶B树.png)

　　第一次磁盘 IO：

![](image/B树查找磁盘IO1.png)

　　这里有一次内存比对：分别跟 3 和 12 比对。

　　第二次磁盘 IO：

![](image/B树查找磁盘IO2.png)

　　第三次磁盘 IO：

![](image/B树查找磁盘IO3.png)

　　这里有一次内存比对，分别跟 14 与 21 比对。

　　从查找过程中发现，B 树的比对次数和磁盘 IO 的次数与二叉树相差不了多少，所以这样看来并没有什么优势。

　　但是仔细一看会发现，比对是在内存中完成的，不涉及到磁盘 IO，耗时可以忽略不计。另外 B 树中一个节点中可以存放很多的 Key（个数由树阶决定）。

　　相同数量的 key 在 B 树种生成的节点要远远少于二叉树中的节点，相差的节点数量就等同于磁盘 IO 的次数。这样到达一定数量后，性能的差异就显现出来了。

　　由于 B 树相对于二叉树来说矮胖了许多，所以它锁涉及的 IO 操作也相对少了许多。不过根据上面的分析，其在查找数据的时候并没有减少比较次数。但是在比较数据的时候是在内存中进行的，所以相对来说时间上会更加迅速，几乎可以忽略。

　　而相同数量的 key 在 B 树中生成的节点要远远少于二叉树中的节点，相差的节点数量就等同于磁盘 IO 的次数。这样到达一定数量后，性能的差异就显现出来了。



## B 树的新增

　　对高度为 k 的 m 阶 B 树，新结点一般是插在叶子层。通过检索可以确定关键码应插入的结点位置。然后分两种情况讨论：

1. 若该节点中关键码个数小于 m-1，则直接插入即可。
2. 若该节点中关键码个数等于 m-1，则将引起节点的分裂。以中间关键码为界将节点一分为二，产生一个新节点，并将中间关键码插入到父节点（k-1 层）中。

　　重复上述工作，最坏情况一直分裂到根节点，建立一个新的根节点，整个 B 树增加一层。

　　例如：在下面的 B 树种插入 key:4

![](image/B树插入1.png)

1. 第一步：检索 key 插入的节点位置如上图所示，在 3、5 之间。

2. 第二步：判断节点种的关键码个数

   节点 3、5 已经是连元素节点，无法再增加（已经  = 3-1）。父亲节点 2、6 也是两元素节点，也无法再增加。根节点 9 是单元素节点，可以升级为两元素节点。

3. 第三步：节点分裂

   拆分节点 3、5 与节点 2、6，让根节点 9 升级为两元素节点 4、9。节点 6 独立为根节点的第二个孩子。

　　最终结果图如下：虽然插入比较麻烦，但是这也能确保 B 树是一个自平衡的树。

![](image/B树插入2.png)

　　另一个例子：

![](image/B树插入3.png)

　　当插入一个关键字 60 后，节点内的关键字个数超过了 m-1=2，此时必须进行节点分裂，分裂的过程图如上图所示。



　　新增元素 4，它应该在 3 与 9 之间：

![](image/B树新增1.png)

![](image/B树新增2.png)

![](image/B树新增3.png)

## B 树的删除

　　首先，根据 key 删除记录，如果 B 树中的记录中不存在对应 key 的记录，则删除失败。

　　之后需要分以下四种情况老考虑。

　　下面的例子中以 5 阶 B 树为例，介绍 B 树的删除操作，5 阶 B 树种，节点最多有 4 个 key，最少有 2 个 key。

　　对于删除 key 的过程来说，对于叶节点和非叶节点其实差别在一个地方，那就是如果当前操作的是非叶节点，那么后继 key（这里的后继 key 指最接近当前删除值，且大于当前删除值的值）覆盖要删除的 key，然后在后继 key 所在的子支中删除该后继 key。

　　例如：

1. 原始状态

   ![](image/B树删除节点1.png)

2. 在伤处情况下接着删除 27。从上图可知 27 位于非叶子节点中，所以用 27 的后继替换它。从图中可以看出，27 的后继为 28，用 28 替换 27，然后在 28（原 27） 的右孩子节点中删除 28。删除后的结果如下图所示。

   

　　删除元素 9：

![](image/B树删除1.png)

![](image/B树删除2.png)



## 总结

　　插入或者删除元素都会导致节点发生裂变反应，有时候会非常麻烦，但正因为如此才让 B 树能够始终保持多路平衡，这也是 B 树自身的一个优势：自平衡；B 树主要应用于文件系统以及部分数据库索引，如 MongoDB，大部分关系型数据库索引则是使用 B+ 树实现。

## 参考文章

1. [B树详解](https://www.jianshu.com/p/a858bb15cbf0)
2. [B-Tree与二叉查找树的对比](http://m.elecfans.com/article/662237.html)
3. [平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了](https://zhuanlan.zhihu.com/p/27700617)