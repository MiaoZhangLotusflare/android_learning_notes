#  直接插入排序

## 1. 基本思想

　　通常人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。在计算机的实现中，为了要给插入的元素腾出空间，需要将其余所有元素在插入之前都向右移动一位。

　　直接插入的思想是：将一个记录插入到已排好序的有序表中，从而得到一个新的、记录数增 1 的有序表。

　　例如，排序序列（3，2，1，5）的过程是，初始时有序序列为（3），然后从位置 1 开始，先访问到 2，将 2 插入到 3 前面，得到有序序列（2，3），之后访问 1，找到合适的插入位置后得到有序序列（1，2，3），最后访问 5，得到最终有序序列（1，2，3，5）。

## 2. 算法描述

　　一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下：

1. 从第一个元素开始，该元素可以认为已经被排序。
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描。
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置。
4. 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置。
5. 将新元素插入到该位置后。
6. 重复步骤 2~5。

　　动态效果如下：

![](image/直接插入排序.gif)

　　注意：如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为二分查找插入排序。

## 3. 代码实现

```java
/**
 * 直接插入排序
 */
public class InsertSort {

    /**
     * 通过交换进行插入排序，借鉴冒泡排序
     *
     * @param a
     */
    public static void sort(int[] a) {
        for (int i = 0; i < a.length - 1; i++) {
          	// 插入前面已经排好序的序列
            for (int j = i + 1; j > 0; j--) {
                if (a[j] < a[j - 1]) {
                    int temp = a[j];
                    a[j] = a[j - 1];
                    a[j - 1] = temp;
                }
            }
        }
    }

    /**
     * 通过将较大的元素都向右移动而不总是交换两个元素
     *
     * @param a
     */
    public static void sort2(int[] a) {
        for (int i = 1; i < a.length; i++) {
            int num = a[i];
            int j;
          	// 插入前面已经排好序的序列
            for (j = i; j > 0 && num < a[j - 1]; j--) {
                a[j] = a[j - 1];
            }
            a[j] = num;
        }
    }
}
```

　　测试：

```java
    public static void main(String[] args) {
        int a1[] = new int[]{9, 1, 2, 7, 4, 8, 6, 3, 5};
        sort(a1);
        System.out.println("sort a1:" + Arrays.toString(a1));
        int a2[] = new int[]{9, 1, 2, 7, 4, 8, 6, 3, 5};
        sort2(a2);
        System.out.println("sort2 a2:" + Arrays.toString(a2));
    }
```

　　输出：

```java
sort a1:[1, 2, 3, 4, 5, 6, 7, 8, 9]
sort2 a2:[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

## 4. 复杂度分析

　　直接插入排序复杂度如下：

| 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 |
| -------------- | -------- | -------- | ---------- |
| O(n^2)         | O(n)     | O(n^2)   | O(1)       |

　　最好情况下，当待排序序列中记录已经有序时，则需要 n-1 次比较，不需要移动，时间复杂度为 O(n)。最差情况下，待排序序列中所有记录正好逆序时，则比较次数和移动次数都达到最大值，时间复杂度为 O(n^2)，平均情况下，时间复杂度为 O(n^2)。

## 5. 比较与总结

　　插入排序所需的时间取决于输入元素的初始顺序。例如，对一个很大且其中的元素已经有序（或接近有序）的数组进行排序将会比随机顺序的数组或是逆序数组进行排序要快得多。

## 6. 参考文章

1. [Java实现八大排序算法](https://www.cnblogs.com/morethink/p/8419151.html)

7. [常见数据结构与算法整理总结（下）](https://www.jianshu.com/p/42f81846c0fb)

