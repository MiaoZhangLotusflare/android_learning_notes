#  简单选择排序

## 1. 基本思想

　　选择排序（Selection sort）是一种简单直接的排序算法。无论什么数据进去都是 O(n^2) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间。

　　它的工作原理如下：

1. 首先在为排序序列中找到最小（大）元素，存放在排序序列的起始位置，
2. 然后，再从剩余为排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
3. 重复第二步，直到所有元素均排序完毕。

　　选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一堆元素，它们当中至少有一个将被移到其最终位置上，因此对 n 个元素的进行排序总共进行至多 n-1 次交换，在所有的安全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。

　　简单选择排序的思想是：设排序序列的记录个数为 n，进行 n-1 次选择，每次在 n-i+1(i=1,2,......,n-1)个记录中选择关键字最小的记录作为有效序列中的第 i 个记录。

　　例如，排序序列（3，2，1，5）的过程是，进行 3 次选择，第 1 次选择在 4 个记录中选择最小的值为 1，放在第 1 个位置，得到序列（1，3，2，5），第 2 次选择从位置 1 开始的 3 个元素中选择最小的值 2 放在第 2 个位置，得到有序序列（1，2，3，5），第3 次选择因为最小的值 3 已经在第 3 个位置不需要操作，最后得到有序序列（1，2，3，5）。

## 2. 算法描述

1. 在未排序序列中，找到关键字最小的元素。
2. 如果最小元素不是未排序序列的第一个元素，将其和为排序序列第一个元素互换。
3. 重复 1、2 步，直到排序结束。

　　动画效果如下所示：

![](image/简单选择排序.gif)

## 3.  代码实现

```java
/**
 * 简单选择排序
 */
public class SelectionSort {

    public static void sort(int[] a) {
        for (int i = 0; i < a.length; i++) {
            int min = i;
            // 选出之后待排序中值最小的位置
            for (int j = i + 1; j < a.length; j++) {
                if (a[j] < a[min]) {
                    min = j;
                }
            }

            // 最小值不等于当前值时进行交换
            if (min != i) {
                int temp = a[i];
                a[i] = a[min];
                a[min] = temp;
            }

        }
    }

}

```

　　测试：

```java
    public static void main(String[] args) {
        int a[] = new int[]{9, 1, 2, 7, 4, 8, 6, 3, 5};
        sort(a);
        System.out.println("a:" + Arrays.toString(a));
    }
```

　　输出：

```java
a:[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

## 4. 复杂度分析

　　简单选择排序过程中需要进行的比较次数与初始状态下待排序的记录序列的排序情况无关。当 i = 1 时，需进行 n-1 次比较；当 i = 2 时，需进行 n-2 次比较；以此类推，共需要进行的比较次数是 (n-1)+(n-2)+.....+2+1 = n(n-1)/2，即进行比较操作的时间复杂度为 O(n^2)，进行移动操作的时间复杂度为 O(n)。总的时间复杂度为 O(n^2)。

　　最好情况下，即待排序序列初始状态就已经是正序排列了，则不需要移动记录。最坏情况下，即待排序记录初始状态是按第一条记录最大，之后的记录从大到小顺序排序，则需要移动记录的次数最多为 3(n-1)。

　　简单选择排序是不稳定排序。

　　以下是选择排序复杂度：

| 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 |
| -------------- | -------- | -------- | ---------- |
| O(n^2)         | O(n^2)   | O(n^2)   | O(1)       |

## 5. 总结与思考

　　选择排序的简单和直观名副其实，这也造就了它 “ 出了名的慢性子 ”，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近 n^2/2 遍历来确认一遍。即便是这样，它的排序结果也还是不稳定的。唯一值得高兴的是，它并不耗费额外的内存空间。

## 6. 参考文章

1. [Java实现八大排序算法](https://www.cnblogs.com/morethink/p/8419151.html)
2. [从零开始学数据结构和算法(一)冒泡与选择排序](https://juejin.im/post/5c9442cb5188252da9013153)
3. [常见数据结构与算法整理总结（下）](https://www.jianshu.com/p/42f81846c0fb)

