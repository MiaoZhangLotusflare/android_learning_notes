#  冒泡排序

## 基本思想

　　冒泡排序（Bubble Sort）是一种简单直观的排序算法。它重复地走访过要排序地数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法地名字由来是因为越小地元素会经有交换慢慢 “浮“ 到数列的顶端。

　　冒泡排序还有一种优化算法，就是立一个 flag，当在一样序列遍历中元素没有发生变换，则说明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。

　　冒泡排序的基本思想是：设排序序列的记录个数为 n，进行 n-1 次遍历，每次遍历从开始位置一次往后比较前后相邻元素，这样较大的元素往后移，n-1 次遍历结束后，序列有序。

　　例如，对序列 （3，2，1，5）进行排序的过程是：共进行 3 次遍历，第 1 次遍历时先比较 3 和 2，交换，继续比较 3 和 1，交换，再比较 3 和 5，不交换，这样第 1 次遍历结束，最大值 5 在最后的位置，得到序列（2，1，3，5）.第二次遍历时先比较 2 和 1，交换，继续比较 2 和 3，不交换，第 2 次遍历结束时次大值 3 在倒数第 2 的位置，得到序列（1，2，3，5），第 3 次遍历时，先比较 1 和 2，不交换，得到最终有序序列（1，2，3，5）。

　　需要注意的是，如果在某次遍历中没有发生交换，那么就不必进行下次遍历，因为序列已经有序。

## 算法描述

　　冒泡排序算法的运作如下：

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一堆数字需要比较。

![](image/bubble.gif)

## 复杂度分析

　　最佳情况下冒泡排序只需一次遍历就能确定数组已经排好序，不需要进行下一次遍历，所以最佳情况下，时间复杂度为 O(n)。

　　最坏情况下冒泡排序需要 n-1 次遍历，第一次遍历需要比较 n-1 次，第二次遍历需要 n-2 次，...，最后一次需要比较 1 次，最差情况下时间复杂度为 O(n^2)。

　　以下是冒泡排序算法复杂度：

| 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 |
| -------------- | -------- | -------- | ---------- |
| O(n^2)         | O(n)     | O(n^2)   | O(1)       |

　　冒泡排序是最容易实现的排序，最坏的情况是每次都需要交换，共需遍历并交换将近 n^2/2 次，时间复杂度为 O(n^2)。最佳的情况是内循环一次后发现排序是对的，因此退出循环，时间复杂度为 O(n)。平均来讲，时间复杂度为 O(n^2)。由于冒泡排序中只有缓存的 temp 变量需要内存空间，因此空间复杂度为常量 O(1)。

## 代码实现

```

```



## 总结与思考

　　由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置，它并不改变相同元素之间的相对顺序，因此它是稳定的排序算法。

　　使用场景：数据量足够小，比如斗牛游戏的牌面排序。

## 参考文章

1. [Java实现八大排序算法](https://www.cnblogs.com/morethink/p/8419151.html)
2. [从零开始学数据结构和算法(一)冒泡与选择排序](https://juejin.im/post/5c9442cb5188252da9013153)
3. [常见数据结构与算法整理总结（下）](https://www.jianshu.com/p/42f81846c0fb)

