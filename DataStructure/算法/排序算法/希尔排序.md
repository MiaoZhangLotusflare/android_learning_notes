#  希尔排序

　　希尔排序，也称递减增量排序算法、“ 缩小增量 ” 排序，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。

　　希尔排序是基于插入排序的以下两点性质而提出改进方法的：

* 直接插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。
* 直接插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。

　　希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录 “ 基本有序 ” 时，再对全体记录进行依次直接插入排序。

## 1. 基本思想

　　将待排序数组按照步长 gap 进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将 gap 折半减少，循环上述操作；当 gap = 1 时，利用直接插入，完成排序。

　　可以看到步长的选择是希尔排序的重要部分。只要最终步长为 1 任何步长序列都可以工作。一般来说最简单的步长取值是初次取数组长度的一半为增量，之后每次再减半，直到增量为 1。

## 2. 算法描述

1. 选择一个增量序列 t1,t2,......,tk，其中 ti > tj，tk=1；
2. 按增量序列个数 k，对序列进行 k 趟排序；
3. 每趟排序，根据对应的增量 ti，将待排序序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

　　效果如下：

![](image/希尔排序.png)

## 3. 代码实现

```java
/**
 * 希尔排序
 */
public class HiliSort {
    public static void sort(int[] a) {
        int length = a.length;
        int h = 1;
        while (h < length / 3) h = 3 * h + 1;
        for (; h >= 1; h /= 3) { // 步长的循环
            System.out.println();
            System.out.println("h:" + h);
            // 分块
            for (int i = 0; i < a.length - h; i += h) {
                System.out.println("i:" + i);
                // 对分块的内容进行排序
                for (int j = i + h; j > 0; j -= h) {
                    System.out.print("j:" + j+",");
                    if (a[j] < a[j-h]) {
                        int temp = a[j];
                        a[j] = a[j - h];
                        a[j - h] = temp;
                    }
                }
                System.out.println();
            }
        }
    }

    public static void main(String[] args) {
        int a[] = new int[]{9, 1, 2,  7, 4, 8, 6, 3, 5};
        sort(a);
        System.out.println("a:" + Arrays.toString(a));
    }
}
```

　　输出为：

```java
h:4
i:0
j:4,
i:4
j:8,j:4,

h:1
i:0
j:1,
i:1
j:2,j:1,
i:2
j:3,j:2,j:1,
i:3
j:4,j:3,j:2,j:1,
i:4
j:5,j:4,j:3,j:2,j:1,
i:5
j:6,j:5,j:4,j:3,j:2,j:1,
i:6
j:7,j:6,j:5,j:4,j:3,j:2,j:1,
i:7
j:8,j:7,j:6,j:5,j:4,j:3,j:2,j:1,
a:[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

## 4. 复杂分析

　　以下是希尔排序复杂度：

| 平均时间复杂度 | 最好情况   | 最坏情况   | 空间复杂度 |
| -------------- | ---------- | ---------- | ---------- |
| O(nlog2 n)     | O(nlog2 n) | O(nlog2 n) | O(1)       |

## 5. 总结与思考

　　希尔排序更高效的原因是它权衡了子数组的规模和有序性。排序之初，每个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。

## 6. 参考文章

1. [Java实现八大排序算法](https://www.cnblogs.com/morethink/p/8419151.html)


