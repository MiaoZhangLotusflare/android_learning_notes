# 1.1. 数据/链表

数组链表代表着计算机最基本的两种存储形式：顺序存储和链式存储，所以他俩可以算是最基本的数据结构。

数组链表的主要算法技巧是双指针，双指针⼜分为中间向两端扩散的双指针、两端向中间收缩的双指针、快慢指针。 

此外，数组还有前缀和和差分数组也属于必知必会的算法技巧。 

## 小而美的算法技巧：前缀和数组

前缀和技巧适⽤于快速、频繁地计算⼀个索引区间内的元素之和。

### 一维数据中的前缀和

⼒扣第 303 题「区域和检索 - 数组不可变」，让你计算数组区间内元素的和，这是⼀道标准的前缀和问题：https://leetcode.cn/problems/range-sum-query-immutable/

```
给定一个整数数组  nums，处理以下类型的多个查询:

计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的 和 ，其中 left <= right
实现 NumArray 类：

NumArray(int[] nums) 使用数组 nums 初始化对象
int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的 总和 ，包含 left 和 right 两点（也就是 nums[left] + nums[left + 1] + ... + nums[right] )

```

```
实例 1:
输入：
["NumArray", "sumRange", "sumRange", "sumRange"]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
输出：
[null, 1, -1, -3]

解释：
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)
numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) 
numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))
```

```
提示：
1 <= nums.length <= 104
-105 <= nums[i] <= 105
0 <= i <= j < nums.length
最多调用 104 次 sumRange 方法
```

题⽬要求你实现这样⼀个类：

```java
class NumArray {
	public NumArray(int[] nums) {}
	/* 查询闭区间 [left, right] 的累加和 */
	public int sumRange(int left, int right) {}
}
```

sumRange 函数需要计算并返回⼀个索引区间之内的元素和，没学过前缀和的⼈可能写出如下代码：

```java
class NumArray {
	private int[] nums;
	public NumArray(int[] nums) {
		this.nums = nums;
	}
	public int sumRange(int left, int right) {
		int res = 0;
		for (int i = left; i <= right; i++) {
	 		res += nums[i];
 		}
		return res;
	}
}
```

这样，可以达到效果，但是效率很差，因为 sumRange ⽅法会被频繁调⽤，⽽它的时间复杂度是 O(N)，其中 N 代表 nums 数组的⻓度。 

这道题的最优解法是使⽤前缀和技巧，将 sumRange 函数的时间复杂度降为 O(1)，说⽩了就是不要在 sumRange ⾥⾯⽤ for 循环：

```java
class NumArray {
// 前缀和数组
private int[] preSum;
/* 输⼊⼀个数组，构造前缀和 */
public NumArray(int[] nums) {
// preSum[0] = 0，便于计算累加和
 preSum = new int[nums.length + 1];
// 计算 nums 的累加和
for (int i = 1; i < preSum.length; i++) {
 preSum[i] = preSum[i - 1] + nums[i - 1];
 }
 }
/* 查询闭区间 [left, right] 的累加和 */
public int sumRange(int left, int right) {
return preSum[right + 1] - preSum[left];
 }
}
```

核⼼思路是我们 new ⼀个新的数组 preSum 出来，preSum[i] 记录 nums[0..i-1] 的累加和。

![](img/前缀和.png)

看这个 preSum 数组，如果想求索引区间 [1, 4] 内的所有元素之和，就可以通过 preSum[5] -preSum[1] 得出。 

这样，sumRange 函数仅仅需要做⼀次减法运算，避免了每次进⾏ for 循环调⽤，最坏时间复杂度为常数 O(1)。 

### 二维区域和检索 - 矩阵不可变

⼒扣第 304 题「304. ⼆维区域和检索 - 矩阵不可变」，其实和上⼀题类似，上⼀题是让你计算⼦数组的元素之和，这道题让你计算⼆维矩阵中⼦矩阵的元素之和：https://leetcode.cn/problems/range-sum-query-2d-immutable/

```
给定一个二维矩阵 matrix，以下类型的多个请求：

计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下角 为 (row2, col2) 。
实现 NumMatrix 类：

NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化
int sumRegion(int row1, int col1, int row2, int col2) 返回 左上角 (row1, col1) 、右下角 (row2, col2) 所描述的子矩阵的元素 总和 。
```

![](img/leetcode304.png)

这题的思路和⼀维数组中的前缀和是⾮常类似的，如下图：

![](img/leetcode304-2.png)

如果想计算红⾊的这个⼦矩阵的元素之和，可以⽤绿⾊矩阵减去蓝⾊矩阵减去橙⾊矩阵最后加上粉⾊矩阵，⽽绿蓝橙粉这四个矩阵有⼀个共同的特点，就是左上⻆就是 (0, 0) 原点。 

可以维护⼀个⼆维 preSum 数组，专⻔记录以原点为顶点的矩阵的元素之和，就可以⽤⼏次加减运算算出任何⼀个⼦矩阵的元素和：

```javascript
class NumMatrix {
// preSum[i][j] 记录矩阵 [0, 0, i, j] 的元素和
private int[][] preSum;
public NumMatrix(int[][] matrix) {
int m = matrix.length, n = matrix[0].length;
if (m == 0 || n == 0) return;
// 构造前缀和矩阵
 preSum = new int[m + 1][n + 1];
labuladong 的刷题秘籍 labuladong的刷题三件套
34 / 604
for (int i = 1; i <= m; i++) {
for (int j = 1; j <= n; j++) {
// 计算每个矩阵 [0, 0, i, j] 的元素和
 preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i
- 1][j - 1] - preSum[i-1][j-1];
 }
 }
 }
// 计算⼦矩阵 [x1, y1, x2, y2] 的元素和
public int sumRegion(int x1, int y1, int x2, int y2) {
// ⽬标矩阵之和由四个相邻矩阵运算获得
return preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] +
preSum[x1][y1];
 }
}
```

这样，sumRegion 函数的复杂度也⽤前缀和技巧优化到了 O(1)。 

### 和为 K 的子数组

⼒扣第 560 题「和为 K 的⼦数组」： 

```
给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。
```

示例：

```
输入：nums = [1,1,1], k = 2
输出：2
输入：nums = [1,2,3], k = 3
输出：2
```

提示：

```
1 <= nums.length <= 2 * 104
-1000 <= nums[i] <= 1000
-107 <= k <= 107
```

那我把所有⼦数组都穷举出来，算它们的和，看看谁的和等于 k 不就⾏了，借助前缀和技巧很容易写出⼀个 

解法：

```java
int subarraySum(int[] nums, int k) {
int n = nums.length;
// 构造前缀和
int[] preSum = new int[n + 1];
 preSum[0] = 0; 
for (int i = 0; i < n; i++)
 preSum[i + 1] = preSum[i] + nums[i];
int res = 0;
// 穷举所有⼦数组
for (int i = 1; i <= n; i++)
for (int j = 0; j < i; j++)
// ⼦数组 nums[j..i-1] 的元素和
if (preSum[i] - preSum[j] == k)
 res++;
return res;
}
```

这个解法的时间复杂度 O(N^2) 空间复杂度 O(N)，并不是最优的解法。不过通过这个解法理解了前缀和数组的⼯作原理之后，可以使⽤⼀些巧妙的办法把时间复杂度进⼀步降低。 

优化的思路是：我直接记录下有⼏个 **preSum[j]** 和 **preSum[i] - k** 相等，直接更新结果，就避免了内层 的 for 循环。我们可以⽤哈希表，在记录前缀和的同时记录该前缀和出现的次数。

```java
int subarraySum(int[] nums, int k) {
int n = nums.length;
// map：前缀和 -> 该前缀和出现的次数
 HashMap<Integer, Integer> 
 preSum = new HashMap<>();
// base case
 preSum.put(0, 1);
int res = 0, sum0_i = 0;
for (int i = 0; i < n; i++) {
 sum0_i += nums[i];
// 这是我们想找的前缀和 nums[0..j]
int sum0_j = sum0_i - k;
// 如果前⾯有这个前缀和，则直接更新答案
if (preSum.containsKey(sum0_j))
 res += preSum.get(sum0_j);
// 把前缀和 nums[0..i] 加⼊并记录出现次数
 preSum.put(sum0_i, 
 preSum.getOrDefault(sum0_i, 0) + 1);
 }
return res;
}
```

这样，就把时间复杂度降到了 O(N)，是最优解法了。

## 小而美的算法技巧：差分数组

前缀和主要适⽤的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。 

