# 关于数据结构的常见问题

# 1. 快排了解不？最坏的情况是怎样？如果有大量重复数据怎么优化？

　　快速排序的主要思想是：在待排序的序列中选择一个称为主元的元素，将数组分为两部分，使得第一部分中的所有元素都小于或等于主元，而第二部分中的所有元素都大于主元，然后对两部分递归地应用快速排序算法，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

　　**最好**情况O(n * logn)——Partition函数每次恰好能均分序列，其递归树的深度就为.log2n.+1（.x.表示不大于x的最大整数），即仅需递归log2n次； **最坏**情况O（n^2）,每次划分只能将序列分为一个元素与其他元素两部分，这时的快速排序退化为冒泡排序，如果用数画出来，得到的将会是一棵单斜树，也就是说所有所有的节点只有左（右）节点的树；平均时间复杂度O(n*logn)。

　　如果有大量重复数据则采用三向快速排序。

　　实际应用中经常会出现含有大量重复元素的数组。例如，一个元素全部重复的子数组就不需要继续排序了，但算法还会继续将它切分为更小的数组。在有大量重复元素的情况下，快速排序的递归行会使元素全部重复的子数组经常出现，这就有很大的改进潜力，经当前实现的性能对数级的性能提高到线性级别。

* 在 lt 之前的 （lo ~ lt-1）都小于中间值
* 在 gt 之前的 （gt+1 ~ h）都大于中间值
* 在 lt ~ i-1 的都等于中间值
* 在 i ~ gt 的都还不确定（最终 i 会大于 gt，即不确定的将不复存在）

![](算法/排序算法/image/三向快速排序.png)

```java
public static void sortThreeWay(int[] a, int lo, int hi) {
    if (lo >= hi) {
        return;
    }
    int v = a[lo], lt = lo, i = lo + 1, gt = hi;
    while (i <= gt) {
        if (a[i] < v) {
            swap(a, i++, lt++);
        } else if (a[i] > v) {
            swap(a, i, gt--);
        } else {
            i++;
        }
    }
    sortThreeWay(a, lo, lt - 1);
    sortThreeWay(a, gt + 1, hi);
}

private static void swap(int[] a, int i, int j) {
    int t = a[i];
    a[i] = a[j];
    a[j] = t;
}
```



## 1. 八大排序算法（手写，时间复杂度和空间复杂度）



## 2. 查找算法（二分查找）



## 3. KMP 算法

字符串匹配算法，有一堆字符串，在其中找到指定的某些字符。

