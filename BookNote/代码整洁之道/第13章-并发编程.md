# 第 13 章 并发编程

　　“ 对象是过程的抽象。线程是调度的抽象。”

## 13.1. 为什么要并发

​		并发是一种解耦策略。它帮助我们把做什么（目的）和何时（时机）做分解开。

​		解耦目的与时机能明显地改进应用程序的吞吐量和结构。从结构的角度来看，应用程序看起来更像是许多台协同工作的计算机，而不是一个大循环。系统因此会更易于被理解，给出了许多切分关注面的有力手段。

​		但结构并非采用并发的唯一动机。有些系统对响应时间和吞吐量有要求，需要手工编写并发解决方案。

​		看看以下常见的迷思和误解：

1. 并发总能改进性能

   并发有时能改进性能，但只在多个线程或处理器之间能分享大量等待时间的时候管用。事情没那么简单。

2. 编写并发程序无需修改设计

   事实上，并发算法的设计有可能与单线程系统的设计极不相同。目的与时机的解耦往往对系统结构产生巨大影响。

3. 在采用 Web 或 EJB 容器的时候，理解并发问题并不重要

   实际上，你最好了解容器在做什么，了解如何对付并发更新、死锁等问题。

​		下面是一些有关编写并发软件的中肯说法：

* 并发会在性能和编写额外代码上增加一些开销；
* 正确的并发是复杂的，即便对于简单的问题也是如此；
* 并发缺陷并非总能重现，所以常被看做偶发事件而忽略，未被当作真的缺陷看待；
* 并发常常需要对设计策略的根本性修改。

## 13.2. 挑战

```java
public class X{
	private int lastIdUsed;
	public int getNextId(){
		return ++lastIdUsed;
	}
}
```

​		上面的代码两个线程执行，就生成的字节码而言，对于在 getNextId 方法中执行的那两个线程，有 12870 种不同的可能执行路径。如果 lastIdUsed 的类型从 int 变为 long，则可能路径的数量将增至 2704156 种。当然，多数路径都得到正确结果。问题是其中一些不能得到正确结果。

## 13.3. 并发防御原则

​		下面给出一系列防御并发代码问题的原则和技巧。

### 13.3.1. 单一权责原则

​		单一权责原则（SRP）认为，方法/类/组件应当只有一个修改的理由。并发设计自身足够复杂到成为修改的理由，所以也该从其他代码中分离出来。不幸的是，并发实现细节常常直接嵌入到其他生产代码中。下面是要考虑的一些问题：

* 并发相关代码有自己的开发、修改和调优生命周期；
* 开发相关代码有自己要对付的挑战，和非并发相关代码不同，而且往往更为困难；
* 即便没有周边应用程序增加的负担，写得不好的并发代码可能的出错方式数量也已经足具挑战性。

​		**建议**：分离并发相关代码与其他代码。

### 13.3.2. 推论：限制数据作用域

​		如我们所见，两个线程修改共享对量的同一字段时，可能互相干扰，导致未预期的行为。解决方案之一是采用 synchronized 关键字在代码中保护一块使用共享对象的临界区（critical section）。限制临界区的数量很重要。更新共享数据的地方越多，就越可能：

* 你会忘记保护一个或多个临界区 -- 破坏了修改共享数据的代码；
* 得多花力气保证一切都受到有效防护（破坏了 DRY 原则）；
* 很难找到错误源，也很难判断错误源。

​		**建议**：谨记数据封装；严格限制对可能被共享的数据的访问。

### 13.3.3. 推论：使用数据复本

​		避免共享数据的好方法之一就是一开始就避免共享数据。在某些情形下，有可能复制对象并以只读方式对待。在另外的情况下，有可能复制对象，从多个线程收集所有复本的结果，并在单个线程中合并这些结果。

​		如果有避免共享数据的简易手段，结果代码就会大大减少导致错误的可能。你可能会关心创建额外对象的成本。值得试验一下看看那是否真是个问题。然而，假设使用对象复本能避免代码同步执行，则因避免了锁定而省下的价值有可能补偿得上额外的创建成本和垃圾收集开销。

### 13.3.4. 推论：线程应尽可能地独立

​		让每个线程在自己的世界中存在，不与其他线程共享数据。每个线程处理一个客户端请求，从不共享的源头接纳所有的请求数据，存储为本地变量。这样一来，每个线程都像是世界中的唯一线程，没有同步需要。

​		**建议**：尝试将数据分解到可被独立线程（可能在不同处理器上）操作的独立子集。

## 13.4. 了解 Java 库

​		相对于之前的版本，Java 5 提供了许多并发开发方面的改进。在用 Java 5 编写线程代码时，要注意以下几点：

* 使用类库提供的线程安全群集；
* 使用 executor 框架（executor framework）执行无关任务；
* 尽可能使用非锁定解决方案；
* 有几个类并不是线程安全的。

**线程安全群集**

​		java.util.concurrent 包中的群集对于多线程解决方案是安全的，执行良好。实际上，在几乎所有情况下，ConcurrentHashMap 实现都比 HashMap 表现得好。它还支持同步并发读写，也拥有支持多线程安全的合成操作的方法。

​		如果部署环境是 Java 5，可以采用 ConcurrentHashMap。

​		还有几个支持高级并发设计的类。以下是其中一小部分，如下表所示。

| 类             | 含义                                                         |
| -------------- | ------------------------------------------------------------ |
| ReentrantLock  | 可在一个方法中获取、在另一方法中释放的锁                     |
| Semaphore      | 经典的 “ 信号 ” 的一种实现，有计数器的锁                     |
| CountDownLatch | 在释放所有等待的线程之前，等待指定数量事件发生的锁。这样，所有线程都平等地几乎同时启动 |

表：支持高级并发设计的类（部分）

​		**建议**：检读可用的类。对于 Java，掌握 java.util.concurrent、java.util.concurrent.atomic 和 java.util.concurrent.locks。

## 13.5. 了解执行模型

​		有几种在并发应用中切分行为的途径。要讨论这些途径，我们需要理解一些基本定义，如下表所示。

| 名称     | 定义                                                         |
| -------- | ------------------------------------------------------------ |
| 限定资源 | 并发环境中有着固定或数量的资源。例如数据库连接和固定尺寸读/写缓存等。 |
| 互斥     | 每一时刻仅有一个线程能访问共享数据或共享资源。               |
| 线程饥饿 | 一个或一组线程在很长时间内或永久被禁止。例如，总是让执行得快的线程先运行，假如执行得快的线程没完没了，则执行时间长的线程就会“挨饿”。 |
| 死锁     | 两个或多个线程互相等待执行结束。每个线程都拥有其他线程需要的资源，得不到其他线程拥有的资源，就无法终止。 |
| 活锁     | 执行次序一致的线程，每个都想要起步，但发现其他线程已经 “ 在路上 ”。由于竞步的原因，线程会持续尝试起步，但在很长时间内却无法如愿，甚至永远无法启动。 |

表：基础定义

​		有了这些定义，我们就能讨论在并发编程中用到的几种执行模型了。

### 13.5.1. 生产者-消费者模型

​		一个或多个生产者线程创建某些工作，并置于缓存或队列中。一个或多个消费者线程从队列中获取并完成这些工作。生产者和消费者之间的队列是一种限定资源。

### 13.5.2. 读者-作者模型

​		当存在一个主要为读者线程提供信息源，但只偶尔被作者线程更新的共享资源，吞吐量就会是个问题。增加吞吐量，会导致线程饥饿和过时信息的累积。更新会影响吞吐量。协调读者线程，不去读作者线程正在更新的信息（反之亦然），这是一种辛苦的平衡工作。作者线程倾向于长期锁定许多读者线程，从而导致吞吐量问题。

​		挑战之处在于平衡读者线程和作者线程的需求，实现正确操作，提供合理的吞吐量，避免线程饥饿。

### 13.5.3. 宴席哲学家

​		用线程代替哲学家，用资源代替叉子，就变成了许多企业级应用中进程竞争资源的情形。如果没有用心设计，这种竞争式系统就会遭遇死锁、活锁、吞吐量和效率降低等问题。

​		你可能遇到的并发问题，大多数都是这三个问题的变种。请研究并使用这些算法，这样，遇到并发问题时你就能有解决问题的准备了。

​		**建议**：学习这些基础算法，理解其解决方案。

## 13.6. 警惕同步方法之间的依赖

​		同步方法之间的依赖会导致并发代码中的狡猾缺陷。Java 语言有 synchronized 概念，可以用来保护单个方法。然而，如果在同一个共享类中有多个同步方法，系统就可能写得不太正确了。

​		**建议**：避免使用一个共享对象的多个方法。

​		有时必须使用一个共享对象的多个方法。在这种情况发生时，有 3 种写对代码的手段：

* 基于客户端的锁定 -- 客户端代码在调用第一个方法前锁定服务器，确保锁的范围覆盖了调用最后一个方法的代码；
* 基于服务端的锁定 -- 在服务端内创建锁定服务端的方法，调用所有方法，然后解锁。让客户端代码调用新方法；
* 适配服务端 -- 创建执行锁定的中间层。这是一种基于服务端的锁定的例子，但不修改原始服务端代码。

## 13.7. 保持同步区域微小

​		关键字 synchronized 制造了锁。同一个锁维护的所有代码区域在任一时刻保证只有一个线程执行。锁是昂贵的，因为它们带来了延迟和额外开销。所以我们不愿将代码扔给 synchronized 语句了事。另一方面，临界区应该被保护起来。所以，应该尽可能少地设计临界区。

​		将同步延展到最小临界区范围之外，会增加资源争用、降低执行效率。

​		**建议**：尽可能减少同步区域。

## 13.8. 很难编写正确的关闭代码

​		编写永远运行的系统，与编写运行一段时间后平静地关闭的系统是两码事。

​		平静关闭很难做到。常见问题与死锁有关，线程一直等待永远不会到来的信号。

​		**建议**：尽早考虑关闭问题，尽早令其工作正常。这会花费比你预期更多的时间。检视既有算法，因为这可能会比想象中难得多。

## 13.9. 测试线程代码

​		证明代码的正确性不切实际。测试并不能确保正确性。然而，好的测试却能尽量降低风险。这对于所有单线程解决方案都是对的。当有两个或多个线程使用同一代码段和共享数据，事情就变得非常复杂了。

​		**建议**：编写有潜力暴露问题的测试，在不同的编程配置、系统配置和负载条件下频繁运行。如果测试失败，跟踪错误。别因为后来测试通过了后来的运行就忽略失败。

​		有一大推问题要考虑。下面是一些精练的建议：

* 将伪失败看作可能的线程问题；
* 先使非线程代码可工作；
* 编写可插拔的线程代码；
* 编写可调整的线程代码；
* 运行多于处理器数量的线程；
* 在不同平台上运行；
* 调整代码并强迫错误发生。

### 13.9.1. 将伪失败看作可能的线程问题

​		线程代码导致 “ 不可能失败的 ” 失败。

​		“ 偶发事件 ” 被忽略得越久，代码就越有可能搭建于不完善的基础之上。

​		**建议**：不要将系统错误归咎于偶发事件。

### 13.9.2. 先使非线程代码可工作

​		确保线程之外的代码可工作。通常，这意味着创建由线程调用的 POJO。POJO 与线程无涉，所以可在线程环境之外测试。能放进 POJO 中的代码越多越好。

​		**建议**：不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可工作。

### 13.9.3. 编写可插拔的线程代码

​		编写可在数个配置环境下运行的线程代码：

* 单线程与多个线程在执行时不同的情况；
* 线程代码与实物或测试替身互动；
* 用运行快速、缓慢和有变动的测试替身执行；
* 将测试配置为能运行一定数量的迭代。

​		**建议**：编写可插拔的线程代码，这样就能在不同的配置环境下运行。

### 13.9.4. 编写可调整的线程代码

​		要获得良好的线程平衡，常常需要试错。一开始，在不同的配置环境下检测系统性能。要允许线程数量可调整。在系统运行时允许线程发生变动。允许线程依据吞吐量和系统使用率自我调整。

### 13.9.5. 运行多于处理器数量的线程

​		系统在切换任务时会发生一些事。为了促使任务交换的发生，运行多于处理器或处理器核心数量的线程。任务交换越频繁，越有可能找到错过临界区或导致死锁的代码。

### 13.9.6. 在不同平台上运行

​		在不同环境中，多线程代码的行为也不一样。应该在所有可能部署的环境中运行测试。

​		**建议**：尽早并经常地在所有目标平台上运行线程代码。

### 13.9.7. 装置试错代码

​		线程中的缺陷之所以如此不频繁、偶发、难以重现，是因为在几千个穿过脆弱区域的可能路径中，只有少数路径会真的导致失败。

​		怎么才能增加捕捉住如此罕见之物的机会？可以装置代码，增加对 Object.wait()、Object.sleep()、Object.yield() 和 Object.priority() 等方法的调用，改变代码执行顺序。

​		这些方法都会影响执行顺序，从而增加了侦测到缺陷的可能性。有问题的代码，最好尽早、尽可能多地通不过测试。

​		有两种装置代码的方法：

* 硬编码；
* 自动化。

### 13.9.8. 硬编码

​		你可以手工向代码中插入 wait()、sleep()、yield() 和 priority() 的调用。在测试某段棘手的代码时，正当如此操作。

​		这种手法有许多毛病：

* 你得手工找到合适的地方来插入方法调用；
* 你怎么知道在哪里插入调用、插入什么调用？
* 不必要地在产品环境中留下这类代码，将拖慢代码执行速度；
* 这是种无的放矢的手段。你可能找不到缺陷。实际上，这不在你把握之中。

​		我们所需要的，是一种在测试中但不在生产中实现的手段。我们还需要为多次运行轻易地调整配置，从而增加总的发现错误机会。

​		无疑，如果将系统分解为对线程及控制线程的类一无所知的 POJO，就能更容易地找到装置代码的位置。而且，还能创建许多个以不同方式调用 sleep、yield 等方法的 POJO 测试。

### 13.9.9. 自动化

​		可以使用 Aspect-Oriented Framework、CGLIB 或 ASM 之类工具通过编程来装置代码。

​		有一种叫做 ConTest 的工具，由 IBM 开发，可以在代码的不同位置调用这个方法。

​		要点是让代码 “ 异动 ”，从而使线程以不同次序执行。编写良好的测试与 “ 异动 ” 相组合，能有效地增加发现错误的机会。

​		**建议**：使用异动策略搜出错误。

## 13.10. 小结

​		并发代码很难写正确。假如多线程和共享数据后，简单的代码也会变成噩梦。要编写并发代码，就得严格地编写整洁的代码，否则将面临微细和不频繁发生的失败。

​		第一要诀是遵循单一职责原则。将系统且分为分离了线程相关代码和线程无关代码的 POJO。确保在测试线程相关代码时只是在测试，没有做其他事情。线程相关代码应该保持短小和目的集中。

​		了解并发问题的可能原因：对共享数据的多线程操作，或使用了公共资源池。类似平静关闭或停止循环之类边界情况尤其棘手。

​		学习如何找到必须锁定的代码区域并锁定之。不要锁定不必锁定的代码。避免从锁定区域中调用其他锁定区域。这需要深刻理解某物是否已共享。尽可能减少共享对象和共享范围。修改对象的设计，向客户代码提供共享数据，而不是迫使客户代码管理共享状态。

​		问题会跳出来。那种在早期没跳出来的问题往往是偶发的。这种所谓偶发问题，通常仅在高负载下出现或偶然出现。所以，你要能在不同平台上、以不同配置持续重复运行线程代码。跟随 TDD 三要则而来的可测试性意味着某种程序的可插拔性，从而提供了在大量不同配置下运行代码的必要支持。

​		如果花点时间装置代码，就能极大地提升发现错误代码的机会。可以手工做，也可以使用某种自动化技术。尽早这么做。在将线程代码投入生产环境前，就要尽可能多地运行它。

​		只要采用了整洁的做法，做对的可能性就有翻天覆地的提高。











​		

