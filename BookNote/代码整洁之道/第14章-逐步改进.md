# 第 14 章 逐步改进

　　本章研究一个逐步改进的案例。

## 14.1. Args 的实现

​		变成是一种技艺甚于科学的东西。要编写整洁代码，必须先写肮脏代码，然后再清理它。

## 14.2. Args：草稿

​		混乱是逐渐产生的。更早的版本并不如此肮脏。

### 14.2.1. 所以我暂停了

​		许多种不同类型，类似的方法 -- 听起来像是个类。ArgumentMarshaler 的概念就是这样产生的。

### 14.2.2. 渐进

​		毁坏程序的最好方法之一就是以改进之名大动其机构。有些程序永远不能从这种所谓 “ 改进 ” 中恢复过来。问题在于，很难让程序以 “ 改进 ” 之前的方式工作。

​		为了避免这种状况发生，我采用了测试驱动开发的规程。这种手法的核心原则之一是保持系统始终能运行。换言之，采用 TDD，我不会允许做出破坏系统的修改。每次修改都必须保证系统能像之前一样工作。

​		需要一套能随需运行、确保系统行为不会改动的自动化测试。在搞出那个烂摊子的同时，也为 Args 类创建了一套单元测试和验收测试。单元测试用 Java 写成，采用 JUnit 管理。验收测试用 FitNesse 以 wiki 页形式写成。我可以随时运行这些测试，如果测试通过，就能打包票说系统以我期望的方式工作。

​		于是我开始做出大量小规模修改。每次修改都将系统结构向 ArgumentMarshaler 概念的方向推动。而且每次修改后，系统都要能动作。

## 14.3. 字符串参数

​		优秀的软件设计，大都关乎分离 -- 创建合适的空间放置不同种类的代码。对关注面的分隔让代码更易于理解和维护。

## 14.4. 小结

​		代码能工作还不够。能工作的代码经常会严重崩溃。满足于仅仅让代码能工作的程序员不够专业。他们会害怕没时间改进代码的结构和设计，我不敢苟同。没什么能比糟糕的代码给开发项目带来更深远和长期的损害了。进度可以重订，需求可以重新定义，团队动态可以修正。但糟糕的代码只是一直腐败发酵，无情地拖着团队的后腿。我无数次看到开发团队蹒跚前行，只因为他们匆匆搞出一片代码沼泽，从此之后命运再也不受自己控制。

​		当然，糟糕的代码可以清理。不过成本高昂。随着代码腐败下去，模块之间互相渗透，出现大量隐藏纠结的依赖关系。找到和破除陈旧的依赖关系又费时间又费劲。另一方面，保持代码整洁却相对容易。早晨在模块中制造出一堆混乱，下午就能轻易清理掉。更好的情况是，5 分钟之前制造出混乱，马上就能很容易地清理掉。

​		所以，解决之道就是保持代码持续整洁和简单。永不让腐坏有机会开始。

