# 第 5 章 调优案例分析与实战

## 5.1 概述

 　　在处理应用中的实际问题时，除了知识与工具外，经验同样时一个很重要的因素。

## 5.2 案例分析

### 5.2.1 大内存硬件上的程序部署策略

　　程序部署上的主要问题是过大的堆内存进行回收时带来的长时间的停顿。

　　目前单体应用在较大内存的硬件上主要的部署方式有两种：

1. 通过一个单独的 Java 虚拟机实例来管理大量的 Java 堆内存。
2. 同时使用若干个 Java 虚拟机，建立逻辑集群来利用硬件资源。

　　对于用户交互性强、对停顿时间敏感、内存又较大的系统，并不是一定要使用 Shenandoah、ZGC 这些明确以控制延迟为目标的垃圾收集器才能解决问题（当然不可否认，如果情况允许的话，这是最值得考虑的方案），使用 Parallel Scavenge/Old 收集器，并且给 Java 虚拟机分配较大的堆内存也是有很多运行得很成功的案例的，但前提是必须把应用的 Full GC 频率控制得足够低，至少要低到不会在用户使用过程中发生，譬如十几个小时乃至一整天都不出现一次 Full GC ，这样可以通过在深夜执行定时任务的方式触发 Full GC 甚至是自动重启应用服务器来保持内存可用空间在一个稳定的水平。

　　控制 Full GC 频率的关键是老年代的相对稳定，这主要取决于应用中绝大多数对象能否符合 “ 朝生夕灭 ” 的原则，即大多数对象的生存时间不应当太长，尤其是不能有成批量的、长生存时间的大对象产生，这样才能保障老年代空间的稳定。

　　在许多网站和 B/S 形式的应用里，多数对象的生存周期都应该是请求级或者页面级的，会话级和全局级的长生命对象相对较少。只要代码写得合理，实现在超大堆中正常使用没有 Full GC 应当并不困难，这样的话，使用超大堆内存时，应用响应速度才可能会有所保证。除此之外，如果读者计划使用单个 Java 虚拟机实例来管理大内存，还需要考虑下面可能面临的问题：

1. 回收大块堆内存而导致的长时间停顿，自从 G1 收集器的出现，增量回收得到比较好的应用，这个问题有所缓解，但要到 ZGC 和 Shenandoah 收集器成熟之后才得到相对彻底地解决。
2. 大内存必须有 64 位 Java 虚拟机的支持，但由于压缩指针、处理器缓存行容量（Cache Line）等因素，64 位虚拟机的性能测试结果普遍略低于相同版本的 32 位虚拟机。
3. 必须保证应用程序足够稳定，因为这种大型单体应用要是发生了堆内存溢出，几乎无法产生堆转储快照（要产生十几 GB 乃至更大的快照文件），哪怕成功生成了快照也难以进行分析；如果确实出了问题要进行诊断，可能就必须应用 JMC 这种能够在生产环境中进行的运维工具。
4. 相同的程序在 64 位虚拟机中消耗的内存一般比 32 位虚拟机要大，这是由于指针膨胀，以及数据类型对齐补白等因素导致的，可以开启（默认即开启）压缩指针功能来缓解。

　　如果计划使用逻辑集群的方式来部署程序，可能会遇到下面这些问题：

1. 节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同时访问某个磁盘文件的话（ 尤其是并发写操作容易出现问题 ），很容易导致 I/O 异常。
2. 很难最高效率地利用某些资源池，譬如连接池，一般都是在各个节点建立自己独立的连接池，这样有可能导致一些节点的连接池已经满了，而另外一些节点仍有较多空余。尽管可以使用集中式的 JNDI 来解决，但这个方案有一定复杂性并且可能带来额外的性能代价。
3. 如果使用 32 位 Java 虚拟机作为集群节点的话，各个节点仍然不可避免地受到 32 位的内存限制，在 32 位 Windows 平台中每个进程只能使用 2 GB 的内存，考虑到堆以外的内存开销，堆最多一般只能开到 1.5 GB。在某些Linux 或 UNIX 系统（如 Solaris ）中，可以提升到 3 GB 乃至接近 4 GB 的内存，但 32 位中仍然受最高 4 GB（2 的 32 次幂）内存的限制。
4. 大量使用本地缓存（如大量使用 HashMap 作为 K/V 缓存）的应用，在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点上都有一份缓存，这时候可以考虑把本地缓存改为集中式缓存。

### 5.2.2 集群间同步导致的内存溢出

　　由于信息有传输失败需要重发的可能性，在确认所有注册在 GMS（Group Membership Service）的节点都收到正确的信息前，发送的信息必须在内存中保留。而此 MIS 的服务端中有一个负责安全校验的全局过滤器，每当接收到请求时，均会更新一次最后操作时间，并且将这个时间同步到所有的节点中去，使得一个用户在一段时间内不能在多台机器上重复登录。在服务使用过程中，往往一个页面会产生数次乃至数十次的请求，因此这个过滤器导致集群各个节点之间网络交互非常频繁。当网络情况不能满足传输要求时，重发数据在内存中不断堆积，很快就产生了内存溢出。

　　这个问题，既有 JBossCache 的缺陷，也有 MIS 系统实现方式上的缺陷。JBoss-Cache 官方的邮件讨论组中讨论过很多次类似的内存溢出异常问题，据说后续版本也有了改进。而更重要的缺陷是，这一类被集群共享的数据要使用类似 JBossCache 这种非集中式的集群缓存来同步的话，可以允许读操作频繁，因为数据在本地内存有一份副本，读取的动作不会耗费多少资源，但不应当有过于频繁的写操作，会带来很大的网络同步的开销。

### 5.2.3 堆外内存导致的溢出错误

　　在此应用中导致溢出的关键是垃圾收集进行时，虚拟机虽然会对直接内存进行回收，但是直接内存却不能像新生代、老年代那样，发现空间不足了就主动通知收集器进行垃圾回收，它只能等待老年代满后 Full GC 出现后，“ 顺便 ” 帮它清理掉内存的废弃对象。否则就不得不一直等到抛出内存溢出异常时，先捕获到异常，再在 Catch 块里面通过System.gc() 命令来触发垃圾收集。但如果 Java 虚拟机再打开了 -XX：+DisableExplicitGC 开关，禁止了人工触发垃圾收集的话，那就只能眼睁睁看着堆中还有许多空闲内存，自己却不得不抛出内存溢出异常了。

　　而 CometD 1.1.1 框架，正好有大量的 NIO 操作需要使用到直接内存。

　　在处理小内存或者 32 位的应用问题时，除了Java 堆和方法区之外，我们注意到下面这些区域还会占用较多的内存，这里所有的内存总和受到操作系统进程最大内存的限制：

1. 直接内存：可通过 -XX：MaxDirectMemorySize 调整大小，内存不足时抛出 OutOfMemoryError 或者 OutOfMemoryError：Direct buffer memory。
2. 线程堆栈：可通过 -Xss 调整大小，内存不足时抛出 StackOverflowError（ 如果线程请求的栈深度大于虚拟机所允许的深度 ）或者OutOfMemoryError（ 如果 Java 虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存 ）。
3. Socket 缓存区：每个 Socket 连接都 Receive 和 Send 两个缓存区，分别占大约 37 KB 和 25 KB 内存，连接多的话这块内存占用也比较可观。如果无法分配，可能会抛出 IOException：Too many open files 异常。
4. JNI 代码：如果代码中使用了 JNI 调用本地库，那本地库使用的内存也不在堆中，而是占用 Java 虚拟机的本地方法栈和本地内存的。
5. 虚拟机和垃圾收集器：虚拟机、垃圾收集器的工作也是要消耗一定数量的内存的。

### 5.2.4 外部命令导致系统缓慢

　　通过 Solaris 10 的 dtrace 脚本可以查看当前情况下哪些系统调用花费了最多的处理器资源。

　　dtrace 运行后发现最消耗处理器资源的竟然是 “ fork ” 系统调用，原因是每个用户请求的处理都需要执行一个外部 Shell 脚本来获得系统的一些信息。执行这个 Shell 脚本是通过 Java 的Runtime.getRuntime().exec() 方法来调用的。这种调用方式可以达到执行 Shell 脚本的目的，但是它在 Java 虚拟机中是非常消耗资源的操作，即使外部命令本身能很快执行完毕，频繁调用时创建进程的开销也会非常可观。Java 虚拟机执行这个命令的过程是首先复制一个和当前虚拟机拥有一样环境变量的进程，再用这个新的进程去执行外部命令，最后再退出这个进程。如果频繁执行这个操作，系统的消耗必然会很大，而且不仅是处理器消耗，内存负担也很重。

　　建议去掉这个 Shell 脚本执行的语句，改为使用 Java 的 API 去获取这些信息后，系统很快恢复了正常。

### 5.2.5 服务器虚拟机进程崩溃

　　进程崩溃的原因是因为一个远端断开连接的异常，通过系统管理员了解到系统最近与一个 OA 门户做了集成，在 MIS 系统工作流的待办事项变化时，要通过 Web 服务通知 OA 门户系统，把待办事项的变化同步到 OA 门户之中。通过 SoapUI 测试了一下同步待办事项的几个 Web 服务，发现调用后竟然需要长达 3 分钟才能返回，并且返回结果都是超时导致的连接中断。

　　由于 MIS 系统的用户多，待办事项变化很快，为了不被 OA 系统速度拖累，使用了异步的方式调用 Web 服务，但由于两边服务速度的完全不对等，时间越长就累积了越多 Web 服务没有调用完成，导致在等待的线程和 Socket 连接越来越多，最终超过虚拟机的承受能力后导致虚拟机进程崩溃。通知 OA 门户方修复无法使用的集成接口，并将异步调用改为生产者 / 消费者模式的消息队列实现后，系统恢复正常。

### 5.2.6 不恰当数据结构导致内存占用过大

　　业务上需要每 10 分钟加载一个约 80 MB 的数据文件到内存进行数据分析，这些数据会在内存中形成超过 100 万个 HashMapEntry ，在这段时间里面 Minor GC 就会造成超过 500 毫秒的停顿，对于这种长度的停顿时间就接受不了了。

而平时 Minor GC 时间很短，原因是新生代的绝大部分对象都是可清除的，在 Minor GC 之后 Eden 和 Survivor 基本上处于完全空闲的状态。但是在分析数据文件期间，800 MB 的 Eden 空间很快被填满引发垃圾收集，但 Minor GC 之后，新生代中绝大部分对象依然是存活的。

　　如果不修改程序，仅从 GC 调优的角度去解决这个问题，可以考虑直接将 Survivor 空间去掉（加入参数 -XX：SurvivorRatio=65536、-XX：MaxTenuringThreshold=0 或者 -XX：+Always-Tenure），让新生代中存活的对象在第一次 Minor GC 后立即进入老年代，等到 Major GC 的时候再去清理它们。这种措施可以治标，但也有很大副作用；治本的方案必须要修改程序，因为这里产生问题的根本原因是用 HashMap 结构来存储数据文件空间效率太低了。

### 5.2.7 由 Windows 虚拟内存导致的长时间停顿

　　问题描述：真正执行垃圾收集动作的时间不是很长，但从准备开始收集，到真正开始收集之间所消耗的时间却占了绝大部分。除收集器日志之外，还观察到这个 GUI 程序内存变化的一个特点，当它最小化的时候，资源管理中显示的占用内存大幅度减小，但是虚拟内存则没有变化，因此怀疑程序在最小化时它的工作内存被自动交换到磁盘的页面文件之中了，这样发生垃圾收集时就有可能因为恢复页面文件的操作导致不正常的垃圾收集停顿。

　　在 Java 的 GUI 程序中要避免这种现象，可以加入参数 “ -Dsun.awt.keepWorkingSetOnMinimize=true ” 来解决。这个参数在许多 AWT 的程序上都有应用，例如 JDK（曾经）自带的 VisualVM，启动配置文件中就有这个参数，保证程序在恢复最小化时能够立即响应。

### 5.2.8 由安全点导致长时间停顿

　　user、sys、real 这三个时间的概念：

* user：进程执行用户态代码所耗费的处理器时间。
* sys：进程执行核心态代码所耗费的处理器时间。
* real：执行动作从开始到结束耗费的时钟时间。

　　前面两个是**处理器时间**，而最后一个是**时钟时间**，它们的**区别**是处理器时间代表的是线程占用处理器一个核心的耗时计数，而时钟时间就是现实世界中的时间计数。

　　如果是单核单线程的场景下，这两者可以认为是等价的，但如果是多核环境下，同一个时钟时间内有多少处理器核心正在工作，就会有多少倍的处理器时间被消耗和记录下来。

　　有什么因素可以阻止线程进入安全点？

　　安全点是以 “ 是否具有让程序长时间执行的特征 ” 为原则进行选定的，所以方法调用、循环跳转、异常跳转这些位置都可能会设置有安全点，但是 HotSpot 虚拟机为了避免安全点过多带来过重的负担，对循环还有一项优化措施，认为循环次数较少的话，执行时间应该也不会太长，所以使用 int 类型或范围更小的数据类型作为索引值的循环默认是不会被放置安全点的。这种循环被称为可数循环（Counted Loop），相对应地，使用 long 或者范围更大的数据类型作为索引值的循环就被称为不可数循环（Uncounted Loop），将会被放置安全点。

　　通常情况下这个优化措施是可行的，但循环执行的时间不单单是由其次数决定，如果循环体单次执行就特别慢，那即使是可数循环也可能会耗费很多的时间。

　　HotSpot 原本提供了-XX：+UseCountedLoopSafepoints 参数去强制在可数循环中也放置安全点，不过这个参数在 JDK 8 下有Bug，有导致虚拟机崩溃的风险，所以就不得不找到 RpcServer 线程里面的缓慢代码来进行修改。

## 5.3 实战：Eclipse 运行速度调优

### 5.3.1 调优前的程序运行状态

 　　Eclipse 启动的总耗时没有办法从监控工具中直接获得，因为 VisualVM 不可能知道 Eclipse 运行到什么阶段算是启动完成。

 　　虚拟机后台占用太多时间也直接导致 Eclipse 在启动后的使用过程中经常有卡顿的感觉，进行调优还是有较大价值的。

###  5.3.2 升级 JDK 版本的性能变化及兼容问题

 　　对 Eclipse 进行调优的第一步就是先对虚拟机的版本进行升级，希望能先从虚拟机版本身上得到一些 “ 免费的 ” 性能提升。

 　　使用 JDK 5 时之所以有永久代容量这个参数，是因为在 eclipse.ini 中存在 “ --launcher.XXMaxPermSize 256M ” 这项设置，当 launcher —— 也就是 Windows 下的可执行程序 eclipse.exe，检测到 Eclipse 是运行在 Sun 公司的虚拟机上的话，就会把参数值转化为 -XX：MaxPermSize 传递给虚拟机进程。因为世界三大商用虚拟机中只有 Sun 公司的虚拟机才有永久代的概念，也就是只有 JDK 8 以前的 HotSpot 虚拟机才需要设置这个参数，JRockit 虚拟机和 J9 虚拟机都是不需要设置的，所以这个参数才会有检测虚拟机后进行设置的过程。

### 5.3.3 编译时间和雷加载时间的优化

　　在 JDK 6 中启动完 Eclipse 所消耗的类加载时间比 JDK 5 长了接近一倍。

　　考虑到实际情况，Eclipse 使用者甚多，它的编译代码可以认为是安全可靠的，可以不需要在加载的时候再进行字节码验证，因此通过参数 -Xverify：none 禁止掉字节码验证过程也可作为一项优化措施。加入这个参数后，两个版本的JDK类加载速度都有所提高，此时 JDK 6 的类加载速度仍然比 JDK 5 要慢，但是两者的耗时已经接近了很多。

　　在取消字节码验证之后，JDK 5 的平均启动下降到了 13 秒，而在 JDK 6 的测试数据平均比 JDK 5 快了 1 秒左右，下降到平均 12 秒。

　　在类加载时间仍然落后的情况下，依然可以看到 JDK 6 在性能上确实比 JDK 5 略有优势，说明至少在 Eclipse 启动这个测试用例上，升级 JDK 版本确实能带来一些 “ 免费的 ” 性能提升。 

　　编译时间是指虚拟机的即时编译器（Just In Time Compiler）编译热点代码（Hot Spot Code）的耗时。

　　Java 语言为了实现跨平台的特性，Java 代码编译出来后形成 Class 文件中储存的是字节码（ Byte Code ），虚拟机通过解释方式执行字节码命令，比起 C/C++ 编译成本地二进制代码来说，速度要慢不少。为了解决程序解释执行的速度问题，JDK 1.2 以后，HotSpot 虚拟机内置了两个即时编译器，如果一段 Java 方法被调用次数到达一定程度，就会被判定为热代码交给即时编译器即时编译为本地代码，提高运行速度（这就是HotSpot虚拟机名字的来由）。

　　Java 的运行期编译的一大缺点就是它进行编译需要消耗机器的计算资源，影响程序正常的运行时间，这也就是 “ 编译时间 ” 。

　　HotSpot 虚拟机提供了一个参数 -Xint 来禁止编译器运作，强制虚拟机对字节码采用纯解释方式执行。加上这个参数之后虽然编译时间确实下降到零，但 Eclipse 启动的总时间却剧增到 27 秒，就是因为没有即时编译的支持，执行速度大幅下降了。现在这个参数最大的作用，除了某些场景调试上的需求外，似乎就剩下缅怀 JDK 1.2 之前 Java 语言那令人心酸心碎的运行速度了。

　　HotSpot 虚拟机还有另一个力度更强的即时编译器：当虚拟机运行在客户端模式的时候，使用的是一个代号为 C1 的轻量级编译器，另外还有一个代号为 C2 的相对重量级的服务端编译器能提供更多的优化措施。

 ### 5.3.4 调整内存设置控制垃圾收集频率 

　　新生代垃圾收集频繁发生，是由于虚拟机分配给新生代的空间太小导致。所以完全有必要使用 -Xmn 参数手工调整新生代的大小。

　　Eclipse 启动时 Full GC 大多数是由于老年代容量扩展而导致的，由永久代空间扩展而导致的也有一部分。为了避免这些扩展所带来的性能浪费，我们可以把 -Xms 和 -XX：PermSize 参数值设置为 -Xmx 和 -XX：MaxPermSize 参数值一样，这样就强制虚拟机在启动的时候就把老年代和永久代的容量固定下来，避免运行时自动扩展。

### 5.3.5 选择收集器降低延迟

　　在 Eclipse 中进行一个非常常用但又比较耗时的操作：代码编译。Eclipse 在进行代码编译时的运行数据，新生代垃圾收集的耗时也还好，停顿在使用中基本无法察觉到，而老年代每次垃圾收集停顿的时间会比较久，虽然较长时间才会出现一次，但这样的停顿已经是可以被人感知了，会影响到体验。而且整个编译过程中平均只使用了不到 30% 的处理器资源，垃圾收集的处理器使用率曲线更是几乎与坐标横轴紧贴在一起，这说明处理器资源还有很多可利用的余地。

　　在 eclipse.ini 中再加入这两个参数，-XX：+UseConc-MarkSweepGC 和 -XX：+UseParNewGC（ ParNew 是使用 CMS 收集器后的默认新生代收集器，写上仅是为了配置更加清晰），要求虚拟机在新生代和老年代分别使用 ParNew 和 CMS 收集器进行垃圾回收。

## 5.4 本章小节

　　Java 虚拟机的内存管理与垃圾收集是虚拟机结构体系中最重要的组成部分，对程序的性能和稳定有着非常大的影响。

