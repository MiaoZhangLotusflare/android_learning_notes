# 第 3 章 垃圾收集器与内存分配策略

## 3.1 概述


## 3.2 对象已死


## 3.3 垃圾收集算法



## 3.4 HotSpot 的算法细节实现



## 3.5 经典垃圾收集器



## 3.6 低延迟垃圾收集器



## 3.7 选择合适的垃圾收集器

### 3.7.1 Epsilon 收集器

 　　Epsilon收集器由RedHat公司在JEP 318中提出。Epsilon 被形容称一个无操作的收集器（A No-Op Garbage Collector）。

　　垃圾收集器除了垃圾收集这个本职工作之外，它还要负责:

1. 堆的管理与布局（ 是Java虚拟机能够正常运作的必要支持，是一个最小化功能的垃圾收集器也必须实现的内容 ）
2. 对象的分配
3. 与解释器的协作
4. 与编译器的协作
5. 与监控子系统协作等职责

　　从 JDK 10 开始，为了隔离垃圾收集器与 Java 虚拟机解释、编译、监控等子系统的关系，RedHat 提出了垃圾收集器的统一接口，即 JEP 304 提案，Epsilon 是这个接口的有效性验证和参考实现，同时也用于需要剥离垃圾收集器影响的性能测试和压力测试。

　　只要运行数分钟甚至数秒，只要 Java 虚拟机能正确分配内存，在堆耗尽之前就会退出，那显然运行负载极小、没有任何回收行为的 Epsilon 便是很恰当的选择。

 ### 3.7.2 收集器的权衡

　　收集器选择的因素影响：

 

三个因素

1. 应用程序的主要关注点是什么？
   * 如果是数据分析、科学计算类的任务，目标是能尽快算出结果，那吞吐量就是主要关注点；
   * 如果是 SLA 应用，那停顿时间直接影响服务质量，严重的甚至会导致事务超时，这样延迟就是主要关注点；
   * 而如果是客户端应用或者嵌入式应用，那垃圾收集的内存占用则是不可忽视的。

2. 运行应用的基础设施如何？
   * 譬如硬件规格，要涉及的系统架构是 x86-32/64、SPARC 还是 ARM / Aarch64 ；
   * 处理器的数量多少，分配内存的大小；
   * 选择的操作系统是 Linux、Solaris 还是 Windows 等。
3. 使用JDK的发行商是什么？
   * 版本号是多少？是 ZingJDK / Zulu、OracleJDK、Open-JDK、OpenJ9 抑或是其他公司的发行版？
   * 该JDK对应了《 Java虚拟机规范 》的哪个版本？

 　　假设某个直接面向用户提供服务的 **B / S 系统**准备选择垃圾收集器，一般来说**延迟时间**是这类应用的主要关注点，那么：

* 如果你**有充足的预算但没有太多调优经验**，那么一套带商业技术支持的专有硬件或者软件解决方案是不错的选择，Azul 公司以前主推的Vega 系统和现在主推的 Zing VM 是这方面的代表，这样你就可以使用传说中的 **C4** 收集器了。

* 如果你虽然**没有足够预算去使用商业解决方案，但能够掌控软硬件型号，使用较新的版本，同时又特别注重延迟**，那 **ZGC** 很值得尝试。

* 如果你对还处于实验状态的**收集器的稳定性有所顾虑**，或者**应用必须运行在Win-dows操作系统**下，那 ZGC 就无缘了，试试 **Shenandoah** 吧。

* 如果你接手的是**遗留系统，软硬件基础设施和JDK版本都比较落后**，那就根据内存规模衡量一下，对于大概 **4GB 到 6GB 以下的堆内存**，**CMS** 一般能处理得比较好，而对于**更大的堆内存**，可重点考察一下 **G1** 。

 ### 3.7.3 虚拟机及垃圾收集器日志

　　垃圾收集器日志是一系列人为设定的规则，所以每个收集器的日志格式都可能不一样。

　　在 JDK 9 以前，HotSpot 并没有提供统一的日志处理框架，虚拟机各个功能模块的日志开关分布在不同的参数上，日志级别、循环日志大小、输出格式、重定向等设置在不同功能上都要单独解决。直到 JDK 9，这种混乱不堪的局面才终于消失，HotSpot 所有功能的日志都收归到了 “ -Xlog ” 参数上，这个参数的能力也相应被极大拓展了：

 ```java
-Xlog[:[selector][:[output][:[decorators][:output-options]]]]
 ```

　　命令行中最关键的参数是选择器（ Selector ），它由标签（ Tag ）和日志级别（ Level ）共同组成。标签可理解为虚拟机中某个功能模块的名字，它告诉日志框架用户希望得到虚拟机哪些功能的日志输出。垃圾收集器的标签名称为 “ gc ”，由此可见，垃圾收集器日志只是 HotSpot 众多功能日志的其中一项，全部支持的功能模块标签名如下所示：

```java
add，age，alloc，annotation，aot，arguments，attach，barrier，biasedlocking，blocks，bot，breakpoint，bytecode，census，class，classhisto，cleanup，compaction，comparator，constraints，constantpool，coops，cpu，cset，data，defaultmethods，dump，ergo，event，exceptions，exit，fingerprint，freelist，gc，hashtables，heap，humongous，ihop，iklass，init，itables，jfr，jni，jvmti，liveness，load，loader，logging，mark，marking，metadata，metaspace，method，mmu，modules，monitorinflation，monitormismatch，nmethod，normalize，objecttagging，obsolete，oopmap，os，pagesize，parser，patch，path，phases，plab，preorder，promotion，protectiondomain，purge，redefine，ref，refine，region，remset，resolve，safepoint，scavenge，scrub，setting，stackmap，stacktrace，stackwalk，start，startuptime，state，stats，stringdedup，stringtable，subclass，survivor，sweep，system，task，thread，time，timer，tlab，unload，update，verification，verify，vmoperation，vtables，workgang
```

　　日志级别从低到高，共有 Trace，Debug，Info，Warning，Error，Off 六种级别，日志级别决定了输出信息的详细程度，默认级别为 Info，HotSpot 的日志规则与 Log4j、SLF4j 这类 Java 日志框架大体上是一致的。另外，还可以使用修饰器（Decorator）来要求每行日志输出都附加上额外的内容，支持附加在日志行上的信息包括：

* time：当前日期和时间。
* uptime：虚拟机启动到现在经过的时间，以秒为单位。
* timemillis：当前时间的毫秒数，相当于System.currentTimeMillis()的输出。
* uptimemillis：虚拟机启动到现在经过的毫秒数。
* timenanos：当前时间的纳秒数，相当于System.nanoTime()的输出。
* uptimenanos：虚拟机启动到现在经过的纳秒数。
* pid：进程ID。
* tid：线程ID。
* level：日志级别。
* tags：日志输出的标签集。

　　如果不指定，默认值是uptime、level、tags这三个，此时日志输出类似于以下形式：

```java
[3.080s][info][gc,cpu] GC(5) User=0.03s Sys=0.00s Real=0.01s
```

　　展示在 JDK 9 统一日志框架前、后是如何获得垃圾收集器过程的相关信息例子：

1. 查看GC基本信息，在JDK 9之前使用-XX：+PrintGC，JDK 9后使用-Xlog：gc：

```java
bash-3.2$ java -Xlog:gc GCTest
[0.222s][info][gc] Using G1
[2.825s][info][gc] GC(0) Pause Young (G1 Evacuation Pause) 26M->5M(256M) 355.623ms
[3.096s][info][gc] GC(1) Pause Young (G1 Evacuation Pause) 14M->7M(256M) 50.030ms
[3.385s][info][gc] GC(2) Pause Young (G1 Evacuation Pause) 17M->10M(256M) 40.576ms
```

2. 查看GC详细信息，在 JDK 9 之前使用 -XX：+PrintGCDetails ，在 JDK 9 之后使用 -X-log：gc *，用通配符 * 将 GC 标签下所有细分过程都打印出来，如果把日志级别调整到 Debug 或者 Trace （ 基于版面篇幅考虑，例子中并没有 ），还将获得更多细节信息：

```java
bash-3.2$ java -Xlog:gc* GCTest
[0.233s][info][gc,heap] Heap region size: 1M
[0.383s][info][gc ] Using G1
[0.383s][info][gc,heap,coops] Heap address: 0xfffffffe50400000, size: 4064 MB, Compressed Oops mode: Non-zero based:
0xfffffffe50000000, Oop shift amount: 3
[3.064s][info][gc,start ] GC(0) Pause Young (G1 Evacuation Pause)
gc,task ] GC(0) Using 23 workers of 23 for evacuation
[3.420s][info][gc,phases ] GC(0) Pre Evacuate Collection Set: 0.2ms
[3.421s][info][gc,phases ] GC(0) Evacuate Collection Set: 348.0ms
gc,phases ] GC(0) Post Evacuate Collection Set: 6.2ms
[3.421s][info][gc,phases ] GC(0) Other: 2.8ms
gc,heap ] GC(0) Eden regions: 24->0(9)
[3.421s][info][gc,heap ] GC(0) Survivor regions: 0->3(3)
[3.421s][info][gc,heap ] GC(0) Old regions: 0->2
[3.421s][info][gc,heap ] GC(0) Humongous regions: 2->1
[3.421s][info][gc,metaspace ] GC(0) Metaspace: 4719K->4719K(1056768K)
[3.421s][info][gc ] GC(0) Pause Young (G1 Evacuation Pause) 26M->5M(256M) 357.743ms
[3.422s][info][gc,cpu ] GC(0) User=0.70s Sys=5.13s Real=0.36s
[3.648s][info][gc,start ] GC(1) Pause Young (G1 Evacuation Pause)
[3.648s][info][gc,task ] GC(1) Using 23 workers of 23 for evacuation
[3.699s][info][gc,phases ] GC(1) Pre Evacuate Collection Set: 0.3ms
gc,phases ] GC(1) Evacuate Collection Set: 45.6ms
gc,phases ] GC(1) Post Evacuate Collection Set: 3.4ms
gc,phases ] GC(1) Other: 1.7ms
gc,heap ] GC(1) Eden regions: 9->0(10)
[3.699s][info][gc,heap ] GC(1) Survivor regions: 3->2(2)
[3.699s][info][gc,heap ] GC(1) Old regions: 2->5
[3.700s][info][gc,heap ] GC(1) Humongous regions: 1->1
[3.700s][info][gc,metaspace ] GC(1) Metaspace: 4726K->4726K(1056768K)
[3.700s][info][gc ] GC(1) Pause Young (G1 Evacuation Pause) 14M->7M(256M) 51.872ms
[3.700s][info][gc,cpu ] GC(1) User=0.56s Sys=0.46s Real=0.05s
```

3. 查看 GC 前后的堆、方法区可用容量变化，在JDK 9 之前使用 -XX：+PrintHeapAtGC ，JDK9 之后使用 -Xlog：gc+heap=debug：

 ```java
bash-3.2$ java -Xlog:gc+heap=debug GCTest
[0.113s][info][gc,heap] Heap region size: 1M
[0.113s][debug][gc,heap] Minimum heap 8388608 Initial heap 268435456 Maximum heap 4261412864
[2.529s][debug][gc,heap] GC(0) Heap before GC invocations=0 (full 0):
[2.529s][debug][gc,heap] GC(0) garbage-first heap total 262144K, used 26624K [0xfffffffe50400000, 0xfffffffe50500800,
0xffffffff4e400000)
[2.529s][debug][gc,heap] GC(0) region size 1024K, 24 young (24576K), 0 survivors (0K)
[2.530s][debug][gc,heap] GC(0) Metaspace used 4719K, capacity 4844K, committed 5120K, reserved 1056768K
[2.530s][debug][gc,heap] GC(0) class space used 413K, capacity 464K, committed 512K, reserved 1048576K
[2.892s][info ][gc,heap] GC(0) Eden regions: 24->0(9)
[2.892s][info ][gc,heap] GC(0) Survivor regions: 0->3(3)
[2.892s][info ][gc,heap] GC(0) Old regions: 0->2
[2.892s][info ][gc,heap] GC(0) Humongous regions: 2->1
[2.893s][debug][gc,heap] GC(0) Heap after GC invocations=1 (full 0):
[2.893s][debug][gc,heap] GC(0) garbage-first heap total 262144K, used 5850K [0xfffffffe50400000, 0xfffffffe50500800, 0xffffffff4e400000)
[2.893s][debug][gc,heap] GC(0) region size 1024K, 3 young (3072K), 3 survivors (3072K)
[2.893s][debug][gc,heap] GC(0) Metaspace used 4719K, capacity 4844K, committed 5120K, reserved 1056768K
[2.893s][debug][gc,heap] GC(0) class space used 413K, capacity 464K, committed 512K, reserved 1048576K
 ```

4. 查看 GC 过程中用户线程并发时间以及停顿的时间，在 JDK 9 之前使用 -XX：+Print-GCApplicationConcurrentTime 以及 -XX：+PrintGCApplicationStoppedTime ，JDK 9 之后使用 -Xlog：safepoint ：

 ```java
bash-3.2$ java -Xlog:safepoint GCTest
[1.376s][info][safepoint] Application time: 0.3091519 seconds
[1.377s][info][safepoint] Total time for which application threads were stopped: 0.0004600 seconds, Stopping threads took:
0.0002648 seconds
[2.386s][info][safepoint] Application time: 1.0091637 seconds
[2.387s][info][safepoint] Total time for which application threads were stopped: 0.0005217 seconds, Stopping threads took:
0.0002297 seconds
 ```

5. 查看收集器 Ergonomics 机制（ 自动设置堆空间各分代区域大小、收集目标等内容，从Parallel 收集器开始支持 ）自动调节的相关信息。在 JDK 9 之前使用 -XX：+PrintAdaptive-SizePolicy ，JDK 9 之后使用 -Xlog：gc+ergo*=trace：

 ```java
bash-3.2$ java -Xlog:gc+ergo*=trace GCTest [0.122s][debug][gc,ergo,refine] Initial Refinement Zones: green: 23, yellow:
69, red: 115, min yellow size: 46
[0.142s][debug][gc,ergo,heap ] Expand the heap. requested expansion amount:268435456B expansion amount:268435456B
[2.475s][trace][gc,ergo,cset ] GC(0) Start choosing CSet. pending cards: 0 predicted base time: 10.00ms remaining time:
190.00ms target pause time: 200.00ms
[2.476s][trace][gc,ergo,cset ] GC(0) Add young regions to CSet. eden: 24 regions, survivors: 0 regions, predicted young
region time: 367.19ms, target pause time: 200.00ms
[2.476s][debug][gc,ergo,cset ] GC(0) Finish choosing CSet. old: 0 regions, predicted old region time: 0.00ms, time
remaining: 0.00
[2.826s][debug][gc,ergo ] GC(0) Running G1 Clear Card Table Task using 1 workers for 1 units of work for 24 regions.
[2.827s][debug][gc,ergo ] GC(0) Running G1 Free Collection Set using 1 workers for collection set length 24
[2.828s][trace][gc,ergo,refine] GC(0) Updating Refinement Zones: update_rs time: 0.004ms, update_rs buffers: 0, update_rs
goal time: 19.999ms
 ```

6. 查看熬过收集后剩余对象的年龄分布信息，在 JDK 9 前使用 -XX：+PrintTenuring-Distribution ，JDK 9 之后使用 -Xlog：gc+age=trace： 

 ```java
bash-3.2$ java -Xlog:gc+age=trace GCTest
[2.406s][debug][gc,age] GC(0) Desired survivor size 1572864 bytes, new threshold 15 (max threshold 15)
[2.745s][trace][gc,age] GC(0) Age table with threshold 15 (max threshold 15)
[2.745s][trace][gc,age] GC(0) - age 1: 3100640 bytes, 3100640 total
[4.700s][debug][gc,age] GC(5) Desired survivor size 2097152 bytes, new threshold 15 (max threshold 15)
[4.810s][trace][gc,age] GC(5) Age table with threshold 15 (max threshold 15)
[4.810s][trace][gc,age] GC(5) - age 1: 2658280 bytes, 2658280 total
[4.810s][trace][gc,age] GC(5) - age 2: 1527360 bytes, 4185640 total
 ```

　　下表给出了全部在  JDK 9 中被废弃的日志相关参数及它们在 JDK 9 后使用 -Xlog 的代替配置形式。

![](image/JDK9前后日志参数变化.jpeg)

下表中整理了这些参数，供实践时参考：

![](image/垃圾收集相关的常用参数.jpeg)

![](image/垃圾收集相关的常用参数续.jpeg)

## 3.8 实战：内存分配与回收策略

 　　Java 技术体系的自动内存管理，最根本的目标是自动化地解决两个问题：自动给对象分配内存以及自动回收分配给对象的内存。

 　　对象的内存分配，从概念上讲，应该都是在堆上分配（ 而实际上也有可能经过即时编译后被拆散为标量类型并间接地在栈上分配 ）。

 　　在经典分代的设计下，新生对象通常会分配在新生代中，少数情况下（ 例如对象大小超过一定阈值）也可能会直接分配在老年代。

 　　对象分配的规则并不是固定的，《 Java 虚拟机规范 》并未规定新对象的创建和存储细节，这取决于虚拟机当前使用的是哪一种垃圾收集器，以及虚拟机中与内存相关的参数的设定。

 ### 3.8.1 对象优先在 Eden 分配

 　　大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。

 　　HotSpot 虚拟机提供了**-XX：+PrintGCDetails** 这个收集器日志参数，告诉**虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况**。

 ### 3.8.2 大对象直接进入老年代

 　　大对象就是指需要大量连续内存空间的 Java 对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组。

  　　在 Java 虚拟机中要避免大对象的原因是，在分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们，而当复制对象时，大对象就意味着高额的内存复制开销。

 　　HotSpot 虚拟机提供了**-XX：PretenureSizeThreshold** 参数，**指定大于该设置值的对象直接在老年代分配**，这样做的**目的**就是避免在 Eden 区及两个 Survivor 区之间来回复制，产生大量的内存复制操作。

 　　-XX：PretenureSizeThreshold 参数只对 Serial 和 ParNew 两款新生代收集器有效，HotSpot 的其他新生代收集器，如 Parallel  Scavenge 并不支持这个参数。如果必须使用此参数进行调优，可考虑 ParNew 加 CMS 的收集器组合。

 ### 3.8.3 长期存活的对象将进入老年代

 　　HotSpot 虚拟机中多数收集器都采用了分代收集来管理堆内存，那内存回收时就必须能决策哪些存活对象应当放在新生代，哪些存活对象放在老年代中。为做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中。

 　　对象通常在 Eden 区里诞生，如果经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，该对象会被移动到 Survivor 空间中，并且将其对象年龄设为 1 岁。

 　　对象在 Survivor 区中每熬过一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度（ 默认为 15 ），就会被晋升到老年代中。

 　　对象晋升老年代的年龄阈值，可以通过参数 -XX：MaxTenuringThreshold 设置。

### 3.8.4 动态对象年龄判定

 　　为了能更好地适应不同程序的内存状况，HotSpot 虚拟机对象晋升到老年代的两种情况：

1. 对象的年龄达到 -XX：MaxTenuringThreshold  ，对象晋升到老年代。
2. 如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。

### 3.8.5 空间分配担保

 　　在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 -XX：HandlePromotionFailure 参数的设置值是否允许担保失败（ Handle Promotion Failure ）；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 -XX：HandlePromotionFailure 设置不允许冒险，那这时就要改为进行一次 Full GC。

 　　冒险指的是什么风险：新生代使用复制收集算法，但为了内存利用率，只使用其中一个 Survivor空间来作为轮换备份，因此当出现大量对象在 Minor GC 后仍然存活的情况 —— 最极端的情况就是内存回收后新生代中所有对象都存活，需要老年代进行分配担保，把 Survivor 无法容纳的对象直接送入老年代，这与生活中贷款担保类似。老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，但一共有多少对象会在这次回收中活下来在实际完成内存回收之前是无法明确知道的，所以只能取之前每一次回收晋升到老年代对象容量的平均大小作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。

 　　取历史平均值来比较其实仍然是一种赌概率的解决办法，也就是说假如某次Minor GC存活后的对象突增，远远高于历史平均值的话，依然会导致担保失败。如果出现了担保失败，那就只好老老实实地重新发起一次Full GC，这样停顿时间就很长了。虽然担保失败时绕的圈子是最大的，但通常情况下都还是会将 -XX：HandlePromotionFailure 开关打开，避免Full GC过于频繁。

 　　JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。

## 3.9 本章小结

 　　本章介绍了垃圾收集的算法、若干款 HotSpot 虚拟机中提供的垃圾收集器的特点以及运作原理。通过代码实例验证了Java虚拟机中自动内存分配及回收的主要规则。

 　　垃圾收集器在许多场景中都是影响系统停顿时间和吞吐能力的重要因素之一，虚拟机之所以提供多种不同的收集器以及大量的调节参数，就是因为只有根据实际应用需求、实现方式选择最优的收集方式才能获取最好的性能。没有固定收集器、参数组合，没有最优的调优方法，虚拟机也就没有什么必然的内存回收行为。





