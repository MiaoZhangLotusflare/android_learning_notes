# 第 1 章 Java 多线程技能

## 本章主要内容
	线程的启动
	如何使线程暂停
	如何使线程停止
	线程的优先级
	线程安全相关的问题

## 1.1 进程和多线程的概念及线程的优点
　　进程是操作系统结构的基础；是一次程序的执行；是一个程序及其数据在处理机上顺序执行时所发生的活动；是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。进程是操作系统管理的基本运行单元。

　　那什么是线程呢？线程可以理解成是在进程中独立运行的子任务。

　　使用多线程技术后，可以在同一时间内运行更多不同种类的任务。

## 1.2 使用多线程
　　一个进程正在运行时至少会有 1 个线程在运行。

#### 1.2.1 继承 Thread 类
　　实现多线程编程的方式主要有两种：一种是继承 Thread 类，另一种是实现 Runnable 接口。

　　Thread 类实现了 Runnable 接口，它们之间具有多态关系。

　　线程是一个子任务，CPU 以不确定的方式，或者说是以随机的时间来调用线程中的 run 方法。

　　Thread.java 类中的 start() 方法通知“线程规划器”此线程已经准备就绪，等待调用线程对象的 run() 方法。这个过程其实就是让系统安排一个时间来调用 Thread 中的 run() 方法，也就是使线程得到运行，启动线程，具有异步执行的效果。如果调用代码 thread.run() 就不是异步执行了，而是同步，那么此线程对象并不交给“线程规划器”来进行处理，而是由 main 主线程来调用 run() 方法，也就是必须等 run() 方法中的代码执行完后才可以执行后面的代码。

　　执行 start() 方法的顺序不代表线程启动的顺序。

#### 1.2.2 实现 Runnable 接口
　　使用继承 Thread 类的方式来开发多线程应用程序在设计上是有局限性的，因为 Java 是单根继承，不支持多继承，所以为了改变这种限制，可以使用实现 Runnable 接口的方式来实现多线程技术。 Thread.java 类也实现了 Runnbale 接口。


#### 1.2.3 实例变量与线程安全
　　自定义线程类中的实例变量针对其他线程可以有共享与不共享之分。

　　每个线程都有各自的变量，自己改变自己变量的值，这种情况就是变量不共享。

　　共享数据的情况就是多个线程可以访问同一个变量。

　　非线程安全主要是指多个线程对同一个对象中的同一个实例变量进行操作时会出现值被更改、值不同步的情况，进而影响程序的执行流程。

　　可以使用 synchronized 关键字解决非线程安全问题。

#### 1.2.4 留意 i-- 与 System.out.println() 的异常
```
	System.out.println("i="+(i--)+" threadName="+Thread.currentThread().getName());
```
　　虽然 println() 方法在内部是同步的，但是 i-- 的操作却是在进入 println() 之前发生的，所以有发生非线程安全问题的概率。所以，为了防止发生非线程安全问题，还是应继续使用同步方法。

## 1.3 currentThread() 方法
　　currentThread() 方法可返回代码段正在被哪个线程调用的信息。

## 1.4 isAlive() 方法
　　方法 isAlive() 的功能是判断当前的线程是否处于活动状态。什么是活动状态呢？活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备开始运行的状态，就认为线程是“存活”的。

## 1.5 sleep() 方法
　　方法 sleep() 的作用是在指定的毫秒数内让当前“正在执行的线程”休眠（暂停执行）。这个“正在执行的线程”是指 this.currentThread() 返回的线程。

## 1.6 getId() 方法
　　getId() 方法的作用是取得线程的唯一标识。

## 1.7 停止线程
　　


#### 1.7.1 停止不了的线程
　　

#### 1.7.2 判断线程是否是停止状态
　　

#### 1.7.3 能停止的线程---异常法
　　

#### 1.7.4 在沉睡中停止
　　

#### 1.7.5 能停止的线程---暴力停止
　　

#### 1.7.6 方法 stop() 与 java.lang.ThreadDeath 异常
　　

#### 1.7.7 释放锁的不良后果
　　

#### 1.7.8 使用 return 停止线程
　　


## 1.8 暂停线程
　　

#### 1.8.1 suspend 与 resume 方法的使用
　　

#### 1.8.2 suspend 与 resume 方法的缺点---独占
　　

#### 1.8.3 suspend 与 resume 方法的缺点---不同步
　　


## 1.9 yield 方法
　　

## 1.10 线程的优先级
　　


#### 1.10.1 线程优先级的继承特性
　　

#### 1.10.2 优先级具有规则性
　　

#### 1.10.3 优先级具有随机性
　　


#### 1.10.4 看谁运行得快
　　


## 1.11 守护线程
　　

## 1.12 本章小结
　　



