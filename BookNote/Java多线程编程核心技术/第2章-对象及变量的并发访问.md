# 第 2 章 对象及变量的并发访问

## 本章主要内容
	synchronized 对象监视器为 Object 时的使用。
	synchronized 对象监视器为 Class 时的使用。
	非线程安全是如何出现的。
	关键字 volatile 的主要作用。
	关键字 volation 与 synchronized 的区别及使用情况。

## 2.1 synchronized 同步方法
　　"非线程安全"其实会在多个线程对同一个对象中的实例变量进行并发访问时发生，产生的后果就是“脏读”，也就是取到的数据其实是被更改过的。而“线程安全”就是以获得的实例变量的值是经过同步处理的，不会出现脏读的现象。

#### 2.1.1 方法内的变量为线程安全
　　“非线程安全”问题存在于“实例变量”中，如果是方法内部的私有变量，则不存在“非线程安全”问题，所得结果也就是“线程安全”的了。

　　方法中的变量不存在非线程安全问题，永远都是线程安全的。这是方法内部的变量是私有的特性造成的。

#### 2.1.2 实例变量非线程安全
　　如果多个线程共同访问 1 个对象中的实例变量，则有可能出现“非线程安全”问题。

　　用线程访问的对象中如果有多个实例变量，则运行的结果有可能出现交叉的情况。如果对象仅有 1 个实例变量，则有可能出现覆盖的情况。

　　在两个线程访问同一个对象中的同步方法时一定是线程安全的。

#### 2.1.3 多个对象多个锁
　　两个线程分别访问同一个类的两个不同实例的相同名称的同步方法，效果却是以异步的方式运行的。

　　如果多个线程访问多个对象，则 JVM 会创建多个锁。

　　同步的单词为 synchronized，异步的单词是 asynchronized.


#### 2.1.4 synchronized 方法与锁对象
　　调用用关键字 synchronized 声明的方法一定是排队运行的。另外需要牢牢记住“共享”这两个字，只有共享资源的读写访问才需要同步化，如果不是共享资源，那么根本就没有同步的必要。

　　A 线程先持有 object 对象的 Lock 锁，B 线程可以以异步的方式调用 object 对象中的非 synchronized 类型的方法。

　　A 线程先持有 object 对象的 Lock 锁，B 线程如果在这时调用 object 对象中的 synchronized 类型的方法则需要等待，也就是同步。

#### 2.1.5 脏读
　　

#### 2.1.6 synchronized 锁重入
　　


#### 2.1.7 出现异常，锁自动释放
　　

#### 2.1.8 同步不具有继承性
　　


## 2.2 synchronized 同步语句块
　　

#### 2.2.1 synchronized 方法的弊端
　　


#### 2.2.2 synchronized 同步代码块的使用
　　

#### 2.2.3 用同步代码块解决同步方法的弊端
　　

#### 2.2.4 一半异步，一半同步
　　

#### 2.2.5 synchronized 代码块间的同步性
　　

#### 2.2.6 验证同步 synchronized(this) 代码块是锁定当前对象的
　　


#### 2.2.7 将任意对象作为对象监视器
　　


#### 2.2.8 细化验证 3 个结论
　　

#### 2.2.9 静态同步 synchronized 方法与 synchronized(class) 代码块
　　


#### 2.2.10 数据类型 String 的常量池特性
　　

#### 2.2.11 同步 synchronized 方法无限等待与解决
　　

#### 2.2.12 多线程的死锁
　　

#### 2.2.13 内置类与静态内置类
　　

#### 2.2.14 内置类与同步：实验 1
　　

#### 2.2.15 内置类与同步：实验 2
　　


#### 2.2.16 锁对象的改变
　　


## 2.3 volatile 关键字
　　

#### 2.3.1 关键字 volatile 与死循环
　　


#### 2.3.2 解决同步死循环
　　


#### 2.3.3 解决异步死循环
　　


#### 2.3.4 volatile 非原子的特性
　　


#### 2.3.5 使用原子类进行 i++ 操作
　　


#### 2.3.6 原子类也并不完全安全
　　


#### 2.3.7 synchronized 代码块有 volatitle 同步的功能
　　


## 2.4 本章总结
　　




