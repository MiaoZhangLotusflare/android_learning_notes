# 第 2 章 对象及变量的并发访问

## 本章主要内容
	synchronized 对象监视器为 Object 时的使用。
	synchronized 对象监视器为 Class 时的使用。
	非线程安全是如何出现的。
	关键字 volatile 的主要作用。
	关键字 volation 与 synchronized 的区别及使用情况。

## 2.1 synchronized 同步方法
　　"费县陈安全"其实会在多个线程对同一个对象中的实例变量进行并发访问时发生，产生的后果就是“脏读”，也就是取到的数据其实是被更改过的。而“线程安全”就是以获得的实例变量的值是经过同步处理的，不会出现脏读的现象。


#### 2.1.1 方法内的变量为线程安全
　　


#### 2.1.2 实例变量非线程安全
　　

#### 2.1.3 多个对象多个锁
　　


#### 2.1.4 synchronized 方法与锁对象
　　


#### 2.1.5 脏读
　　

#### 2.1.6 synchronized 锁重入
　　


#### 2.1.7 出现异常，锁自动释放
　　

#### 2.1.8 同步不具有继承性
　　


## 2.2 synchronized 同步语句块
　　

#### 2.2.1 synchronized 方法的弊端
　　


#### 2.2.2 synchronized 同步代码块的使用
　　

#### 2.2.3 用同步代码块解决同步方法的弊端
　　

#### 2.2.4 一半异步，一半同步
　　

#### 2.2.5 synchronized 代码块间的同步性
　　

#### 2.2.6 验证同步 synchronized(this) 代码块是锁定当前对象的
　　


#### 2.2.7 将任意对象作为对象监视器
　　


#### 2.2.8 细化验证 3 个结论
　　

#### 2.2.9 静态同步 synchronized 方法与 synchronized(class) 代码块
　　


#### 2.2.10 数据类型 String 的常量池特性
　　

#### 2.2.11 同步 synchronized 方法无限等待与解决
　　

#### 2.2.12 多线程的死锁
　　

#### 2.2.13 内置类与静态内置类
　　

#### 2.2.14 内置类与同步：实验 1
　　

#### 2.2.15 内置类与同步：实验 2
　　


#### 2.2.16 锁对象的改变
　　


## 2.3 volatile 关键字
　　

#### 2.3.1 关键字 volatile 与死循环
　　


#### 2.3.2 解决同步死循环
　　


#### 2.3.3 解决异步死循环
　　


#### 2.3.4 volatile 非原子的特性
　　


#### 2.3.5 使用原子类进行 i++ 操作
　　


#### 2.3.6 原子类也并不完全安全
　　


#### 2.3.7 synchronized 代码块有 volatitle 同步的功能
　　


## 2.4 本章总结
　　




