# 第 2 章 对象及变量的并发访问

## 本章主要内容
	synchronized 对象监视器为 Object 时的使用。
	synchronized 对象监视器为 Class 时的使用。
	非线程安全是如何出现的。
	关键字 volatile 的主要作用。
	关键字 volation 与 synchronized 的区别及使用情况。

## 2.1 synchronized 同步方法
　　"非线程安全"其实会在多个线程对同一个对象中的实例变量进行并发访问时发生，产生的后果就是“脏读”，也就是取到的数据其实是被更改过的。而“线程安全”就是以获得的实例变量的值是经过同步处理的，不会出现脏读的现象。

#### 2.1.1 方法内的变量为线程安全
　　“非线程安全”问题存在于“实例变量”中，如果是方法内部的私有变量，则不存在“非线程安全”问题，所得结果也就是“线程安全”的了。

　　方法中的变量不存在非线程安全问题，永远都是线程安全的。这是方法内部的变量是私有的特性造成的。

#### 2.1.2 实例变量非线程安全
　　如果多个线程共同访问 1 个对象中的实例变量，则有可能出现“非线程安全”问题。

　　用线程访问的对象中如果有多个实例变量，则运行的结果有可能出现交叉的情况。如果对象仅有 1 个实例变量，则有可能出现覆盖的情况。

　　在两个线程访问同一个对象中的同步方法时一定是线程安全的。

#### 2.1.3 多个对象多个锁
　　两个线程分别访问同一个类的两个不同实例的相同名称的同步方法，效果却是以异步的方式运行的。

　　如果多个线程访问多个对象，则 JVM 会创建多个锁。

　　同步的单词为 synchronized，异步的单词是 asynchronized.


#### 2.1.4 synchronized 方法与锁对象
　　调用用关键字 synchronized 声明的方法一定是排队运行的。另外需要牢牢记住“共享”这两个字，只有共享资源的读写访问才需要同步化，如果不是共享资源，那么根本就没有同步的必要。

　　A 线程先持有 object 对象的 Lock 锁，B 线程可以以异步的方式调用 object 对象中的非 synchronized 类型的方法。

　　A 线程先持有 object 对象的 Lock 锁，B 线程如果在这时调用 object 对象中的 synchronized 类型的方法则需要等待，也就是同步。

#### 2.1.5 脏读
　　虽然在赋值时进行了同步，但在取值时有可能出现一些意想不到的意外，这种情况就是脏读（dirtyRead）。发生脏读的情况是在读取实例变量时，此值已经被其他线程更改过了。

　　脏读是通过 synchronized 关键字解决的。

　　当 A 线程调用 anyObject 对象加入 synchronized 关键字的 X 方法时，A 线程就获得了 X 方法锁，更准确地讲，是获得了对象的锁，所以其他线程必须等 A 线程执行完毕才可以调用 X 方法，但 B 线程可以随意调用其他的非 synchronized 同步方法。

　　当 A 线程调用 anyObject 对象加入 synchronized 关键字的 X 方法时，A 线程就获得了 X 方法所在对象的锁，所以其他线程必须等 A 线程执行完毕才可以调用 X 方法，而 B 线程如果调用声明了 synchronized 关键字的非 X 方法时，必须等 A 线程将 X 方法执行完，也就是释放对象锁后才可以调用。

　　脏读一定会出现操作实例变量的情况下，这就是不同线程“争抢”实例变量的结果。

#### 2.1.6 synchronized 锁重入
　　关键字 synchronized 拥有锁重入的功能，也就是在使用 synchronized 时，当一个线程得到一个对象锁后，再次请求此对象锁时是可以再次得到该对象的锁的。这也证明在一个 synchronized 方法/块的内部调用本类的其他 synchronized 方法/块时，是永远可以得到锁的。

　　“可重入锁”的概念是：自己可以造次获取自己的内部锁。

　　可重入锁也支持在父子类继承的环境中。

　　当存在父子类继承关系时，子类是完全可以通过“可重入锁”调用父类的同步方法的。

#### 2.1.7 出现异常，锁自动释放
　　当一个线程执行的代码出现异常时，其所持有的锁会自动释放。

#### 2.1.8 同步不具有继承性
　　同步不可以继承。

## 2.2 synchronized 同步语句块
　　用关键字 synchronized 声明方法在某些情况下是有弊端的，比如 A 线程调用同步方法执行一个长时间的任务，那么 B 线程则必须等待比较长时间，这样的抢矿下可以使用 synchronized 同步语句块来解决。

#### 2.2.1 synchronized 方法的弊端
　　弊端就是 A 线程调用同步方法执行一个长时间的任务，那么 B 线程则必须等待比较长时间。解决这样的问题可以使用 synchronized 同步块。

#### 2.2.2 synchronized 同步代码块的使用
　　当两个并发线程访问同一个对象 object 中的 synchronized(this) 同步代码块中，一段时间内只能有一个线程被执行，另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。

#### 2.2.3 用同步代码块解决同步方法的弊端
　　当一个线程访问 object 的一个 synchronized 同步代码块时，另一个线程仍然可以访问该 object 对象中的非 synchronized(this) 同步代码块。

#### 2.2.4 一半异步，一半同步
　　不在 synchronized 块中就是异步执行，在 synchronized 块中就是同步执行。

#### 2.2.5 synchronized 代码块间的同步性
　　在使用同步 synchronized(this) 代码块时需要注意的是，当一个线程访问 object 的一个 synchronized(this) 同步代码块时，其他线程对同一个 object 中所有其他 synchronized(this) 同步代码块的访问将被阻塞，这说明 synchronized 使用的 “对象监视器” 是一个。

#### 2.2.6 验证同步 synchronized(this) 代码块是锁定当前对象的
　　和 synchronized 方法一样，synchronized(this) 代码块也是锁定当前对象的。

#### 2.2.7 将任意对象作为对象监视器
　　


#### 2.2.8 细化验证 3 个结论
　　

#### 2.2.9 静态同步 synchronized 方法与 synchronized(class) 代码块
　　


#### 2.2.10 数据类型 String 的常量池特性
　　

#### 2.2.11 同步 synchronized 方法无限等待与解决
　　

#### 2.2.12 多线程的死锁
　　

#### 2.2.13 内置类与静态内置类
　　

#### 2.2.14 内置类与同步：实验 1
　　

#### 2.2.15 内置类与同步：实验 2
　　


#### 2.2.16 锁对象的改变
　　


## 2.3 volatile 关键字
　　

#### 2.3.1 关键字 volatile 与死循环
　　


#### 2.3.2 解决同步死循环
　　


#### 2.3.3 解决异步死循环
　　


#### 2.3.4 volatile 非原子的特性
　　


#### 2.3.5 使用原子类进行 i++ 操作
　　


#### 2.3.6 原子类也并不完全安全
　　


#### 2.3.7 synchronized 代码块有 volatitle 同步的功能
　　


## 2.4 本章总结
　　




