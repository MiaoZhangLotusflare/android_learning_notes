# 第 3 章 线程间通信

## 本章主要内容
	

## 3.1 等待 / 通知机制
　　

#### 3.1.1 不使用等待 / 通知机制实现线程间通信
　　

#### 3.1.2 什么是等待 / 通知机制
　　

#### 3.1.3 等待 / 通知机制的实现
　　


#### 3.1.4 方法 wait() 锁释放与 notify() 锁不释放
　　

#### 3.1.5 当 interrupt 方法遇到 wait 方法
　　

#### 3.1.6 只通知一个线程
　　

#### 3.1.7 唤醒所有线程
　　

#### 3.1.8 方法 wait(long) 的使用
　　

#### 3.1.9 通知过早
　　


#### 3.1.10 等待 wait 的条件发生变化
　　

#### 3.1.11 生产者 / 消费者模式实现
　　

###### 1. 一生产与一消费：操作值
　　

###### 2. 多生产与多消费：操作值 - 假死
　　

###### 3. 多生产与多消费：操作值
　　

###### 4.一生产与一消费：操作栈
　　


###### 5.一生产与多消费 - 操作栈：解决 wait 条件改变与假死
　　


###### 6.多生产与一消费：操作栈
　　


###### 7.多生产与多消费：操作栈
　　


#### 3.1.12 通过管道进行线程间通信：字节流
　　


#### 3.1.13 通过管道进行线程间通信：字符流
　　


#### 3.1.14 实战：等待 / 通知之交叉备份
　　


## 3.2 方法 join 的使用
　　

#### 3.2.1 学习方法 join 前的铺垫
　　

#### 3.2.2 用 join() 方法来解决
　　

#### 3.2.3 方法 join 与异常
　　

#### 3.2.4 方法 join(long) 的使用
　　

#### 3.2.5 方法 join(long) 与 sleep(long) 的区别
　　

#### 3.2.6 方法 join() 后面的代码提前运行：出现意外
　　

#### 3.2.7 方法 join() 后面的代码提前运行：解释意外
　　


## 3.3 类 ThreadLocal 的使用
　　

#### 3.3.1 方法 get() 与 null
　　

#### 3.3.2 验证线程变量的隔离性
　　

#### 3.3.3 解决 get() 返回 null 问题
　　

#### 3.3.4 再次验证线程变量的隔离性
　　

## 3.4 类 InheritableThreadLocal 的使用
　　

#### 3.4.1 值继承
　　

#### 3.4.2 值继承再修改
　　

## 3.5 本章总结
　　


