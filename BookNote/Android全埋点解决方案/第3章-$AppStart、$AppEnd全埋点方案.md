# 第3章 $AppStart、$AppEnd 全埋点方案

​		对于 $AppStart 和 $AppEnd 事件而言，归根结底就是判断当前应用程序是处于前台还是处于后台。而 Android 系统本身并没有给应用程序提供相关的接口来判断这些状态，所以我们只能借助其他方式来间接判断。

​		目前，业界也有很多种方案用来判断一个应用程序是处于前台还是后台，以 Github上 的一个开源项目为例：https://github.com/wenmingvs/AndroidProcess。

​		这个开源项目提供了 6 种方案。这 6 种方案的综合对比可以参考下表。

![6种方案的对比](https://res.weread.qq.com/wrepub/epub_25123578_6)

## 3.1. 原理概述

1. 应用程序如果有多个进程该如何判断是处于前台还是处于后台？

​		众所周知，一个 Android 应用程序是可以有多个进程同时存在的，所以这就加大了我们判断一个应用程序是处于前台还是处于后台的难度，继而导致很多常见的判断方案也都会失效。

​		其实，对于这个问题，可以归于应用程序多进程间的数据共享问题。

​		Android 系统中支持多进程通信方式主要有以下几种，它们各有优缺点。

* AIDL

  AIDL 的功能相对来说比较强大，支持进程间一对多的实时并发通信，并且可以实现 RPC（远程过程调用）。

* Messenger

  Messenger 支持一对多的串行实时通信，它相当于是 AIDL 的简化版本。

* Bundle

  Bundle 是 Android 系统中四大组件的进程间通信方式，目前只能传输 Bundle 支持的数据类型，比如 String、int 等。

* ContentProvider

  ContentProvider 是一个非常强大的数据源访问组件，主要支持 CRUD 操作和一对多的进程间数据共享，例如我们的应用访问系统的图库数据。

* BroadcastReceiver

  BroadcastReceiver 即广播，目前只能支持单向通信，接收者只能被动地接收消息。

* 文件共享

  文件共享主要适用于在非高并发情况下共享一些比较简单的数据。

* Socket

  Socket主要通过网络传输数据。

​		主要是采用 ContentProvider 机制来解决进程间的数据共享问题。

2. 应用程序如果发生崩溃或者被强杀了该如何判断该应用程序是处于前台还是处于后台？

​		对于应用程序发生崩溃或者应用进程被强杀的场景，我们引入了 Session 的概念。简单理解就是：对于一个应用程序，当它的一个页面退出了，如果在 30s 之内没有新的页面打开，我们就认为这个应用程序处于后台了（触发 $AppEnd 事件）；当它的一个页面显示出来了，如果与上一个页面的退出时间的间隔超过了 30s，我们就认为这个应用程序重新处于前台了（触发 $AppStart事件）。此时，Session 的间隔我们是以 30s 为例。

## 3.2. 案例

​		完整的项目源码可以参考：https://github.com/wangzhzh/AutoTrackAppStartAppEnd

## 3.3. 缺点

​		应用程序发生崩溃或者应用程序被强杀等场景，需要下次启动应用程序的时候才能有机会补发 $AppEnd 事件。如果用户不再启动应用程序或者将应用程序卸载掉，会导致 “ 丢失 ” $AppEnd 事件。