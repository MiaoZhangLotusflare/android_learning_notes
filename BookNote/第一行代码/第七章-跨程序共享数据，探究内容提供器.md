# 第七章 跨程序共享数据，碳九内容提供器

1. 使用臼齿化技术所保存的数据都只能在当前程序中访问。
2. 内容提供器（Content Provider）主要用于在不同的应用程序之间实现数据共享的功能，它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访数据的安全性。目前，使用内容提供器是Android实现跨程序共享数据的标准方式。
    不同于文件存储和SharedPreferences存储中的两种全局可读写操作模式，内容提供器可以选择只对哪一部分数据进行共享，从而保证我们程序中的隐私数据不会有泄漏的风险。
	内容提供器的用法一般有两种，一种是使用现有的内容提供器来读取和操作相应程序中的数据，另一种是创建自己的内容提供器给我们程序的数据提供外部访问接口。
3. 当一个应用程序通过内容提供器对其数据提供了外部访问接口，任何其他的应用程序就都可以对这部分数据进行访问。Android系统中自带的电话簿、短信、媒体库等程序都提供了类似的访问接口，这就使得第三方应用程序可以充分地利用这部分数据来实现更好的功能。
    对于每一个应用程序来说，如果想要访问内容提供器中共享的数据，就一定要借助ContentResolve类，可以通过Context中的getContentResolver()方法获取到该类的实例。ContentResolver中提供了一系列的方法用于对数据进行CRUD操作，其中insert()方法用于添加数据，update()方法用于更新数据，delete()方法用于删除数据，query()方法用于查询数据。
	不同于SQLiteDatabase，ContentResolver中的增删改查方法都是不接收表名参数的，而是使用一个Uri参数代替，这个参数被称为内容URI。内容URI给内容提供器中的数据建立了唯一标识符，它主要由两部分组成，权限（authority）和路径（path）。权限是用于对不同的应用程序做区分的，一般为了避免冲突，都会采用程序包名的方式来进行命名。路径则是用于对同一应用程序中不同的表做区分的，通常都会添加到权限的后面。
	调用Uri.parse()方法，就可以将内容URL字符串解析成Uri对象了。
	可以使用Uri对象来查询table表中的数据，代码如下所示：

	      Cursor cursor = getContentResolver().query(
	           uri,
		   projection,
		   selection,
		   selectionArgs,
		   sortOrder
	      
	      )

	 query()方法参数     对应SQL部分                 描述
	 uri                 from table_name             指定查询某个应用程序下的某一张表
	 projection          select column1,column2      指定查询的列名
	 selection           where column = value        指定where的约束条件
	 selectionArgs       -                           为where中的占位符提供具体的值
	 orderBy             order by column1,column2    指定查询结果的排序方式
	 查询完成后返回的仍然是一个Cursor对象，这时我们就可以将数据从Cursor对象中逐个读取出来了。读物的思路仍然是通过移动游标的位置来遍历Cursor的所有行，然后再取出每一行中相应列的数据。
4. 创建自己的内容提供器需要继承ContentProvider，ContentProvider类中有六个抽象方法。
   （1）onCreate()
	    初始化内容提供器的时候调用。通常会在这里完成对数据库的创建和升级等操作，返回true表示内容提供器初始化成功，返回false则表示失败。注意，只有当存在ContentResolver尝试访问我们程序中的数据时，内容提供器才会被初始化。
   （2）query()
	    从内容提供器中查询数据。使用uri参数来确定查询哪张表，projection参数用于确定查询哪些列，selection和selectionArgs参数用于约束查询哪些行，sortOrder参数用于对结果进行排序，查询的结果存放在Cursor对象中返回。
   （3）insert()
	    更新内容提供器中添加一条数据。使用uri参数来确定要添加到的表，待添加的数据保存在values参数中，selection和selectionArgs参数用于约束更新哪些行，瘦影响的行数将作为返回值返回。
   （4）update()
	    更新内容提供器中已有的数据。使用uri参数来确定更新哪一张表中的数据，新数据保存在values参数中，selection和selectionArgs参数用于约束更新哪些行，受影响的行数将作为返回值返回。
   （5）delete()
	    从内容提供器中删除数据。使用uri参数来确定删除哪一张表中的数据，selection和selectionArgs参数用于约束删除哪些行，被删除的行数将作为返回值返回。
   （6）getType()
	    根据传入的内容URI来返回相应的MIME类型。
5. 一个标准的内容URI写法是这样的：
    content://com.example.app.provider/table1
	这就表示调用方期望访问的是com.example.app这个应用的table1表中的数据。除此之外，我们还可以在这跟人URI的后面加上一个id，如下所示：
	content://com.example.app.provider/table1/1
	内容URI的格式主要就只有以上两种，以路径结尾就表示期望访问该表中所有的数据，以id结尾就表示期望访问该表中拥有相应id的数据。我们可以使用通配符的方式来分别匹配这两种格式的内容URI，规则如下：
	   （1）*：表示匹配任意长度的任意字符
	   （2）#：表示匹配任意长度的数据
	    所以：一个能够匹配任意表的内容URI格式就可以写成：
	        content://com.example.app.provider/*
	    而一个能够匹配table1表中任意一行数据的内容URI格式就可以写成：
	        content://com.example.app.provider/table1/#
        我们再借助UriMatcher这个类就可以轻松地实现匹配内容URI的功能。UriMatcher中提供了一个addURI()方法，这个方法接收三个参数，可以分别把权限、路径和一个自定义代码传进去。这样，当调用UriMatcher的match()方法时，就可以将一个Uri对象传入，返回值是某个能够匹配这个Uri随想所对应的自定义代码，利用这个代码，我们 就可以判断出调用方期望访问的是哪张表中的数据了。
6. 一个内容URI所对应的MIME字符串主要由三部分组成，Android对这三个部分做了如下格式规格：
    （1）必须以vnd开头。
	（2）如果内容URI以路径结尾，则后接android.cursor:dir/，如果内容URI以id结尾，则后接android.cursor.item/。
	（3）最后接上vnd.<authority>.<path>。
	所以，对于content://com.example.app.provider/table1这个内容URL，它所对应的MIME类型就可以写成：
	    vnd.android.cursor.dir/vnd.com.example.app.provider.table1
	对于content://com.example.app.provider/table1/1这个内容URI，它所对应的MIME类型就可以写成：
	    vnd.android.cursor.item/vnd.com.example.app.provider.table1
7. Git提供了一种可配性很强的机制来允许用户将指定的文件或目录排除在版本控制之外，它会检查代码仓库的根目录下是否存在一个名为.gitignore的文件，如果存在的话就去一行行读取这个文件中的内容，并把每一行指定的文件或目录排除在版本控制之外。注意.gitignore中指定的文件或目录是可以使用“*”通配符的。
    查看文件修改情况使用status命令。
	git diff 可以查看到所有文件的更改内容。
	想要撤销修改可以使用checkout命令。这种撤销方式只适用于那些还没有执行过add命令的文件。执行过add命令的文件取消添加使用的是reset命令（get reaset HEAD <fileName>）。
    使用git log命令查看历史提交信息。
    使用git log commit-id 查看其中一条记录，加-1参数表示我们只想看到一行记录，加-p参数，查看这条提交记录具体修改了什么内容。

