Effective Java 
    第11条   
    第12条
         compareTo方法不但允许进行简单的等同性比较，而且允许执行顺序比较，是个泛型。
         如果一个类的compareTo方法施加了一个与equals方法不一致的顺序关系，它仍然能够正常工作，但是，如果一个有序集合包含了该类的元素，这个集合就可能无法遵守相应集合接口的通用约定。因为，对于这些接口的通用约定是按照equals方法来定义的，但是有序集合使用了由comp[areTo方法而不是equals方法所施加的等同性测试。
	 编写compareTo方法与编写equals方法非常相似，单页存在几处重大的差别。因为Comparable接口是参数化的，而且comparable方法是静态的类型，因此不必进行类型检查，也不必对它的参数进行类型转换。如果参数的类型不合适，这个调用甚至无法编译。如果参数为null，这个调用应该抛出NullPointerException异常，并且一旦该方法试图访问它的成员时就应该抛出。
	 CompareTo方法中域的比较是顺序的比较，而不是等同性的比较。
第4章 类与接口
    第13条 使类和成员的可访问性最小化
         设计良好的模块会隐藏所有的实现细节，把它的API与它的实现清晰地隔离开来。然后，模块之间只通过它们的API进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏（information hiding）或封装（encapsulation），是软件设计的基本原则之一。
         如果方法覆盖了超累中的一个方法，子类中的访问级别就不允许低于超类中的访问级别。这样可以确保任何可使用超类的实例的地方也都可以使用子类的实例。
	 如果一个类实现了一个接口，那么接口中所有的类方法在这个类中也都必须被声明为公有的。之所以如此，是因为接口中的所有方法都隐含着公有访问级别。
         实例域决不能是公有的。如果域是非final的，或者是一个指向可变对象的final引用，那么一旦使这个域成为共有的，就放弃了对存储在这个域中的值进行限制的能力；这意味着，你也放弃了强制这个域不可变的能力。同时，当这个域被修改的时候，你也失去了对它采取任何行动的能力。因此，包含公有可变域的类并不是线程安全的。即使域是final的，并且引用不可变的对象，当把这个域变成公有的时候，也就放弃了“切换到一种新的内部数据表示法”的灵活性。
	 同样的建议也适用于静态域，只是有一种例外情况。假设常量构成了类提供的整个抽象中的一部分，可以通过公有的静态final域来暴露这些常量。按惯例，这种域的名称由大写字母组成，单词之间用下划线隔开。很重要的一点是，这些域要么包含基本类型的值，要么包含指向不可变对象的引用。如果final域包含可变对象的引用，它便具有非final域所有缺点。虽然引用本身不能被修改，但是它所引用的对象却可以被修改-这会导致灾难性的后果。
	 长度非零的数组总是可变的，所以，类具有公有的静态final数组域，或者返回这种域的访问方法，这几乎总是错误的。如果类具有这样的域或者访问方法，客户端将能够修改数组中的内容。
    第14条 在公有类中使用访问方法而非公有域
         公有类永远都不应该暴露可变的域。虽然还是有问题，但是让公有类暴露不可变的域其危害比较小。但是，有时候会需要用包级私有的或者私有的嵌套类来暴露域，无论这个类是可变还是不可变的。
    第15条 使可变性最小化
         不可变类真正唯一的缺点是，对于每个不同的值都需要一个单独的对象。
         如果选择让自己的不可变类实现Serializable接口，并且包含一个或者多个指向可变对象的域，就必须提供一个显式的readObject或者readResolve方法，或者使用ObjectOutputStream.writeUnshared和ObjectInputStream.readUnshared方法，即使默认的序列化形式是可以接受的，也是如此。否则攻击者可能从不可变的类创建可变的实例。
    第16条 复合优先于继承
         在回调框架中，对象把自身的引用传递给其他的对象，用于后续的调用。 
	 只有当子类真正是超类的子类型时，才适合用继承。
    第17条 要么为继承而设计，并提供文档说明，要么就禁止继承   76
         对于为了继承而设计的类，唯一的测试方法就是编写子类。
	 为了允许继承，类必须遵守其他一些约束。构造器决不能调用可被覆盖的方法。
    第18条 接口优于抽象类
         接口通常是定义允许多个实现的类型的最佳途径。这条规则有个例外，即当演变的容易性比灵活性和功能更为重要的时候。在这种情况下，应该使用抽象类来定义类型，但前提是必须理解并且可以接受这些局限性。如果你导出了一个重要的接口，就应该坚决考虑同时提供实现类。最后，尽可能谨慎地设计所有的公有接口，并通过编写多个实现来对它们进行全面的测试。
    第19条 接口只用于定义类型
         常量接口没有包含任何方法，它只包含静态的final域，每个域都导出一个常量。使用这些常量的类实现这个接口，以避免用类名来修饰常量名。
	 常量接口模式是对接口的不良使用。
	 接口应该只被用来定义类型，它们不应该被用来导出常量。
    第20条 类层次优于标签类 
         遇到一个包含标签域的现有类时，就要考虑将它重构到一个层次结构中去。
    第21条 用函数对象表示策略
         Java没有提供函数指针，但是可以用对象引用实现同样的功能。调用对象上的方法通常是执行该对象上的某项操作。然而，我们也可能定义这样一种对象，它的方法执行其他对象（这些对象被显式传递给这些方法）上的操作。如果一个类仅仅导出这样的一个方法，它的实例实际上就等同于一个指向该方法的指针。这样的实例被称为函数对象。
    第22条 优先考虑静态成员类 
         嵌套类有四种：静态成员类(static member class)、非静态成员类(nonstatic member class)、匿名类(anonymous class)和局部类(local class)。除了第一种之外，其他三种都被称为内部类(inner class)。
 第5章 泛型
    第23条 请不要再新代码中使用原生态类型
         在没有泛型之前，从集合中读取到的每一个对象都必须进行转换。如果有人不小心插入了类型错误的对象，在运行时的转换处理就会出错。有了泛型之后，可以告诉编译器每个集合中接受哪些对象类型。编译器自动地为你的插入进行转化，并在编译时告知是否插入了类型错误的对象。
	 声明中具有一个或者多个类型参数的类或者接口，就是泛型类或者接口。从技术的角度来看，泛型类和接口统称为泛型(generic type)。
	 每个泛型都定义一个原生态类型(raw type)，既不带任何实际类型参数的泛型名称。
	 如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势。
	 如果使用像List这样的原生态类型，就会失掉类型安全性，但是如果使用像List<Object>这样的参数化类型，则不会。
	 Set<Object>是一个参数化类型，表示可以包含任何对象类型的一个集合，Set<?>则是一个通配符类型，表示只能包含某种未知对象类型的一个集合，Set则是个原生态类型，它脱离了泛型系统。前两种是安全的，最后一种是不安全的。
    第24条 消除非受检警告
         如果无法消除警告，同时可以证明引起警告的代码是类型安全的，（只有在这种情况下才）可以用一个@SuppressWarnings("unchecked")注解来禁止这条警告。
	 SuppressWarnings注解可以用在任何粒度的级别中，从单独的局部变量声明到整个类都可以。应该始终在尽可能小的范围中使用SuppressWarnings注解。它通常是个变量声明，或是非常简短的方法或者构造器。永远不要在整个类上使用SuppressWarnings，这样做可能会掩盖了重要的警告。
	 每当使用SuppressWarnings("unchecked")注解时，都要添加一条注释，说明为什么这样做是安全的。
    第25条 列表优先于数组 
	 数组和泛型相比，有两个重要的不同点。首先，数组是协变的(convariant)。协变表示如果Sub为Super的子类型，那么数组类型Sub[]解释Super[]的子类型。相反，泛型则是不可变的(invariant)，对于任意两个不同的类型Type1和Type2，List<Type1>既不是List<Type2>的子类型，也不是List<Type2>的超类型。
	 数组与泛型之间的第二大区别在于，数组是具体化的(reified)，因此数组会在运行时才知道检查它们的元素类型约束。相比之下，泛型则是通过擦除(erasure)来实现的，因此泛型只在编译时强化它们的类型信息，并在运行时丢弃（或者擦除）它们的元素类型信息。擦除就是使泛型可以与没有使用泛型的代码随意进行互用。
         创建泛型、参数化类型或者类型参数的数组是非法的，new List<E>[]、new List<String>[]和new E[]，这些在编译时都会导致一个generic array creation(泛型数组创建)错误。
	 为什么创建泛型数组是非法的？因为它不是类型安全的。要是它合法，编译器在其他正确的程序中发生的转换就会在运行时失败，并出现一个ClassCastException异常，这就违背了泛型系统提供的基本保证。、
	 从技术的角度来说，像E、List<E>和List<String>这样的类型应称作不可具体化的(nonreifiable)类型。直观地说，不可具体化的(non-reifiable)类型是指其运行时表示法包含的信息比它的编译时表示法包含的信息更少的类型。唯一可具体化的(reifiable)参数化类型是无限制的通配符类型，如List<?>和Map<?,?>，虽然不常用，但是创建无限制通配符类型的数组是合法的。
	 在结合使用可变参数(varargs)方法和泛型时会出现令人费解的警告，这是由于每当调用可变参数方法时，就会创建一个数组来存放varargs参数，如果这个数组的元素类型不是可具体化的(reifiable)，就会得到一条警告，关于这些警告，除了把它们禁止，并且避免在API中混合使用泛型与可变参数之外，别无他法。
	 如果你发现自己将数组和泛型混合起来使用，并且得到了编译时错误或者警告，你的第一反应就应该是用列表代替数组。
    第26条 优先考虑泛型
         类型参数列表(<E extends Delayed>)要求实际的类型参数E必须是java.util.concurrent.Delayed方法，无需显式的转换，也没有出现ClassCastException的风险。类型参数E被称作有限制的类型参数(bounded type parameter)。注意，字类型关系确定了，每个类型都是它自身的子类型，因此创建DelayQueue<Delayed>是合法的。
         使用泛型比使用需要在客户端代码中进行转换的类型来得更加安全，也更加容易。在设计新类型的时候，要确保它们不需要这种转换就可以使用。这通常意味着要把类做成泛型的。只要时间允许，就把现有的类型都泛型化。这对于这些类型的新用户来说会变得更加轻松，又不会破坏现有的客户端。
    第27条 优先考虑泛型方法
         泛型方法的一个显著特性是，无需明确指定类型参数的值，不像调用泛型构造器的时候是必须指定的。编译器通过检查方法参数的类型来计算类型参数的值。
         通过某个包含该类型参数本身的表达式来限制类型参数是允许的。这就是递归类型限制（recursive type bound）。
	 泛型方法就像泛型一样，使用起来比要求客户端转换输入参数并返回值的方法来得更加安全，也比较容易。就像类型一样，你应该确保新方法可以不用转换就能使用，这通常意味着要将它们泛型化。并且就像类型一样，还应该将现有的方法泛型化，使新用户使用起来更加轻松，且不会破坏现有的客户端。
    第28条 利用有限制通配符来提升API的灵活性
         为了获得最大限度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符类型。如果某个输入即是生产者，有时消费者，那么通配符类型对你就没有什么好处了：因为你需要的是严格的类型匹配，这是不用任何通配符而得到的。
	 PECS表示producer-extends, consumer-super。
	 不要用通配符类型作为返回类型。除了为用户提供额外的灵活性之外，它还会强制用户在客户端代码中使用通配符类型。
	 如果累得用户必须考虑通配符类型，类的API或许就会出错。
	 如果类型参数只在方法声明中出现一次，就可以用通配符取代它。
    第29条 有限考虑类型安全的异构容器 
         当一个类的字面文字被用在方法中，来传达编译时和运行时的类型信息时，就被称作type token。
	 Class的cast方法是Java的cast操作符的动态模拟。它只检验它的参数是否为Class对象所表示的类型的实例。如果是，就返回参数；否则就抛出ClassCastException异常。
	 集合API说明了泛型的一般用法，限制你每个容器只能有固定数目的类型参数。你可以通过将类型参数放在键上而不是容器上来避开这一限制。对于这种类型安全的异构容器，可以用Class对象作为键。以这种方式使用的Class对象称作类型令牌。也可以使用定制的键类型。例如，用一个DatabaseRow类型表示一个数据库行（容器），用泛型Column<T>作为它的键。
第6章 枚举与注解
    第30条 用enum代替int常量
         Java枚举类型背后的基本想法非常简单：它们就是通过公有的静态final域为每个枚举常量导出实例的类。因为没有可以访问的构造器，枚举类型是真正的final。因为客户端既不能创建枚举类型的实例，也不能对它进行扩展，因此很可能没有实例，而只有声明过的枚举常量。换句话说，枚举类型是实例受控的。它们是单例(Singleton)的泛型化，本质上是单元素的枚举。
	 枚举类型为类型安全的枚举模式提供了语言方面的支持。
	 枚举提供了编译时的类型安全。
	 包含同名常量的多个枚举类型可以在一个系统中和平共处，因为每个类型都有自己的命名空间。你可以增加或者重新排列枚举类型中的常量，而无需重新编译它的客户端代码，因为导出常量的域在枚举类型和它的客户端之间提供了一个隔离层；常量值并没有被编译到客户端代码中，而是在int枚举模式之中。最终，可以通过调用toString方法，将枚举转换成可打印的字符串。
	 除了完善了int枚举模式的不足之外，枚举类型还允许添加任意的方法和域，并实现任意的接口。它们提供了所有Object方法的高级实现，实现了Comparable和Serizable接口，并针对枚举类型的可任意改变性设计了序列化方式。
	 那么我们为什么要将方法或者域添加到枚举类型中呢？首先，你可能是想将数据与它的常量关联起来。
	 为了将数据和枚举常量关联起来，得声明实例域，并编写一个带有数据并将数据保存在域中的构造器。枚举天生就是不可变的，因此所有的域都应该为final的。它们可以是公有的，单最好将它们做成私有的，并提供公有的访问方法。
	 如果一个枚举具有普通适用性，它就应该成为一个顶层类(top-level class)；如果它只是被用在一个特定的顶层类中，它就应该成为该顶层类的一个成员类。
	 在枚举类型中声明一个抽象的apply方法，并在特定于常量的类主体（constant-specific class body）中，用具体的方法覆盖每个常量的抽象apply方法。这种方法被称作特定于常量的方法实现（constant-specific method implementation）。
	 枚举类型有一个自动产生的valueOf(String)方法，它将常量的名字转变成常量本身。如果在枚举类型中覆盖toString，要考虑编写一个fromString方法，将定制的字符串表示法变回相应的枚举。
         枚举中的switch语句适合于给外部的枚举类型增加特定于常量的行为。
	 一般来说，枚举会有限使用comparable而非int常量。与int常量相比，枚举有个小小的性能缺点，即装载和初始化枚举时会有空间和时间的成本。除了受资源约束的设备，例如手机和烤面包机之外，在实践中不必太在意这个问题。
	 那么什么时候应该使用枚举呢？每当需要一组固定常量的时候。当然，这包括“天然的枚举类型”，例如行星、一周的天数以及棋子的数目等等。但它也包含你在编译时就知道其所有可能值的其他集合，例如菜单的选项，操作代码以及命令行标记等。枚举类型中的常量集并不一定要始终保持不变。专门设计枚举特性是考虑到枚举类型的二进制兼容演变。
    第31条 用实例域代替序数  
         永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中。
    第32条 用EnumSet代替位域
         如果一个枚举类型的元素主要用在集合中，一般就是用int枚举模式，将2的不同倍数赋予每个变量：
	      public class Text {
	           public static final int STYLE_BOLD           = 1 << 0; //1
		   public static final int STYLE_ITALIC         = 1 << 1; //2
		   public static final int STYLE_UNDERLINE      = 1 << 2; //4
		   public static final int STYLE_STRIKETHROUCH  = 1 << 3; //8

		   public void applyStyles(int styles) {...}
	      }
         这种表示法让你用OR位运算将几个常量合并到一个集合中，称为位域(bit field):
	      text.applyStyles(STYLE_BOLD | STYLE_ITALIC);
	 位域表示法也允许利用位操作，有效地执行像union(联合)和intersection(交集)这样的集合操作。但位域有着int枚举常量的所有缺点，甚至更多。当位域以数字形式打印时，翻译位域比翻译简单的int枚举常量要困难很多，甚至，要遍历位域表示的所有元素也没有很容易的方法。
	 java.util包提供了EnumSet类有效地表示从单个枚举类型中提起的多个值的多个集合。这个类实现Set接口，提供了丰富的功能、类型安全性，以及可以从任何其他Set实现中得到的互用性。但是在内部具体的实现上，每个EnumSet内容都表示为位矢量。如果底层的枚举类型有64个或者更少的元素-大多如此-整个EnumSet就是用单个long来表示，因此它的性能比得上位域的性能。
	 EnumSet有个缺点，即截止Java 1.6发型版本，它都无法创建不可变的EnumSet，但是这一点很可能在即将出来的版本中得到修正。同事，可以用Collections.unmodifiableSet将EnumSet封装起来，但是简洁性和性能会受到影响。
    第33条 用EnumMap代替序数索引
         EnumMap构造器采用键类型的Class对象：这是一个有限制的类型令牌（bounded type token），它提供了运行时的泛型信息。
         最好不要用序数来索引数组，而要使用EnumMap。如果你所表示的这种关系是多维的，就是用EnumMap<..., EnumMap<...>>。应用程序的程序员在一般情况下都不适用Enum.ordinal，即使要用也很少，因此这是一种特殊情况。
    第34条 用接口模拟可伸缩的枚举
         对于可伸缩的枚举类型而言，至少有一种具有说服力的用例，这就是操作码（operation code），也称作opcode。
	 操作码是指这样的枚举类型：它的元素表示在某种机器上的那些操作。
	 有时候，要尽可能地让AOI的用户提供它们自己的操作，这样可以有效地扩展API所提供的操作集。
	 枚举类型可以通过给操作码类型和（属于接口的标准实现的）枚举定义接口，来实现任意接口。
	 用接口模拟可伸缩枚举有个小小的不足，即无法将实现从一个枚举类型继承到另一个枚举类型。
	 虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础枚举类型，对它进行模拟、这样允许客户端编写自己的枚举来实现接口。如果API是根据接口编写的，那么在可以使用基础枚举类型的任何地方，也都可以使用这些枚举。
    第35条 注解优先于命名模式
         注解类型声明中的注解称作元注解(meta-annotation)。
	 @Retention(RetentionPolicy.RUNTIME)元注解表明，注解应该在运行时保留。
	 @Target(ElementType.METHOD)元注解表明，只在方法声明中才是合法的：它不能运用到类声明、域声明或者其他程序元素上。
    第36条 坚持使用Override注解
         Override注解只能用在方法声明中，它表示被注解的方法覆盖了超类型中的一个声明。
	 现在的IDE提供了坚持使用Override注解的一个理由。这种IDE具有自动检查功能，称作代码检验（code inspection）。如果启用相应的代码检验功能，当有一个方法没有Override注解，却覆盖了超类方法时，IDE就会产生警告。如果坚持使用Override注解，这些警告就会提醒你警惕无意识的覆盖。这些警告补充了编译器的错误信息，提醒你警惕无意识的覆盖失败。IDE和编译器，可以确保你覆盖任何你想要覆盖的方法，无一遗漏。
    第37条 用标记接口定义类型
         标记接口（maker interface）是没有包含方法声明的接口，而只是指明一个类实现了具有某种属性的接口。如Serializable接口，实现它的实例就可以被写到ObjectOutputStream。
	 标记接口有两点胜过标记注解。首先，也是最重要的一点是，标记接口定义的类型是由被标记类的实例实现的；标记注解则没有定义这样的类型。这个类型允许你在编译时捕捉在使用标记注解的情况下要到运行时才能捕捉到的错误。
	 标记接口胜过标记注解的另一个优点是，它们可以被更加精确地进行锁定。如果注解类型利用@Target（ElementType.TYPE）声明，它就可以被应用到任何类或者接口。假设有一个标记只适用于特殊接口的实现。如果将它定义成一个标记接口，就可以用它将唯一的接口扩展成它适用的接口。
	 标记注解胜过接口的最大优点在于，它可以通过默认的方式添加一个或者多个注解类型元素，给已被使用的注解类型添加更多的信息。随着时间的推移，简单的标记注解类型可以演变成更加丰富的注解类型。这种演变对于标记接口而言是不可能的，因为它通常不可能在实现接口之后再给它添加方法。
	 标记注解的另一个优点在于，它们是更大的注解机制的一部分。因此，标记注解在那些支持注解作为编程元素之一的框架中同样具有一致性。
	 那么什么时候应该使用标记注解，什么时候应该使用标记接口呢？很显然，如果标记是应用到任何程序元素而不是类或者接口，就必须使用注解，因为只有类和接口可以用来实现或者扩展接口。如果标记只应用给类和接口，就要问问自己：我要编写一个还是多个只接受有这种标记的方法呢？如果是这种情况，就应该优先使用标记接口而非注解。这样你就可以用接口作为相关方法的参数类型，它真正可以为你提供编译时进行类型检查的好处。如果你对第一个问题的回答是否定的，就再问问自己：我要永远限制这个标记只用于特殊接口的元素吗？如果是，最好将标记定义成该接口的一个子接口。如果两个问题的答案都是否定的，或许就应该使用标记注解。
	 如果想要定义一个任何新方法都不会与之关联的类型，标记接口就是最好的选择。如果想要标记程序元素而非类和接口，考虑到未来可能要给标记添加更多的信息，或者标记要适合于已经广泛使用了注解类型的框架，那么标记注解就是正确的选择。
	 如果你发现自己在编写的是目标为ElementType.TYPE的标记注解类型，就要花点时间考虑清楚，它是否真的应该为注解类型，想想标记接口是否会更加适合呢。
第7章 方法
    第38条 检查参数的有效性
         对于公有的方法，要用Javadoc的@throw标签（tag）在文档中说明违反参数限制时会抛出的异常。这样的异常通常为IllegalArgumentException、IndexOutOfBoundException或NullPointerException。
	 对于未被导出的方法(unexported method)，作为包的创建者，你可以控制这个方法将在哪种情况下被调用，因此你可以，也应该确保只将有效地参数值传递过来。因此，非公有的方法通常应该使用断言(assertion)来检查它们的参数。
	 从本质上讲，这些断言是在声称被断言的条件将会为真，无论外围包的客户端如何使用它。不同于一般的有效性检查，断言如果失败，将会抛出AssertionError。也不同于一般的有效性检查，如果它们没有起到作用，本质上也不会有成本开销，除非通过将-ea(或者-enableassertions)标记(flag)传递给Java解释器，来启用它们。
	 每当编写方法或者构造器的时候，应该考虑它的参数有哪些限制。应该把这些限制写到文档中，并且在这个方法体的开头处，通过显示的检查来实施这些限制。
    第39条 必要时进行保护性拷贝
         Java是一门安全的语言(safe language)。这意味着，它对于缓冲区溢出、数组越界、非法指针记忆其他的内存破坏错误都自动免疫。
	 即使在安全的语言中，如果不采取一点措施，还是无法与其他的类隔离开来。假设类的客户端会尽其所能来破坏这个类的约束条件，因此你必须保护性地设计程序。实际上，只有当有人试图破坏系统的安全性时，才可能发生这种情形；更有可能地是，对你的API产生误解的程序员，所导致的的各种不可预期的行为，只好由类来处理。
	 对于构造器的每个可变参数进行保护性拷贝(defensive copy)是必要的。
	 保护性拷贝是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是针对原始的对象。这样做可以避免在“危险阶段(window of vulncrability)”期间从另一个线程改变类的参数，这里的危险阶段是指从检查参数开始，知道拷贝参数之间的时间段。
	 对于参数类型可以被不可信任方子类化的参数，请不要使用clone方法进行保护性拷贝。
	 参数的保护性拷贝并不仅仅针对不可变类。每当编写方法或者构造器时，如果它要允许客户提供的对象进入到内部数据结构中，则有必要考虑一下，客户提供的对象是否有可能是可变的。如果是，就要考虑你的类是否能够容忍对象进入数据结构之后发生变化。如果答案是否定的，就必须对该对象进行保护性拷贝，并且让拷贝之后的对象而不是原始对象进入到数据结构中。
	 在内部组件被返回给客户端之前，对它们进行保护性拷贝也是同样的道理。不管类是否为不可变的，在把一个指向内部可变组件的引用返回给客户端之间，也应该加倍认真地考虑。解决方案是，应该返回保护性拷贝。记住长度非零的数组总是可变的。因此，在把内部数组返回给客户端之前，应该总要进行保护性拷贝。另一种解决方案是，给客户端返回该数组的不可变视图(immutable view)。
	 保护性拷贝可能会带来相关的性能损失，这种说法并不总是正确的。如果类信任它的调用者不会修改内部的组件，可能因为类及其客户端都是同一个包的双方，那么不进行保护性拷贝也是可以的。在这种情况下，类的文档中必须清楚地说明，调用者绝不能修改受到影响的参数或者返回值。
	 即使跨越包的作用范围，也并不总是适合在将可变参数整合到对象中之前，对它进行保护性拷贝。有一些方法和构造器的调用，要求参数所引用的对象必须有个显式的交接(handoff)过程。当客户端调用这样的方法时，它承诺以后不再直接修改该对象。如果方法或者构造器期望接管一个由客户端提供的可变对象，它就必须在文档中明确地指明这一点。
	 如果类所包含的方法或者构造器的调用需要移交对象的控制权，这个类就无法让自身抵制恶意的客户端，只有当类和它的客户端之前有着互相的信任，或者破坏类的约束条件不会伤害到除了客户端之外的其他对象时，这种类才是可以接受的。
	 如果类具有从客户端得到或者返回到客户端的可变组件，类就必须保护性地拷贝这些组件。如果拷贝的成本受到限制，并且类信任它的客户端不会不恰当地修改组件，就可以在文档中指明客户端的职责是不得修改受到影响的组件，以此来代替保护性拷贝。
    第40条 谨慎设计方法签名
	 谨慎地选择方法的名称。方法的名称应该始终遵循标准的命名习惯。首要目标应该是选择易于理解的，并且与同一个包中的其他名称风格一致的名称。第二个目标应该是选择与大众认可的名称（如果存在的话）相一致的名称。
	 不要过于追求提供便利的方法。每个方法都应该尽其所能。方法太多会使类难以学习、使用、文档化、测试和维护。对于雷和接口所支持的每个动作，都提供一个功能齐全的方法。只有当一项操作被经常用到的时候，才考虑为它提供快捷方式(shorthand)。如果不能确定，还是不提供快捷为好。
	 避免过长的参数列表。目标是四个参数，或者更少。相同类型的长参数序列格外有害。
	 有三种方法可以缩短过长的参数列表。第一种是把方法分解成多个方法，每个方法只需要这些参数的一个子集。如果不小心，这样做会导致方法过多。但是通过提升它们的正交性(orthogonality)，还可以减少(reduce)方法的数目。缩短长参数列表的第二种方法是创建辅助类(helper class)，用来保存参数的分组。这些辅助类一般为静态成员类。如果一个频繁出现的参数序列可以被看做是代表了某个独特的实体，则建议使用这种方法。结合了前两种方法特征的第三种方法是，从对象构建到方法调用都采用Builder模式。如果方法带有多个参数，尤其是当他们中有些是可选的时候，最好定义一个对象来表示所有参数，并允许客户端在这个对象上进行多次"setter"调用，每次调用都设置一个参数，或者设置一个较小的相关的集合。一般设置了需要的参数，客户端就调用对象的“执行(execute)”方法，它对参数进行最终的有效性检查，并执行实际的计算。
	 对于参数类型，要有限使用接口而不是类。只要有适当的接口可用来定义参数，就优先使用这个接口，而不是使用实现该接口的类。如果使用的是类而不是接口，则限制了哭护短只能传入替丁的实现，如果碰巧输入的数据是以其他的形式存在，就会导致不必要的‘可能非常昂贵的拷贝操作。
	 对于boolean参数，要有限使用两个元素的枚举类型。它使代码更易于阅读和编写，尤其当你在使用支持自动完成功能的IDE的时候。它也使以后更易于添加更多的选项。
    第41条 慎用重载
         要调用哪个重载(overloading)方法是在编译时做出决定。
	 对于重载方法(overloading method)的选择是静态的，而对于被覆盖的方法(overridden method)的选择则是动态的。选择被覆盖的方法的正确版本是在运行时进行的，选择的依据是被调用方法所在对象的运行时类型。
	 当一个子类包含的方法声明与其祖先类中的方法声明具有相同的签名时，方法就被覆盖了。
	 如果实例方法在子类中被覆盖了，并且这个方法是在该子类的实例上被调用的，那么子类中的覆盖方法(overriding method)将会执行，而不管该子类实例的编译时类型到底是什么。
	 一般情况下，对于多个具有相同参数数目的方法来说，应该避免重载方法。在某些情况下，特别是涉及构造器的时候，要遵循这条建议也许是不可能的。在这种情况下，至少应该避免这样的情形：同一组参数只需经过类型转换就可以被传递给不同的重载方法。如果不能避免这种情形，例如，因为正在改造一个现有的类以实现新的接口，就应该保证：当传递同样的参数时，所有重载方法的行为必须一致。
    第42条 慎用可变参数
         不必改造具有final数组参数的每个方法；只当确实是在数目不定的值上执行调用时才是用可变参数。
	 在重视性能的情况下，是用可变参数机制要特别小心。可变参数方法的每次调用都会导致进行一次数组分配和初始化。
	 在定义参数数目不定的方法时，可变参数方法是一种很方便的方式，但是它们不应该被过度滥用。如果使用不当，会产生混乱的结果。
    第43条 返回零长度的数组或集合么不是null
         返回类型为数组或集合的方法没理由返回null，而不是返回一个零长度的数组或者集合。
    地44条 为所有导出的API元素编写文档注释
         为了正确得编写API文档，必须在每个被导出的类、接口、构造器、方法和域声明之前增加一个文档注释。如果类是可序列化的，也应该对它的序列化形式编写文档。如果没有文档注释，Javadoc所能做的也就是重新生成该声明，作为受影响的API元素的唯一文档。为了编写出可维护的代码，还应该为那些没有被导出的类、接口、构造器、方法和域编写文档注释。
	 方法的文档注释应该简洁地描述出它和客户端之间的约定。除了专门为继承而设计的类中的方法之外，这个约定应该说明这个方法做了什么，而不是说明它是如何完成这项工作的。文档注释应该列举出这个方法的所有前提条件(precondition)和后置条件(postcondition)，所谓前提条件是指为了使客户端能够调用这个方法，而必须满足的条件；所谓后置条件是指在调用成功完成之后，哪些条件必须要满足。一般情况下，前提条件是由@throws标签针对未受检的异常所隐含描述的；每个未受检的异常都对应一个前提违例(precondition violation)。同样地，也可以在一些受影响的@param标记中指定前提条件。
	 除了前提条件和后置条件之外，每个方法还应该在文档中描述它的副作用(side effect)。所谓副作用是指系统状态中可以观察到的变化，
	 为了完整地描述方法的约定，方法的文档注释应该让每个参数都有一个@param标签，以及一个@return标签（除非这个方法的返回类型是void），以及对于该方法抛出的每个异常，无论是受检的还是未受检的，都有一个@throws标签。按惯例，跟在@param标签或者@return标签后面的文字应该是一个名词短语，描述了这个参数或者返回值所表示的值。跟在@throws标签之后的文字应该包含单词"if"(如果)，紧接着是一个名词短语，它描述了这个异常将在什么样的条件下会被抛出。有时候，也会用算数表达式来代替名词短语。按惯例，@param、@return或者@throws标签后面的短语或者自居都不用句点来结束。
	 @throws子句的代码片段中到处使用了Javadoc的{@code}标签。它有两个作用：造成该代码片段以代码字体(code font)进行呈现，并限制HTML标记和嵌套的Javadoc标签在代码片段中进行处理。
	 在Java 1.5发行版本之前，是通过使用HTML标签和HTML转义，将代码片段包含在文档注释中。现在再也没有必要在文档注释中使用HTML <code>或者<tt>标签了：Javadoc{@code}标签更好，因为它避免了转义HTML元字符。为了将多个代码示例包含在一个文档注释中，要使用包在HTML的<pre>标签里面的Javadoc{@code}标签。换句话说，是先在多行的代码示例前使用字符<pre>{@code,然后在代码后面机上}</pre>
	 要注意文档注释中用到了单词“this”。按惯例，当"this"被用在实例方法的文档注释中时，它应该始终是指方法调用所在的对象。
	 为了产生包含HTML元字符的文档，比如小于号(<)、大于号(>)以及“与”号(&)，必须采取特殊的动作。让这些字符出现在文档中的最佳方法是用{@literal}标签将它们包围起来，这样就限制了HTML标记和嵌套的Javadoc标签的处理。除了它不以代码字体渲染文本之外，其余方面就像{@code}标签一样。
	 文档注释在源代码和产生的文档中都应该是易于阅读的。如果无法让两者都易读，产生的文档的可读性要优先于源代码的可读性。
	 每个文档注释的第一句话成了该注释所属元素的概要描述(summary description)。为了避免混淆，同一个类或者接口中的两个成员或者构造器，不应该具有同样的概要描述。
	 注意所期待的概要描述中是否包含句点，因为句点会过早地终止这个描述。最好的解决方法是，将讨厌的句点以及任何与{@literal}关联的文本都包起来。
	 概要描述很少是个完整的句子。对于方法和构造器而言，概要描述应该是个完整的动词短语（包含任何对象），它描述了该方法所执行的动作。
	 对于类、接口和域，概要描述应该是一个名词短语，它描述了该类或者接口的实例，或者域本身所代表的事物。
	 当为泛型或者方法编写文档时，确保要在文档中说明所有的类型参数。
	 当为枚举类型编写文档时，要确保在文档中说明常量，以及类型，还有任何公有的方法。
	 为注解类型编写文档，要确保在文档中说明所有成员，以及类型本身。带有名词短语的文档成员，就像是域一样。对于该类型的概要描述，要使用一个动词短语，说明当程序元素具有这种类型的注解时它表示什么意思。
	 从Java 1.5发行版本开始，包级私有的文档注释就应该放在一个称作package-info.java的文件中，而不是放在package.html中。除了包级私有的文档注释之外，package-info.java也可以（但并非必要）包含包声明和包注解。
	 类的导出API有两个特征经常被人忽视，即线程安全性和可序列化性。类是否是线程安全的，应该在文档中对它的线程安全级别进行说明。如果类是可序列化的，就应该在文档中说明它的序列化形式。
	 javadoc具有“继承”方法注释的能力。如果API元素没有文档注释，Javadoc将会搜索最为使用的文档注释，接口的文档注释优先于超类的文档注释。也可以利用{@inheritDoc}标签从超类型中继承文档注释的部分内容。这意味着，类还可以重用它所实现的接口的文档注释，而不需要拷贝这些注释。这项机制有可能减轻维护多个几乎相同的文档注释的负担，但它使用起来比较需要小技巧(tricky)，并具有一些局限性。
	 为了降低文档注释中出错的可能性，一种简单的方法是通过一个HTML有效性检查器(HTML validity checker)来运行由Javadoc产生的HTML文件。这样可以检测出HTML标签的许多不正确用法，以及应该被转义的HTML元字符。
	 虽然为所有导出的API元素提供文档注释是必要的，但是这样做并非永远就足够了。对于由多个相互关联的类组成的复杂API，通常有必要用一个外部文档来描述该API的总体结构，对文档注释进行补充。如果有这样的文档，相关的类或者包文档注释就应该包含一个对这个外部文档的链接。
	 要为API编写文档，文档注释是最好、最有效的途径。对于所有可导出的API元素来说，使用文档注释应该被看作是强制性的。要采用一致的风格来遵循标准的约定。记住，在文档注释内部出现任何HTML标签都是允许的，但是HTML元字符需要经过转义。
第8章 通用程序设计 
    第45条 将局部变量的作用域最小化
         要使局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明。
	 过早地声明局部变量不仅会使它的作用域过早地扩展，而且结束得也过于晚了。局部变量的作用域从它被声明的点开始扩展，一直到外围块(block)的结束处。如果变量是在“使用它的块”之外被声明的，当程序退出该块之后，该变量仍是课件的。如果变量在它的目标使用区域之前或者之后被意外地使用的话，后果将可能是灾难性的。
	 几乎每个局部变量的声明都应该包含一个初始化表达式。如果你没有足够的信息来对一个变量进行有意义的初始化，就应该推迟这个声明，直到可以初始化为止。这条规则有个例外的情况与try-catch语句有关。如果一个变量被一个方法初始化，而这个方法可能会抛出一个受检的异常(checked exception)，该变量就必须在try块的内部被初始化。如果变量的值必须在try块的外部被使用到，它就必须在try块之前被声明，但是在try块之前，它还不能被“有意义地初始化”。
	 循环中提供了特殊的机会来将变量的作用域最小化。（武林是传统的还是for-each形式的）for循环，都允许声明循环变量(loop variable)，它们的作用域被限定在正好需要的范围之内。（这个范围包括循环体，以及循环体之前的初始化、测试、更新部分。）因此，如果在循环终止之后不再需要循环变量的内容，for循环就优先于while循环。
	 最后一种“将局部变量的作用域最小化”的方法是使方法小而集中。如果把两个操作(activity)合并到同一个方法中，与其中一个操作相关的局部变量又有可能会出现在执行另一个操作的代码范围之内。为了防止这种情况发生，只要把这个方法分成两个，每个方法各执行一个操作。
    第46条 for-each循环优先于传统的for循环
         for-each循环在简洁性和预防Bug方面有着传统的for循环无法比拟的优势，并且没有性能损失。应该尽可能地使用for-each循环。遗憾的是，有三种常见的情况无法使用for-each训话：
	      1.过滤---如果需要遍历集合，并删除选定的元素，就需要使用显式的迭代器，以便可以调用它的remove方法。
	      2.转换---如果需要并行地遍历列表或者数组，并取代它部分或者全部的元素值，就需要列表迭代器或者数组索引，以便设定元素的值。
	      3.平行迭代---如果需要并行地遍历多个集合，就需要显式地控制迭代器或者索引变量，以便所有迭代器或者索引变量都可以得到同步前移。
    第47条 了解和使用类库
         random方法的三个缺点：（产生0-n之间的随机整数,Randon rnd = new Random();Math.abs(rnd.nextInt())%n;）
	      第一个缺点是，如果n是一个比较小的2的乘方，经过一段相当短的周期之后，它产生的随机数序列将会重复。
	      第二个缺点是，如果n不是2的盛放，那么平均起来，有些数会比其他的数出现的更加频繁。如果n比较大，这个缺点就会非常明显。
	      第三个缺点是，在极少数情况下，它的失败是灾难性的，返回一个落在指定范围之外的数。之所以如此，是因为这个方法视图通过Math.abs，将rnd.nextInt()返回的值映射为一个非负整数int。如果next()返回Integer.MIN_VALUE，那么Math.abs也会返回Integer.MIN_VALUE，假设n不是2的乘方，那么取模运算符(%)将会返回一个负数。
         使用标准库的好处：
	      通过使用标准类库，可以充分利用这些编写标准类库的专家的知识，以及在你之前的其他人的使用经验。
	      使用标准库的第二个好处是，不必浪费时间为那些与工作不太相关的问题提供特别的解决方案。
	      使用标准类库的第三个好处是，它们的性能往往会随着时间的推移而不断提高，无需你做任何努力。
	      使用标准类库的最后一个好处是，可以使自己的代码融入主流。这样的代码更易读、更易维护，更易被大多数的开发人员重用。
	 在每个重要的发行版本中，都会有许多新的特性被加入到类库中，所以与这些新特性保持同步是值得的。
	 每个程序员都应该熟悉java.lang、java.util，某种程序上还有java.io中的内容。
	 在1.2发行版本中，Collections Framework（集合框架）被加入到了java.util包中。它应该成为每个程序员基本工具箱中的一部分。Collections Framework是一个统一的体系结构，用来表示和操作集合，允许它们对集合进行独立于表示细节的操作。它减轻了编程的负担，同时还提升了性能。它考虑到不相关的API之间的互操作性，减少了为设计和学习新的API所要付出的努力，并且鼓励软件重用。
	 1.5发行版本中，在java.util.concurrent包中增加了一组并发实用工具。这个包既包含高级的并发工具来简化多线程的编程任务，还包含低级别的并发基本类型，允许专家们自己编写更高级的并发抽象。java.util.concurrent的高级部分，也应该是每个程序员基本工具箱中的一部分。
    第48条 如果需要精确的答案，请避免使用float和double
         float和double类型主要是为了科学计算和工程计算而设计的。它们执行二进制浮点计算(binary floating-point arithmetic)，这是为了在广泛的数值范围上提供较为精确的快速近似计算而精心设计的。然而，它们并没有提供完全精确的结果，所以不应该被用于需要精确结果的场合。float和double类型尤其不适合用于货币计算，因为要让一个float或者double精确地表示0.1(或者10的任何其他负数次方值)是不可能的。
	 使用BigDecimal、int或者long进行货币计算。
	 使用BigDecimal有两个缺点：与使用基本运算类型相比，这样做很不方便，而且很慢。对于解决这样一个简单的问题，后一个缺点并不要紧，但是前一种缺点可能会让你不舒服。
	 对于任何需要精确答案的计算任务，请不要使用float或者double。如果你想让系统来记录十进制小数点，并且不介意因为不使用基本类型二带来的不便，就请使用BigDecimal。使用BigDimal还有一些额外的好处，它允许你完全控制舍入，每当一个操作涉及舍入的时候，它允许你从8中舍入模式中选择其一。如果你正通过法定要求的舍入行为进行业务计算，使用BigDecimal时非常方便的。如果性能非常关键，并且你又不介意自己记录十进制小数点，而且所涉及的数值又不太大，就可以使用int或者long。如果数值范围没有超过9位十进制数字，就可以使用int，如果不超过18位数字，就可以使用long。如果数值可能超过18位数字，就必须使用BigDecimal。
    第49条 基本类型优先于装箱基本类型
         Java有一个类型系统由两部分组成，包含基本类型(primitive)，如int、double和boolean，和引用类型(reference type)，如String和List。每个基本类型都有一个对应的引用类型，称作装箱基本类型(boxed primitive)。装箱基本类型中对应于int、double和boolean的是Integer、Double和Boolean。
	 在基本类型和装箱基本类型之间有三个主要区别。第一，基本类型只有值，而装箱基本类型则具有与它们的值不同的同一性。换句话说，两个装箱基本类型可以具有相同的值和不同的同一性。换句话说，两个装箱基本类型可以具有相同的值和不同的同一性。第二，基本类型只有功能完备的值，而每个装箱基本类型除了它对应基本类型的所有功能值之外，还有一个非功能值：null。最后一点区别是，基本类型通常比装箱基本类型更节省空间和时间。
	 对装箱基本类型运用==操作符几乎总是错误的。
	 当在一项操作中混合使用基本类型和装箱基本类型时，装箱基本类型会自动拆箱。如果null对象引用被自动拆箱，就会得到一个NullPointerException一样。
	 那么什么时候应该使用装箱基本类型呢？它们有几个合理的用处。第一个是作为集合中的元素、键和值。你不能将基本类型放在集合中，因此必须使用装箱基本类型。这是一种更常用的特例。在参数化类型中，必须使用装箱基本类型作为类型参数，因为Java不允许使用基本类型。例如，你不能将变量声明为ThreadLocal<int>类型，因此必须使用ThreadLocal<Integer>代替，最后，在进行反射的方法调用时，必须使用装箱基本类型。
	 当可以选择的时候，基本类型要优先于装箱基本类型。基本类型更加简单，也更加快速。如果必须使用装箱基本类型，要特别小心！自动装箱减少了使用装箱基本类型的繁琐性，但是并没有减少它的风险。当程序用==操作符比较两个装箱基本类型时，它做了一个同一性比较，这几乎肯定不是你所希望的。当程序进行涉及装箱和拆箱基本类型的混合类型计算时，它会进行拆箱，当程序进行拆箱时，会抛出NullPointerException异常。最后，当程序装箱了基本类型时，会导致高开销和不必要的对象创建。
    第50条 如果其他类型更适合，则尽量避免使用字符串 
         字符串不适合代替其他的值类型。如果存在适当的值类型，不管是基本类型，还是对象引用，大多应该使用这种类型；如果不存在这样的类型，就应该编写一个类型。
	 字符串不适用代替枚举类型。
	 字符串不适合代替聚集类型。如果一个实体有多个组件，用一个字符串来表示这个实体通常是很不恰当的。
	 字符串也不适合代替能力表（capabilities）。
	 如果可以使用更加合适的数据类型，或者可以编写更加适合的数据类型，就应该避免用字符串来表示对象。若使用不当，字符串会比其他的类型更加笨拙、更不灵活、速度更慢，也更容易出错。经常被错误地用字符串来代替的类型包括基本类型、枚举类型和聚集类型。
    第51条 当心字符串连接的性能
         字符串连接操作符(+,string concatenation operator)是把多个字符串合并为一个字符串的便利途径。要想产生单独一行的输出，或者构造字符串来表示一个较小的、大小固定的对象，使用连接操作符是非常合适的，但是它不适合运用在大规模的场景中。为连接n个字符串而重复地使用字符串连接操作符，需要n的平方级时间。这是由于字符串不可变而导致的不幸结果。当两个字符串被连接在一起时，它们的内容都会被拷贝。
	 为了获得可以接受的性能，请使用StringBuilder代替String。
	 不要使用字符串连接操作来合并多个字符串，除非性能无关紧要。相反，应该使用StringBuilder的append方法。另一个方法是，使用字符数组，或者每次只处理一个字符串，而不是将它们组合起来。
    第52条 通过接口引用对象
         如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明。只有当你利用构造器创建某个对象的时候，才真正需要引用这个对象的类。
	 如果你养成了用接口作为类型的习惯，你的程序将会更加灵活。当你决定更换实现时，所做的就只是改变构造器中类的名称（或者使用一个不同的静态工程）。
	 有一点值得注意：如果原来的实现提供了某种特殊的功能，而这种功能并不是这个接口的通用约定所要求的，并且周围的代码又依赖于这种功能，那么很关键的一点是，新的实现也要提供同样的功能。
	 如果没有合适的接口存在，完全可以用类而不是接口来引用对象。
	 不存在适当接口类型的第二种情形是，对象属于一个框架，而框架的基本类型是类，不是接口。如果对象属于这种基于类的框架(class-based framework)，就应该用相关的基类(base class)(往往是抽象类)来引用这个对象，而不是用它的实现类。
	 不存在适当接口类型的最后一种情形是，类实现了接口，但是它提供了接口中不存在的额外方法。如果程序依赖于这些额外的方法，这种类就应该只被用来引用它的实例。它很少应该被用作参数类型。
    第53条 接口优先于反射机制 201
         
总277页 总78条












