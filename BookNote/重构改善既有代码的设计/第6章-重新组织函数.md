# 第 6 章 重新组织函数

​		我的重构手法中，很大一部分是对函数进行整理，使之更恰当地包装代码。几乎所有时刻，问题都源于 Long Methods（过长函数）。这很讨厌，因为它们往往包含太多信息，这些信息又被函数错综复杂的逻辑掩盖，不易鉴别。对付过长函数，一项重要的重构手法就是 Extract Method (110)（提炼函数），它把一段代码从原先函数中提取出来，放进一个单独函数中。Inline Method ( 117)（内联函数）正好相反：将一个函数调用动作替换为该函数本体。如果在进行多次提炼之后，意识到提炼所得的某些函数并没有做任何实质事情，或如果需要回溯恢复原先函数，我就需要 Inline Method (117)（内联函数）。

​		Extract Method (110)（提炼函数）最大的困难就是处理局部变量，而临时变量则是其中一个主要的困难源头。处理一个函数时，我喜欢运用 Replace Temp with Query (120)（以查询取代临时变量）去掉所有可去掉的临时变量。如果很多地方使用了某个临时变量，我就会先运用 Split Temporary Variable (128)（分解临时变量）将它变得比较容易替换。

​		但有时候临时变量实在太混乱，难以替换。这时候我就需要使用 Replace Method with Method Object (135)（以函数对象取代函数）。它让我可以分解哪怕最混乱的函数，代价则是引入一个新类。

​		参数带来的问题比临时变量稍微少一些，前提是你不在函数内赋值给它们。如果你已经这样做了，就得使用 Remove Assignments to Parameters (131)（移除对参数的赋值）。

​		函数分解完毕后，我就可以知道如何让它工作得更好。也许我还会发现算法可以改进，从而使代码更清晰。这时我就使用 Substitute Algorithm (139)（替换算法）引入更清晰的算法。

## 6.1. Extract Method（提炼函数）

​		你有一段代码可以被组织在一起并独立出来。

​		**将这段代码放进一个独立函数中，并让函数名称解释该函数的用途。**

### 动机

​		Extract Method (110)（提炼函数）是我最常用的重构手法之一。当我看见一个过长的函数或者一段需要注释才能让人理解用途的代码，我就会将这段代码放进一个独立函数中。

​		有几个原因造成我喜欢简短而命名良好的函数。首先，如果每个函数的粒度都很小，那么函数被复用的机会就更大；其次，这会使高层函数读起来就像一系列注释；再次，如果函数都是细粒度，那么函数的覆写也会更容易些。

### 做法

​		创造一个新函数，根据这个函数的意图来对它命名（ 以它 “ 做什么 ” 来命名，而不是以它 “ 怎样做 ” 命名）。

​		即使你想要提炼的代码非常简单，例如只是一条消息或一个函数调用，只要新函数的名称能够以更好的方式昭示代码意图，你也应该提炼它。但如果你想不出一个更有意义的名称，就别动。

​		将提炼出的代码从源函数复制到新建的目标函数中。

​		仔细检查提炼出的代码，看看其中是否引用了 “ 作用域限于源函数 ” 的变量（ 包括局部变量和源函数参数 ）。

​		检查是否有 “ 仅用于被提炼代码段 ” 的临时变量。如果有，在目标函数中将它们声明为临时变量。

​		检查被提炼代码段，看看是否有任何局部变量的值被它改变。如果一个临时变量值被修改了，看看是否可以将被提炼代码段处理为一个查询，并将结果赋值给相关变量。如果很难这样做，或如果被修改的变量不止一个，你就不能仅仅将这段代码原封不动地提炼出来。你可能需要先使用 Split Temporary Variable (128)（分解临时变量），然后再尝试提炼。也可以使用 Replace Temp with Query (120)（以查询取代临时变量）将临时变量消灭掉。

​		将被提炼代码段中需要读取的局部变量，当作参数传给目标函数。

​		处理完所有局部变量之后，进行编译。

​		在源函数中，将被提炼代码段替换为对目标函数的调用。

​		如果你将任何临时变量移到目标函数中，请检查它们原本的声明式是否在被提炼代码段的外围。如果是，现在你可以删除这些声明式了。

​		编译，测试。

​		“ 如果需要返回的变量不止一个，又该怎么办呢？”

​		有几种选择。最好的选择通常是：挑选另一块代码来提炼。我比较喜欢让每个函数都只返回一个值，所以会安排多个函数，用以返回多个值。如果你使用的语言支持 “ 出参数 ”（output parameter），可以使用它们带回多个回传值。但我还是尽可能选择单一返回值。

​		临时变量往往为数众多，甚至会使提炼工作举步维艰。这种情况下，我会尝试先运用 Replace Temp with Query (120)（以查询取代临时变量）减少临时变量。如果即使这么做了提炼依旧困难重重，我就会动用 Replace Method with Method Object (135)（以函数对象取代函数），这个重构手法不在乎代码中有多少临时变量，也不在乎你如何使用它们。

## 6.2. Inline Method（内联函数）

​		一个函数的本体与名称同样清楚易懂。

​		**在函数调用点插入函数本体，然后移除该函数**。

### 动机

​		本书经常以简短的函数表现动作意图，这样会使代码更清晰易读。但有时候你会遇到某些函数，其内部代码和函数名称同样清晰易读。也可能你重构了该函数，使得其内容和其名称变得同样清晰。果真如此，你就应该去掉这个函数，直接使用其中的代码。间接性可能带来帮助，但非必要的间接性总是让人不舒服。

​		另一种需要使用 Inline Method (117)（内联函数）的情况是：你手上有一群组织不甚合理的函数。你可以将它们都内联到一个大型函数中，再从中提炼出组织合理的小型函数。

​		实施 Replace Method with Method Object (135)（以函数对象取代函数）之前先这么做，往往可以获得不错的效果。你可以把所要的函数（有着你要的行为）的所有调用对象的函数内容都内联到函数对象中。比起既要移动一个函数、又要移动它所调用的其他所有函数，将整个大型函数作为整体来移动会比较简单。

​		如果别人使用了太多间接层，使得系统中的所有函数都似乎只是对另一个函数的简单委托，造成我在这些委托动作之间晕头转向，那么我通常都会使用 Inline Method (117)（内联函数）。当然，间接层有其价值，但不是所有间接层都有价值。试着使用内联手法，我可以找出那些有用的间接层，同时将那些无用的间接层去除。

### 做法

​		检查函数，确定它不具多态性。

​		如果子类继承了这个函数，就不要将此函数内联，因为子类无法覆写一个根本不存在的函数。

​		找出这个函数的所有被调用点。

​		将这个函数的所有被调用点都替换为函数本体。

​		编译，测试。

​		删除该函数的定义。

## 6.3. Inline Temp（内联临时变量）

​		你有一个临时变量，只被一个简单表达式赋值一次，而它妨碍了其他重构手法。

​		**将所有对该变量的引用动作，替换为对它赋值的那个表达式自身。**

### 动机

​		Inline Temp (119)（内联临时变量）多半是作为 Replace Temp with Query (120)（以查询取代临时变量）的一部分使用的，所以真正的动机出现在后者那儿。唯一单独使用 Inline Temp (119)（内联临时变量）的情况是：你发现某个临时变量被赋予某个函数调用的返回值。一般来说，这样的临时变量不会有任何危害，可以放心地把它留在那儿。但如果这个临时变量妨碍了其他的重构手法，例如 Extract Method (110)（提炼函数），你就应该将它内联化。

### 做法

​		检查给临时变量赋值的语句，确保等号右边的表达式没有副作用。

​		如果这个临时变量并未被声明为 final，那就将它声明为 final，然后编译。

​		这可以检查该临时变量是否真的只被赋值一次。

​		找到该临时变量的所有引用点，将它们替换为 “ 为临时变量赋值 ” 的表达式。

​		每次修改后，编译并测试。

​		修改完所有引用点之后，删除该临时变量的声明和赋值语句。

​		编译，测试。

## 6.4. Replace Temp with Query（以查询取代临时变量）

​		你的程序以一个临时变量保存某一表达式的运算结果。

​		**将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。**

### 动机

​		临时变量的问题在于：它们是暂时的，而且只能在所属函数内使用。由于临时变量只在所属函数内可见，所以它们会驱使你写出更长的函数，因为只有这样你才能访问到需要的临时变量。如果把临时变量替换为一个查询，那么同一个类中的所有函数都将可以获得这份信息。这将带给你极大帮助，使你能够为这个类编写更清晰的代码。

​		Replace Temp with Query (120)（以查询取代临时变量）往往是你运用 Extract Method (110)（提炼函数）之前必不可少的一个步骤。局部变量会使代码难以被提炼，所以你应该尽可能把它们替换为查询式。

​		这个重构手法较为简单的情况是：临时变量只被赋值一次，或者赋值给临时变量的表达式不受其他条件影响。其他情况比较棘手，但也有可能发生。你可能需要先运用 Split Temporary Variable (128)（分解临时变量）或 Separate Query from Modifier (279)（将查询函数和修改函数分离）使情况变得简单一些，然后再替换临时变量。如果你想替换的临时变量是用来收集结果的（例如循环中的累加值），就需要将某些程序逻辑（例如循环）复制到查询函数去。

### 做法

​		首先是简单情况：

​		找出只被赋值一次的临时变量。

​		如果某个临时变量被赋值超过一次，考虑使用 Split Temporary Variable (128)（分解临时变量）将它分割成多个变量。

​		将该临时变量声明为 final。

​		编译。

​		这可确保该临时变量的确只被赋值一次。

​		将 “ 对该临时变量赋值 ” 之语句的等号右侧部分提炼到一个独立函数中。

​		首先将函数声明为 private。日后你可能会发现有更多类需要使用它，那时放松对它的保护也很容易。

​		确保提炼出来的函数无任何副作用，也就是说该函数并不修改任何对象内容。如果它有副作用，就对它进行 Separate Query from Modifler (279)（将查询函数和修改函数分离）。

​		编译，测试。

​		在该临时变量身上实施 Inline Temp (119)（内联临时变量）。

​		我们常常使用临时变量保存循环中的累加信息。在这种情况下，整个循环都可以被提炼为一个独立函数，这也使原本的函数可以少掉几行扰人的循环逻辑。有时候，你可能会在一个循环中累加好几个值。这种情况下你应该针对每个累加值重复一遍循环，这样就可以将所有临时变量都替换为查询。当然，循环应该很简单，复制这些代码时才不会带来危险。

​		运用此手法，你可能会担心性能问题。和其他性能问题一样，我们现在不管它，因为它十有八九根本不会造成任何影响。若是性能真的出了问题，你也可以在优化时期解决它。代码组织良好，你往往能够发现更有效的优化方案：如果没有进行重构，好的优化方案就可能与你失之交臂。如果性能实在太糟糕，要把临时变量放回去也是很容易的。

## 6.5. Introduce Explaining Variable（引入解释性变量）

​		你有一个复杂的表达式。

​		**将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。**

### 动机

​		表达式有可能非常复杂而难以阅读。这种情况下，临时变量可以帮助你将表达式分解为比较容易管理的形式。

​		在条件逻辑中，Introduce Explaining Variable (124)（引入解释性变量）特别有价值：你可以用这项重构将每个条件子句提炼出来，以一个良好命名的临时变量来解释对应条件子句的意义。使用这项重构的另一种情况是，在较长算法中，可以运用临时变量来解释每一步运算的意义。

​		Introduce Explaining Variable (124)（引入解释性变量）是一个很常见的重构手法，但我得承认，我并不常用它。我几乎总是尽量使用 Extract Method (110)（提炼函数）来解释一段代码的意义。毕竟临时变量只在它所处的那个函数中才有意义，局限性较大，函数则可以在对象的整个生命中都有用，并且可被其他对象使用。但有时候，当局部变量使 Extract Method (110)（提炼函数）难以进行时，我就使用 Introduce Explaining Variable (124)（引入解释性变量）。

### 做法

​		声明一个 final 临时变量，将待分解之复杂表达式中的一部分动作的运算结果赋值给它。

​		将表达式中的 “ 运算结果 ” 这一部分，替换为上述临时变量。

​		如果被替换的这一部分在代码中重复出现，你可以每次一个，逐一替换。

​		编译，测试。

​		重复上述过程，处理表达式的其他部分。

​		我比较喜欢使用 Extract Method (110)（提炼函数），因为同一对象中的任何部分，都可以根据自己的需要取用这些提炼出来的函数。一开始我会把这些新函数声明为 private；如果其他对象也需要它们，我可以轻易释放这些函数的访问限制。我还发现，Extract Method (110)（提炼函数）的工作量通常并不比 Introduce Explaining Variable (124)（引入解释性变量）来得大。

​		那么，应该在什么时候使用 Introduce Explaining Variable (124)（引入解释性变量）呢？答案是：在 Extract Method (110)（提炼函数）需要花费更大工作量时。如果我要处理的是一个拥有大量局部变量的算法，那么使用 Extract Method (110)（提炼函数）绝非易事。这种情况下就会使用 Introduce Explaining Variable (124)（引入解释性变量）来理清代码，然后再考虑下一步该怎么办。搞清楚代码逻辑之后，我总是可以运用 Replace Temp with Query (120)（以查询取代临时变量）把中间引入的那些解释性临时变量去掉。况且，如果我最终使用 Replace Method with Method Object (135)（以函数对象取代函数），那么中间引入的那些解释性临时变量也有其价值。

## 6.6. Split Temporary Variable（分解临时变量）

​		你的程序有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。

​		**针对每次赋值，创造一个独立、对应的临时变量。**

### 动机

​		临时变量有各种不同用途，其中某些用途会很自然地导致临时变量被多次赋值。“ 循环变量 ” 和 “ 结果收集变量 ” 就是两个典型例子：循环变量 ( loop variable ）[Beck] 会随循环的每次运行而改变（ 例如 for(int i=0; i<10; i++) 语句中的 i）；结果收集变量（collecting temporary variable）[Beck] 负责将 “ 通过整个函数的运算 ” 而构成的某个值收集起来。

​		除了这两种情况，还有很多临时变量用于保存一段冗长代码的运算结果，以便稍后使用。这种临时变量应该只被赋值一次。如果它们被赋值超过一次，就意味它们在函数中承担了一个以上的责任。如果临时变量承担多个责任，它就应该被替换（分解）为多个临时变量，每个变量只承担一个责任。同一个临时变量承担两件不同的事情，会令代码阅读者糊涂。

### 做法

​		在待分解临时变量的声明及其第一次被赋值处，修改其名称。

​		如果稍后之赋值语句是 [ i=i+某表达式 ] 形式，就意味这是个结果收集变量，那么就不要分解它。结果收集变量的作用通常是累加、字符串接合、写入流或者向集合添加元素。

​		将新的临时变量声明为 final。

​		以该临时变量的第二次赋值动作为界，修改此前对该临时变量的所有引用点，让它们引用新的临时变量。

​		在第二次赋值处，重新声明原先那个临时变量。

​		编译，测试。

​		逐次重复上述过程。每次都在声明处对临时变量改名，并修改下次赋值之前的引用点。

## 6.7. Remove Assignments to Parameters（移除对参数的赋值）

​		代码对一个参数进行赋值。

​		**以一个临时变量取代该参数的位置。**

### 动机

​		在 Java 中，不要对参数赋值：如果你看到手上的代码已经这样做了，请使用 Remove Assignments to Parameters (131)（移除对参数的赋值）。

### 做法

​		建立一个临时变量，把待处理的参数值赋予它。

​		以 “ 对参数的赋值 ” 为界，将其后所有对此参数的引用点，全部替换为 “ 对此临时变量的引用 ”。

​		修改赋值语句，使其改为对新建之临时变量赋值。

​		编译，测试。

​		如果代码的语义是按引用传递的，请在调用端检查调用后是否还使用了这个参数。也要检查有多少个按引用传递的参数被赋值后又被使用。请尽量只以 return 方式返回一个值。如果需要返回的值不止一个，看看可否把需返回的大堆数据变成单一对象，或干脆为每个返回值设计对应的一个独立函数。

### Java的按值传递

​		Java 使用按值传递的函数调用方式，这常常造成许多人迷惑。在所有地点，Java 都严格采用按值传递方式，

​		从本质上说，对象的引用是按值传递的。因此，我可以修改参数对象的内部状态，但对参数对象重新赋值是没有意义的。

## 6.8. Replace Method with Method Object（以函数对象取代函数）

​		你有一个大型函数，其中对局部变量的使用使你无法采用 Extract Method (110)（提炼函数）。

​		**将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数。**

### 动机

​		只要将相对独立的代码从大型函数中提炼出来，就可以大大提高代码的可读性。

​		但是，局部变量的存在会增加函数分解难度。如果一个函数之中局部变量泛滥成灾，那么想分解这个函数是非常困难的。Replace Temp with Query (120)（以函数对象取代函数）可以助你减轻这一负担，但有时候你会发现根本无法拆解一个需要拆解的函数。这种情况下，你应该把手伸进工具箱的深处，祭出函数对象（method object）[Beck] 这件法宝。

​		Replace Method with Method Object (135)（以函数对象取代函数）会将所有局部变量都变成函数对象的字段。然后你就可以对这个新对象使用 Extract Method (110)（提炼函数）创造出新函数，从而将原本的大型函数拆解变短。

### 做法

​		建立一个新类，根据待处理函数的用途，为这个类命名。

​		在新类中建立一个 final 字段，用以保存原先大型函数所在的对象。我们将这个字段称为 “ 源对象 ”。同时，针对原函数的每个临时变量和每个参数，在新类中建立一个对应的字段保存之。

​		在新类中建立一个构造函数，接收源对象及原函数的所有参数作为参数。

​		在新类中建立一个 compute() 函数。

​		将原函数的代码复制到 compute() 函数中。如果需要调用源对象的任何函数，请通过源对象字段调用。

​		编译。

​		将旧函数的函数本体替换为这样一条语句：“ 创建上述新类的一个新对象，而后调用其中的 compute() 函数 ”。

​		现在进行到很有趣的部分了。因为所有局部变量现在都成了字段，所以你可以任意分解这个大型函数，不必传递任何参数。

## 6.9. Substitute Algorithm（替换算法）

​		你想要把某个算法替换为另一个更清晰的算法。

​		**将函数本体替换为另一个算法。**

### 动机

​		如果你发现做一件事可以有更清晰的方式，就应该以较清晰的方式取代复杂的方式。

​		“ 重构 ” 可以把一些复杂东西分解为较简单的小块，但有时你就必须壮士断腕，删掉整个算法，代之以较简单的算法。随着对问题有了更多理解，你往往会发现，在原先的做法之外，有更简单的解决方案，此时你就需要改变原先的算法。如果你开始使用程序库，而其中提供的某些功能/特性与你自己的代码重复，那么你也需要改变原先的算法。

​		有时候你会想要修改原先的算法，让它去做一件与原先略有差异的事。这时候你也可以先把原先的算法替换为一个较易修改的算法，这样后续的修改会轻松许多。

​		使用这项重构手法之前，请先确定自己已经尽可能分解了原先函数。替换一个巨大而复杂的算法是非常困难的，只有先将它分解为较简单的小型函数，然后你才能很有把握地进行算法替换工作。

### 做法

​		准备好另一个（替换用）算法，让它通过编译。

​		针对现有测试，执行上述的新算法。如果结果与原本结果相同，重构结束。

​		如果测试结果不同于原先，在测试和调试过程中，以旧算法为比较参照标准。

​		对于每个测试用例，分别以新旧两种算法执行，并观察两者结果是否相同。

​		这可以帮助你看到哪一个测试用例出现麻烦，以及出现了怎样的麻烦。
