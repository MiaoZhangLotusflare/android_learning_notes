# 第 14 章 重构工具

​		重构的最大障碍之一就是：几乎没有工具对它提供支持。那些把重构作为文化成分之一的语言（ 例如 Smalltalk ）通常都提供了强大的开发环境，其中对代码重构的众多必要特性都提供了支持。但即使是这样的环境，到目前为止，也只是对重构过程提供了部分支持，绝大部分工作仍然得靠手工完成。 

## 14.1. 使用工具进行重构

​		和手工重构相比，自动化工具所支持的重构，给人一种完全不同的感觉。即使有测试套件织成的安全网，手工重构仍然是很耗时的工作。正是这个简单的事实造成很多程序员不愿进行重构，尽管他们知道自己应该重构，但毕竟重构的成本太大了。如果能够把重构变得像调整代码格式那么简单，程序员自然也会乐意像整理代码外观那样去整理系统的设计。而这样的整理对代码的可维护性、可复用性和可理解性，都能够带来深远的正面影响。Kent Beck 如是说。 ——Kent Beck

​		Refactoring Browser 将会完全改变你的编程思路。以前你可能会想：“呃，我应该修改这个名字，但……” 现在，所有这些让你烦心的事情都烟消云散了，因为 Refactoring Browser 里有个菜单选项就是专门用来改名的，你只管放心用它就是了。

​		随着重构成本的降低，设计错误也不再像从前那样带来昂贵代价了。由于弥补设计错误所需的成本降低了，需要预先做的设计也就更少了。预先设计是一项带有预测性质的工作，因为项目激活之时，需求往往还不明朗。由于设计时尚未编写代码，所以正确的设计方式应该是：尽量简化需求尚未明朗的那一部分代码。过去，无论最初的设计方案水平如何，我们都不得不忍受，因为修改设计的代价实在太高了。有了自动化重构工具的帮助，我们可以让设计更具可变性，因为修改设计不再需要付出那么高的代价了。如今，我们可以只对当前完全了解的问题进行设计，因为我们知道以后可以很方便地扩展设计方案以加入额外的灵活性。我们不再需要预测系统未来所有可能的修改。如果发现当前的设计给编程带来麻烦，造成第 3 章所说的坏味道，我们可以很快修改设计，使代码更干净、更可维护。

​		工具辅助下的重构工作，也影响了测试。拥有自动化重构工具的辅助之后，所需测试少多了，因为很多重构都可以自动进行，无需再做测试。当然，总有一些重构是无法自动进行的，因此测试步骤永远都不可能被完全忽略。经验显示：在自动化重构工具的协助下，我们每天所需运行的测试数量，和在无自动化重构工具的环境中大致相当，但完成的重构数量则大大增加。

​		正如 Martin 指出，Java 也需要这样的自动化重构工具。以下我们将提出一些准则——只有满足这些准则的自动化重构工具，才是成功的工具。尽管也提到了技术方面的准则，但我们相信，实用性方面的准则重要得多。

## 14.2. 重构工具的技术标准

​		重构工具最主要的用途就是让程序员可以不必重新测试，便能对代码进行重构。即使有了自动化测试工具，测试仍然是很费时间的，如果能完全避免测试，将可极大加快重构过程。本节简短讨论重构工具的技术标准。唯有满足这些标准，重构工具才能在保持程序行为的前提下，对程序进行改造。

### 程序数据库

​		对于重构工具，最早被人们所认识的需求就是贯穿整个程序搜索各种程序元素的能力。例如，对于某个特定函数，找出其所有可能被调用点；对于某个特定的实例变量，找到读/写该变量的所有函数。在 Smalltalk 这样紧密集成的环境中，这类信息总是被维护为一种便于搜索的格式。这不是传统意义上的数据库，但的确是一个可搜索的数据库。程序员只需执行一次搜索动作，就可以找到任何程序元素的交叉引用。这种能力主要源自代码的动态编译机制：当任何一个类被修改，就立刻被编译为字节码，而上述的数据库则同时得到更新。在较为静态的开发环境（如 Java ）中，程序员是把代码输入到文本文件中。这种环境下如果要更新程序数据库，就必须运行一个程序来处理这些文本文件，从中提炼相关信息。这样的更新过程和 Java 代码自身的编译过程很相似。一些比较先进的开发环境（例如 IBM VisualAge for Java）则模仿了 Smalltalk 的程序数据库动态更新机制。

​		有一种原始的做法是：以诸如 grep 之类的文本处理工具来进行搜索。这种办法很快就归于失败，因为它无法区分名为 foo 的变量和名为 foo 的函数。要建立程序数据库，就必须借助语义分析来判断程序中每个语汇单元在语句中的地位。而且这种分析在类定义和函数定义两层面上都不可少：在类定义层面上，需要以语义分析来区分实例变量和函数；在函数定义层面上，需要以语义分析来区分实例变量和函数引用。

### 解析树

​		绝大多数重构都必须处理函数层面下的一部分系统，通常是对被修改程序元素的引用。举个例子，如果某个实例变量被改名，那么其所属类及其子类中对于该实例变量的所有引用都必须更新。有些重构手法则整个运作于函数层面下，例如将某个函数的一部分提炼为一个独立函数。由于对函数的任何修改都必须能够处理函数结构，因此我们需要解析树的帮助。这是一种数据结构，可用以表现函数的内部结构。

### 准确性

​		由工具实现的重构，必须合理保持程序原有行为。当然，完全的行为保持是不可能达到的，重构总是会给程序带来一些细微改变。例如重构可能会对程序的运行速度带来数个微秒的变化，这算是 “ 完全的行为保持 ” 吗？通常这般微小差异不会对程序造成影响。但如果程序有严格的实时性要求，这一点点差异就可能导致整个程序出错。

​		即使是传统程序（而非实时系统）也可能被重构破坏。假设你的程序建构了一个字符串，然后使用 Java 反射 API 执行以这个字符串命名的函数，那么如果日后你修改这个函数的名称，程序就会抛出一个异常。重构前的程序不会这样做。

​		然而，对绝大多数程序来说，重构可以相当准确。只要可能破坏重构准确性的因素都被识别出来，重构技术员就可以避免在不适当时候进行重构，也可以避免对于重构工具无法修补的程序错误地进行手工修补。

## 14.3. 重构工具的实用标准

​		工具之所以被创造出来，是为了帮助人们完成工作。如果工具不能适应人们的工作方式，人们就不会使用它。重构工具的最重要要求就是：和其他工具共同集成出重构过程。

### 速度

​		重构前的分析和必要调整，可能会耗费较多时间，因为它们有可能非常复杂。工具设计者必须考虑这些前期工作对时间和准确性的影响。如果重构前需要大量准备工作，程序员就不会使用自动化重构工具，他们宁可手工进行重构。是的，开发速度总是很重要的。

​		如果重构前的分析需要花费太长时间，一个简单的解决办法就是：直接询问程序员你所需要的信息。这种办法把保证准确性的责任交给了程序员，于是分析过程可以进行得更快一些。很多时候程序员其实都知道必要信息。尽管这种办法可能不够安全（因为程序员有可能犯错），但出错的责任也一部分落在了程序员肩上。讽刺的是，这竟然使程序员更有可能使用这些工具，因为他们无需倚赖程序的试错来收集信息。

### 撤销

​		自动化重构令开发者得以采用探索方式进行设计：你可以试着把代码移到他处，观察新设计方案是否有效。由于我们假设重构都能够保持程序的原本行为，所以反向重构（亦即对原重构的撤销）也应该不影响程序的原本行为。Refactoring Browser 的早期版本并没有撤销功能，这使用户无法对重构充满信心。重构的撤销相当困难。但是很多时候我们偏偏必须找出程序重构前的版本，重新开始，这可真够讨厌的。于是我们后来为 Refactoring Browser 加上了撤销功能，从而又克服了一个障碍。现在，我们可以放心尝试，不会遭受任何惩罚，因为我们总是可以回到原先的任何一个版本。我们可以建立新的类、搬移函数、观察代码的行为，而后又改变想法，走另一个完全不同的方向。这一切都可以非常快速地完成。

### 与其他工具集成

​		过去十年以来，集成开发环境（IDE）已经成为绝大多数开发项目的核心工具。IDE 将编辑器、编译器、连接器、调试器以及程序开发所需的其他所有工具，都集成于一起，开发者可以在同一个环境中极方便地使用所有这些工具。Refactoring Browser for Smalltalk 早期版本是一个独立于标准 Smalltalk 开发工具之外的工具，我们发现根本没人使用这样的产品，就连我们自己都不用。但是把重构功能直接集成到 Smalltalk Browser 之后，我们就开始经常使用它。工具是否触手可及造成了这一切的不同。

## 14.4. 小结

​		要想控制软件项目演化过程中产生的复杂度，使用自动化重构工具是最好的办法。如果没有合适工具协助我们解决那些复杂度，软件就会变得臃肿不堪、错漏百出、不堪一击。
