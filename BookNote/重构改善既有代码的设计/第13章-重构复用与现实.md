# 第 13 章 重构复用与现实

## 13.1. 现实的检验

​		随着与一线开发人员的交谈越来越多，我开始明白为什么以前的演讲不能感染别人。我与听众的距离有一部分是因为面向对象技术自身就很新。那些使用它工作的人多半都还没有完成第一个版本的开发，所以还没有遇到 “ 演化 ” 这个大问题，而这个问题是重构能够帮忙解决的。这是研究人员的典型尴尬处境——技术的发展超前于实践。但是，造成这种距离，还有另一个讨厌的原因。有一些常识性原因影响了开发者，所以即使他们了解重构的好处，也不情愿对自己的程序进行重构。如果要让重构得到开发者的拥抱，首先必须解决这些问题。

## 13.2. 为什么开发者不愿意重构他们的程序

​		更多时候，你需要对既有软件进行扩展，你对自己所做的事情没有完整的了解，你受到生产进度的压力。这种情况下你该怎么办？

​		你可以重写整个程序。你可以倚赖自己的设计经验来纠正程序中存在的错误，这是创造性的工作，也很有趣。但谁来付钱呢？你又如何保证新的系统能够完成旧系统所做的每一件事呢？

​		你可以复制、修改现有系统的一部分，以扩展它的功能。这看上去也许很好，甚至可能被看做一种复用方式：你甚至不必理解自己复用的东西。但是，随着时间流逝，错误会不断地被复制、被传播，程序变得臃肿，程序的当初设计开始腐败变质，修改的整体成本逐渐上升。

​		重构是上述两个极端的中庸之道。通过重新组织软件结构，重构使得设计思路更详尽明确。重构被用于开发框架、抽取可复用组件、使软件架构更清晰、使新功能的增加更容易。重构可以帮助你充分利用以前的投资，减少重复劳动，使程序更简洁有力。

​		为什么还不肯重构你的程序呢？有以下几个可能的原因。

1. 你不知道如何重构。

2. 如果这些利益是长远的，何必现在付出这些努力呢？长远看来，说不定当项目收获这些利益时，你已经不在职位上了。

3. 代码重构是一项额外工作，老板付钱给你，主要是让你编写新功能。

4. 重构可能破坏现有程序。

### 如何重构，在哪里重构

​		面对一个既有程序，我们该使用哪些重构呢？当然，这取决于你的目标。一个常见的重构原因，同时也是本书关注焦点，是调整程序结构以使（短期内）添加新功能更容易。

​		自动化工具可用来识别程序中的结构缺陷，例如函数参数过多、函数过长等。这些都应该考虑成为重构的对象。自动化工具还可以识别出结构上的相似，这样的相似很可能代表着冗余代码的存在。

​		对设计模式的很多研究，都集中于良好编程风格以及程序各部分之间有用的交互模式，而这些都可以映射为结构特征和重构手法。

​		在程序员说服自己 “ 我应该重构我的代码 ” 之前，他们需要先了解如何重构、在哪里重构。经验是无可替代的。研究过程中，我们得益于经验丰富的面向对象开发者的经验，得到了一些有用的重构做法，以及 “ 该在哪里使用这些重构 ” 的认识。自动化工具可以分析程序结构，建议可能改进程序结构的重构做法。和其他大多数学科一样，工具和技术会带来帮助，但前提是你打算使用它们。重构过程中，程序员自己对重构的理解也会逐渐加深。

### 对重构有支持能力的语言特性和编程风格

​		重构时，你必须找出待重构的这一部分程序被什么地方引用。C++ 的静态类型特性让你可以比较容易地缩小搜索范围。

​		在十分庞大的程序中，不同地点有可能声明一些同名函数。有时候，两个或多个同名函数以同一个函数取代可能更好，某些重构手法可用来做这种修改；有时候则应该给两个同名函数中的一个改名，让另一个保持原来名称。如果项目开发成员不只一人，不同的程序员可能给风马牛不相及的函数取相同的名称。在 C++ 中，当你对两个同名函数中的一个改名之后，几乎总是很容易找到哪些引用点针对的是这个被易名函数，哪些引用点针对的是另一个函数。这种分析在 Smalltalk 中要困难得多。

​		由于 C++ 以继承方式来实现 “ 子类型 ” 的概念，所以通常可以通过将变量或函数在继承体系中移上移下来扩大（普通化）或缩小（特殊化）其作用域。对程序做这一类分析并进行相应重构，都是很简单的。

​		如果在最初开发和整个开发过程中一直遵循一些良好的设计原则，那么重构过程会更轻松，软件的进化会更容易。“ 将所有成员变量和大多数成员函数定义为 private 或 protected ” 作为一种抽象技术，常常使类的内部重构更简单，因为对程序其他地方造成的影响被减至最低。以继承机制表现 “ 普通化和特殊化 ” 体系（ 这在 C++ 中很自然 ），也使日后 “ 泛化或特化成员变量或成员函数 ” 的重构动作更容易进行，你只需在继承体系内上下移动这些成员即可。

### 增加重构复杂度的语言特性和编程风格

​		程序如果使用诸如指针、转型操作和 sizeof(object) 之类的 C++ 特性，将难以重构。指针和转型操作会造成别名，使你很难找到待重构对象的所有被引用点。上述这些特性暴露了对象的内部表现形式，违反了抽象原则。

### 结语

​		很多时候，重构技术可以（并且已经）应用于 C++ 程序。C++ 程序员通常希望自己的程序能在未来数年中不断演化进步，而软件演化过程正是最能凸显重构的好处。C++ 语言提供的某些特性可以简化重构，但另一些特性会使重构变得困难。幸运的是，程序员已经公认：使用诸如指针运算之类的语言特性并不是好主意。大多数优秀的面向对象程序员都会避免使用它们。

### 重构以求短期利益

​		要说明重构有哪些中长期好处是比较容易的。但许多公司受到来自投资方日益沉重的压力，不得不追求短期成绩。重构可以在短期之内带来惊喜吗？

​		那些经验丰富的面向对象开发者，成功运用重构已经有十多年的历史了。在强调代码简洁明了、复用性高的 Smalltalk 文化中，许多程序员都变得成熟了。在这样的文化中，程序员会投入时间去进行重构，因为他应该这样做。Smalltalk 语言和实现使得重构成为可能，这是过去绝大多数语言和开发环境都没有能够做到的。

​		一个例子是 Choices 文件系统框架。最初这个框架实现了 BSD Unix 文件系统格式。后来它又被扩展支持 Unix System V、MS-DOS、持久化和分布式文件系统。框架开发者采用的办法是：先把实现 BSD Linux 的部分原样复制一份过来，然后修改它，使它支持 System V。系统最终可以有效运作，但充斥大量重复的代码。加入新代码后，框架开发者重构了这些代码，建立抽象超类容纳两个 Unix 文件系统的共通行为。相同的变量和函数被移到超类中。当两个对应函数几乎但不完全相同时，他们就在子类中定义新函数来包容两者不同之处，然后在原先函数里把这些代码换成对新函数的调用。这样一来，两个子类的代码就逐渐变得越来越相似了。一旦两个函数变得完全相同，就可以将它们搬移到共同的超类去。

​		这些重构手法为开发者提供了多方面好处，既有短期利益，也有长期利益。短期来看，如果在测试阶段发现共同的代码有错误，只需在一个地方修改就行了。代码总量变少了。“ 某一文件系统特有的行为 ” 与 “ 两种文件系统共有的行为 ” 清晰地分开了，这使得追踪、修补某种文件系统格式特有的行为更加容易。中期来看，重构得到的抽象层对于定义后续文件系统常常很有帮助。当然，现有的两种文件系统格式的共通行为未必就完全适用于第三种文件格式，但现有的共享基础是一个很有价值的起点。后继的重构动作可以澄清究竟哪些东西真正是所有文件系统共有的。框架开发团队发现：随着时间流逝，支持新文件系统格式越来越省劲。就算新的格式更复杂、开发团队经验更浅，情况也一样。

### 降低重构带来的开销

​		目前已有一些工具和技术，可以使重构快速而相对无痛苦地完成。

​		一些面向对象程序员的经验显示，重构虽然需要开销，但它能在程序开发的其他阶段降低精力和时间开销，从而补偿它的开销。

​		尽管乍见之下重构可能有点笨拙、开销太大，但是当它成为软件开发规则的一部分，人们就不会再觉得它费事，反而开始觉得它是必不可少的。

​		伊利诺伊大学的软件重构团队开发的 Smalltalk 自动化重构工具也许是目前最成熟的自动化重构工具（参见第14章）。你可以从他们的网站（[http://st-www.cs.uiuc.edu](http://st-www.cs.uiuc.edu/)）自由下载这个工具。

### 安全地进行重构

​		安全性是令人关心的议题，特别对于那些开发、维护大型系统的组织更是如此。许多应用程序背负着财政、法律和道德伦理方面的压力，必须提供不间断的、可靠的、不出错的服务。有许多组织提供大量培训和努力，力图以严谨的开发过程来帮助他们保证产品的安全性。

​		安全性是一个很难定义的概念。直观的定义是：所谓 “ 安全重构 ” 就是不会对程序造成破坏的重构。由于重构的意图就是在不改变程序行为的前提下修改程序结构，所以重构后的程序行为应该与重构前完全相同。

​		如何进行安全重构呢？你有以下几种选择。

​		相信你自己的编码功力。

​		相信你的编译器能捕捉你遗漏的错误。

​		相信你的测试套件能捕捉你和编译器都遗漏的错误。

​		相信代码复审能捕捉你、编译器和测试套件都遗漏的错误。

​		我在研究工作中使用的另一种方法是：定义并快速实现一个重构工具的原型，用以检查某项重构是否可以安全地施加于程序身上。如果可以，就重构之。这避免了大量可能因为人为错误而引入的 bug。

​		我的重构工具的一部分是程序分析器，这是一个用来分析程序结构的程序（ 被分析的对象是将来打算施加某项重构的一个 C++ 程序 ）。这个工具可以解答一系列问题，内容涉及作用域、类型和程序语义（ 程序的意图或用途 ）等方面。作用域的问题与继承有关，所以这一分析过程比起很多非面向对象程序分析要复杂；但 C++ 的某些语言特性（ 例如静态类型 ）又使得这一分析过程比起对 Smalltalk 等动态类型程序的分析要简单。

​		在我的研究中，我把 “ 安全 ” 定义为：程序属性（包括作用域和类型等）在重构之后仍然保持不变。很多程序属性很像数据库中的完整性约束——修改数据库结构时，完整性约束必须保持不变。每个重构都伴随一组必要前提，如果这些前提得到满足，该重构就能保证程序属性获得维持。一旦确定某次重构的全部过程都安全，我的工具才会执行该次重构。

​		幸运的是，对于重构安全性进行的检查（ 尤其是对于数量占绝对优势的低层重构 ）往往是轻而易举的。为了保证较高层重构、较复杂重构的安全性，我们以低层重构来定义它们。例如 “ 建立一个抽象超类 ” 的复杂重构手法就被定义为几个较小步骤，每个步骤都以较简单的重构完成，像是创建和搬移变量或函数等等。只要证明复杂重构的每一个步骤是安全的，我们就可以确定整个复杂重构也是安全的。

​		在某些十分罕见的情况下，在工具无法确认时，仍然可以安全施行重构。此时，工具会选择较安全的方式：禁止重构。拿先前例子来说，你想删除程序中的某个变量，但程序其他地方对该变量有引用动作。然而或许这个引用动作所处段落永远不会被执行到，例如它也许出现于条件表达式（ 如 if-then ）中，而它所处分支永远不为真。如果肯定这个分支永远不为真，你可以移除它，连同那个影响你重构的引用点一并移除。然后你就可以安全地进行重构，删除想删除的变量或函数了。只不过，一般情况下你无法肯定分支永远为假——如果你继承了别人开发的代码，你有多大把握安全删掉其中某段代码？

​		重构工具可以标记出这种可能不安全的引用关系，并向用户提出警告。用户可以先把这段代码放在一旁。一旦能够肯定引用点永远不会被执行到，他就可以把这段多余代码移除，而后进行重构。这个工具让用户知道存在这么一个隐藏的引用关系，而不是盲目地进行修改。

​		所有这些安全性检查都可以在重构工具中实现。如果程序员想要重构一个程序，只需以这个工具检查其代码。如果检查结果为 “ 安全 ”，就执行重构。

​		重构的安全性可以分为很多级别。有些重构很容易实施，但安全性较低。使用重构工具有很多好处。它可以帮我们做许多简单而乏味的检查，并标记出一些埋藏较深的问题。如果不做这些检查，重构动作有可能导致程序完全崩溃。

​		编译、测试和代码复审可以指出很多错误，但也会遗漏一些错误，重构工具则可以帮助你抓住漏网之鱼。尽管如此，编译、测试和代码复审仍然是很有价值的，在实时系统的开发和维护中更是如此。这些系统中的程序往往不是孤立运行的，它们是大型通信系统网络中的一部分。有些重构不但把代码清扫干净，而且会让程序跑得更快。然而提升某个程序的速度，可能会在另一个地方造成性能瓶颈。这就好像你升级 CPU 进而提升了部分系统性能，你需要以类似方法来调整、测试系统整体性能。另一方面，有些重构也可能略微降低系统整体性能。一般说来，重构对性能的影响是微不足道的。

​		“ 安全性措施 ” 用来保证重构不会向程序引入新错误。这些措施并不能检查或修复程序重构前就存在的错误。但重构可以使你更容易找到并修复这些错误。

## 13.3. 再论现实的检验

​		对于某些项目，以下问题也是需要关心的。

​		如果代码由多位程序员共同拥有，怎么办？一方面，许多传统的变更管理机制都可以解决这个问题；另一方面，如果软件设计良好，又经过重构，子系统之间就会有效分离，于是很多重构手法都只会影响代码的一小部分。

​		如果你的代码库中有多个分支版本的代码，怎么办？有些时候，重构和每一个分支相关，这种情况下我们必须在重构前先对所有分支进行安全测试。另一些时候，重构可能只与某些分支相关，那么，检查过程和重构过程就简单多了。如果打算同时管理多个分支变化，通常需要使用许多传统的版本管理技术。如果想将多个分支并入一个新的代码库中，重构也会有所帮助，因为它有可能简化合并工作。

​		总而言之，“ 让软件开发者相信重构的实际价值 ” 和 “ 让博士论文评议委员会相信重构研究够得上博士水平 ” 是完全不同的两码事。在写完毕业论文以后，我又花了相当长的时间才对这种差异有了足够充分的认识。

## 13.4. 重构的资源和参考资料

​		《程序设计的模式语言》（Pattern Languages of Program Design）丛书第一卷的第 14 章 “ 生命周期以及支持演变和复用的重构模式 ” 是个不错的起点。

​		Smalltalk 程序重构。他们的网站（[http://st-www.cs.uiuc.edu](http://st-www.cs.uiuc.edu/)）上有其最新的研究成果。

## 13.5. 从重构联想到软件复用和技术传播

​		如果要成功适应复用方法，开销、学习曲线和探索成本都必须考虑。

​		采用复用方法不该引起项目混乱。项目中可能有很大压力：尽管面对遗留系统的束缚，仍应让现有资产或实现发挥作用。新的实现应该与现有系统协同工作，或至少向下兼容于现有系统。
