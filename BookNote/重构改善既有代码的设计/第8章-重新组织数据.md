# 第 8 章 重新组织数据

第8章 重新组织数据

Replace Value with Object (175)让你可以将“哑”数据变成善表达的对象。

如果你发现程序中有太多地方需要这一类对象，也可以使用Change Value to Reference (179)将它们变成引用对象。

如果你看到一个数组的行为方式很像一个数据结构，就可以使用Replace Array with Object (186)把数组变成对象，从而使这个数据结构更清晰地显露出来。但这只是第一步，当你使用Move Method (142)为这个新对象加入相应行为时，真正的好处才得以体现。

魔法数——也就是带有特殊含义的数字——从来都是个问题。我还清楚记得，一开始学习编程的时候，老师就告诉我不要使用魔法数。但它们还是不时出现。因此，只要弄清楚魔法数的用途，我就运用Replace Magic Number with Symbolic Constant (204)将它们除掉，以绝后患。

对象之间的关联可以是单向的，也

可以是双向的。单向关联比较简单，但有时为了支持一项新功能，你需要使用Change Unidirectional Association to Bidirectional (197)将它变成双向关联。Change Bidirectional Association to Unidirectional (200)则恰恰相反：如果你发现不再需要双向关联，可以使用这项重构将它变成单向关联。

面向对象编程的关键原则之一就是封装。如果一个类公开了任何public数据，你就应该使用Encapsulate Field (206)将它郑重地包装起来。如果被公开的数据是个集合，就应该使用Encapsulate Collection (208)，因为集合有其特殊协议。如果一整条记录都被裸露在外，就应该使用Replace Record with Data Class (217)。

8.1 Self Encapsulate Field（自封装字段）

需要特别对待的一种数据是类型码（type code）：这是一种特殊数值，用来指出“与实例所属之类型相关的某些东西”。类型码通常以枚举形式出现，并且通常以static final整数实现。如果这些类型码用来表现某种信息，并且不会改变所属类型的行为，你可以运用Replace Type Code with Class (218)将它们替换掉，这项重构会为你提供更好的类型检查，以及一个更好的平台，使你可以在未来更方便地将相关行为添加进去。另外，如果当前类型的行为受到类型码的影响，你就应该尽可能使用Replace Type Code with Subclasses (223)。如果做不到，就只好使用更复杂（同时也更灵活）的Replace Type Code with State/Strategy (227)。

你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙。为这个字段建立取值/设值函数，并且只以这些函数来访问字段。

动机

在“字段访问方式”这个问题上，存在两种截然不同的观点：其中一派认为，在该变量定义所在的类中，你可以自由访问它；另一派认为，即使在这个类中你也应该只使用访问函数间接访问

归根结底，间接访问变量的好处是，子类可以通过覆写一个函数而改变获取数据的途径；它还支持更灵活的数据管理方式，例如延迟初始化（意思是：只有在需要用到某值时，才对它初始化）。

直接访问变量的好处则是：代码比较容易阅读。阅读代码的时候，你不需要停下来说：“啊，这只是个取值函数。”

面临选择时，我总是做两手准备。通常情况下我会很乐意按照团队中其他人的意愿来做。就我自己而言，我比较喜欢先使用直接访问方式，直到这种方式给我带来麻烦为止，此时我就会转而使用间接访问方式。重构给了我改变主意的自由。

如果你想访问超类中的一个字段，却又想在子类中将对这个变量的访问改为一个计算后的值，这就是最该使用Self Encapsulate Field (171)的时候。“字段自我封装”只是第一步。完成自我封装之后，你可以在子类中根据自己的需要随意覆写取值/设值函数。

做法

为待封装字段建立取值/设值函数。

找出该字段的所有引用点，将它们全部改为调用取值/设值函数。

如果引用点要读取字段值，就将它替换为调用取值函数；如果引用点要给字段赋值，就将它替换为调用设值函数。

你可以暂时将该字段改名，让编译器帮助你查找引用点。

将该字段声明为private。

复查，确保找出所有引用点。

编译，测试。

使用本项重构时，你必须小心对待“在构造函数中使用设值函数”的情况。一般说来，设值函数被认为应该在对象创建后才使用，所以初始化过程中的行为有可能与设值函数的行为不同。这种情况下，我也许在构造函数

中直接访问字段，要不就是单独另建一个初始化函数：

8.2 Replace Data Value with Object（以对象取代数据值）

你有一个数据项，需要与其他数据和行为一起使用才有意义。将数据项变成对象。

动机

开发初期，你往往决定以简单的数据项表示简单的情况。但是，随着开发的进行，你可能会发现，这些简单数据项不再那么简单了。比如说，一开始你可能会用一个字符串来表示“电话号码”概念，但是随后你就会发现，电话号码需要“格式化”、“抽取区号”之类的特殊行为。如果这样的数据项只有一两个，你还可以把相关函数放进数据项所属的对象里；但是Duplicate Code坏味道和Feature Envy坏味道很快就会从代码中散发出来。当这些坏味道开始出现，你就应该将数据值变成对象。

做法

为待替换数值新建一个类，在其中声明一个final字段，其类型和源类中的待替换数值类型一样。然后在新类中加入这个字段的取值函数，再加上一个接受此字段为参数的构造函数。

编译。

将源类中的待替换数值字段的类型改为前面新建的类。

修改源类中该字段的取值函数，令

它调用新类的取值函数。

如果源类构造函数中用到这个待替换字段（多半是赋值动作），我们就修改构造函数，令它改用新类的构造函数来对字段进行赋值动作。

修改源类中待替换字段的设值函数，令它为新类创建一个实例。

编译，测试。

现在，你有可能需要对新类使用Change Value to Reference (179)。

值对象应该是不可修改内容的

8.3 Change Value to Reference（将值对象改为引用对象）

你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象。将这个值对象变成引用对象。

动机

在许多系统中，你都可以对对象做一个有用的分类：引用对象和值对象。前者就像“客户”、“账户”这样的东西，每个对象都代表真实世界中的一个实物，你可以直接以相等操作符（==，用来检验对象同一性）检查两个对象是否相等。后者则是像“日期”、“钱”这样的东西，它们完全由其所含的数据值来定义，你并不在意副本的存在，系统中或许存在成百上千个内容为“1/1/2000”的“日期”对象。当然，你也需要知道两个值对象是否相等，所以你需要覆写equals()（以及hashCode

)）。

要在引用对象和值对象之间做选择有时并不容易。有时候，你会从一个简单的值对象开始，在其中保存少量不可修改的数据。而后，你可能会希望给这个对象加入一些可修改数据，并确保对任何一个对象的修改都能影响到所有引用此一对象的地方。这时候你就需要将这个对象变成一个引用对象。

做法

使用Replace Constructor with Factory Method (304)。

编译，测试。

决定由什么对象负责提供访问新对象的途径。

可能是一个静态字典或一个注册表对象。

你也可以使用多个对象作为新对象

的访问点。

决定这些引用对象应该预先创建好，或是应该动态创建。

如果这些引用对象是预先创建好的，而你必须从内存中将它们读取出来，那么就得确保它们在被需要的时候能够被及时加载。

修改工厂函数，令它返回引用对象。

如果对象是预先创建好的，你就需要考虑：万一有人索求一个其实并不存在的对象，要如何处理错误？

你可能希望对工厂函数使用Rename Method (273)，使其传达这样的信息：它返回的是一个既存对象。

编译，测试。

8.4 Change Reference to Value（将引用对象改为值对象）

你有一个引用对象，很小且不可变，而且不易管理。将它变成一个值对象。

正如我在Change Value to Reference (179)中所说，要在引用对象和值对象之间做选择，有时并不容易。作出选择后，你常会需要一条回头路。

如果引用对象开始变得难以使用，也许就应该将它改为值对象。引用对象必须被某种方式控制，你总是必须向其控制者请求适当的引用对象。它们可能造成内存区域之间错综复杂的关联。在分布系统和并发系统中，不可变的值对象特别有用，因为你无需考虑它们的同步问题。

值对象有一个非常重要的特性：它们应该是不可变的。无论何时，只要你调用同一对象的同一个查询函数，都应该得到同样结果。如果保证了这一点，就可以放心地以多个对象表示同一个事物。如果值对象是可变的，你就必须确保对某一对象的修改会自动更新其他“代表相同事物”的对象。这太痛苦了，与其如此还不如把它变成引用对象。

这里有必要澄清一下“不可变”（immutable）的意思。如果你以Money类表示“钱”的概念，其中有“币种”和“金额”两条信息，那么Money对象通常是一个不可变的值对象。这并非意味你的薪资不能改变，而是意味：如果要改变你的薪资，就需要使用另一个Money对象来取代现有的Money对象，而不是在现有的Money对象上修改。你和Money对象之间的关系可以改变，但Money对象自身不能改变。

做法

检查重构目标是否为不可变对象，或是否可修改为不可变对象。

如果该对象目前还不是不可变的，就使用Remove Setting Method (300)，直到它成为不可变的为止。

如果无法将该对象修改为不可变的，就放弃使用本项重构。

建立equals()和hashCode()。

编译，测试。

考虑是否可以删除工厂函数，并将构造函数声明为public。

要把一个引用对象变成值对象，关键动作是：检查它是否不可变。如果不是，我就不能使用本项重构，因为可变的值对象会造成烦人的别名问题。

8.5 Replace Array with Object（以对象取代数组）

你有一个数组，其中的元素各自代表不同的东西。以对象替换数组。对于数组中的每个元素，以一个字段来表示。

动机

数组是一种常见的用以组织数据的结构。不过，它们应该只用于“以某种顺序容纳一组相似对象”。有时候你会发现，一个数组容纳了多种不同对象，这会给用户带来麻烦，因为他们很难记住像“数组的第一个元素是人名”这样的约定。对象就不同了，你可以运用字段名称和函数名称来传达这样的信息，因此你无需死记它，也无需依赖注释。而且如果使用对象，你还可以将信息封装起来，并使用Move Method (142)为它加上相关行为。

做法

新建一个类表示数组所拥有的信息，并在其中以一个public字段保存原先的数组。

修改数组的所有用户，让它们改用新类的实例。

编译，测试。

逐一为数组元素添加取值/设值函数。根据元素的用途，为这些访问函数命名。修改客户端代码，让它们通过访问函数取用数组内的元素。每次修改后，编译并测试。

当所有对数组的直接访问都转而调用访问函数后，将新类中保存该数组的字段声明为private。

编译。

对于数组内的每一个元素，在新类中创建一个类型相当的字段。修改该元素的访问函数，令它改用上述的新建字段。

每修改一个元素，编译并测试。

数组的所有元素都有了相应字段之后，删除该数组。

来自京东读书

导出日期：2021-04-20

下一封未读：

**account   【通知】美摄SDK版本已更新到【2.21.0】**

上一封 [下一封](javascript:;)

[« 返回](