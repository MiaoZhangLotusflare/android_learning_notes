# 第 8 章 重新组织数据

​		Replace Data Value with Object (175)（以对象取代数据值） 让你可以将 “ 哑 ” 数据变成善表达的对象。如果你发现程序中有太多地方需要这一类对象，也可以使用 Change Value to Reference (179)（将值对象改为引用对象）将它们变成引用对象。

​		如果你看到一个数组的行为方式很像一个数据结构，就可以使用 Replace Array with Object (186)（以对象取代数组）把数组变成对象，从而使这个数据结构更清晰地显露出来。但这只是第一步，当你使用 Move Method (142)（搬移函数）为这个新对象加入相应行为时，真正的好处才得以体现。

​		魔法数 —— 也就是带有特殊含义的数字 —— 从来都是个问题。我还清楚记得，一开始学习编程的时候，老师就告诉我不要使用魔法数。但它们还是不时出现。因此，只要弄清楚魔法数的用途，我就运用 Replace Magic Number with Symbolic Constant (204)（以字面常量取代魔法数）将它们除掉，以绝后患。

​		对象之间的关联可以是单向的，也可以是双向的。单向关联比较简单，但有时为了支持一项新功能，你需要使用 Change Unidirectional Association to Bidirectional (197)（将单向关联改为双向关联）将它变成双向关联。Change Bidirectional Association to Unidirectional (200)（将双向关联改为单向关联）则恰恰相反：如果你发现不再需要双向关联，可以使用这项重构将它变成单向关联。

​		面向对象编程的关键原则之一就是封装。如果一个类公开了任何 public 数据，你就应该使用 Encapsulate Field (206)（封装字段）将它郑重地包装起来。如果被公开的数据是个集合，就应该使用 Encapsulate Collection (208)（封装集合），因为集合有其特殊协议。如果一整条记录都被裸露在外，就应该使用 Replace Record with Data Class (217)（以数据类取代记录）。

​		需要特别对待的一种数据是类型码（type code）：这是一种特殊数值，用来指出 “ 与实例所属之类型相关的某些东西 ”。类型码通常以枚举形式出现，并且通常以 static final 整数实现。如果这些类型码用来表现某种信息，并且不会改变所属类型的行为，你可以运用 Replace Type Code with Class (218)（以类取代临时变量）将它们替换掉，这项重构会为你提供更好的类型检查，以及一个更好的平台，使你可以在未来更方便地将相关行为添加进去。另外，如果当前类型的行为受到类型码的影响，你就应该尽可能使用 Replace Type Code with Subclasses (223)（以子类取代类型码）。如果做不到，就只好使用更复杂（同时也更灵活）的 Replace Type Code with State/Strategy (227)（以 State/Strategy 取代类型码）。

## 8.1. Self Encapsulate Field（自封装字段）

​		你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙。

​		**为这个字段建立取值/设值函数，并且只以这些函数来访问字段。**

### 动机

​		在 “ 字段访问方式 ” 这个问题上，存在两种截然不同的观点：其中一派认为，在该变量定义所在的类中，你可以自由访问它；另一派认为，即使在这个类中你也应该只使用访问函数间接访问。

​		归根结底，间接访问变量的好处是，子类可以通过覆写一个函数而改变获取数据的途径；它还支持更灵活的数据管理方式，例如延迟初始化（意思是：只有在需要用到某值时，才对它初始化）。

​		直接访问变量的好处则是：代码比较容易阅读。阅读代码的时候，你不需要停下来说：“啊，这只是个取值函数。”

​		面临选择时，我总是做两手准备。通常情况下我会很乐意按照团队中其他人的意愿来做。就我自己而言，我比较喜欢先使用直接访问方式，直到这种方式给我带来麻烦为止，此时我就会转而使用间接访问方式。重构给了我改变主意的自由。

​		如果你想访问超类中的一个字段，却又想在子类中将对这个变量的访问改为一个计算后的值，这就是最该使用 Self Encapsulate Field (171)（自封装字段）的时候。“ 字段自我封装 ” 只是第一步。完成自我封装之后，你可以在子类中根据自己的需要随意覆写取值/设值函数。

### 做法

​		为待封装字段建立取值 / 设值函数。

​		找出该字段的所有引用点，将它们全部改为调用取值 / 设值函数。

​		如果引用点要读取字段值，就将它替换为调用取值函数；如果引用点要给字段赋值，就将它替换为调用设值函数。

​		你可以暂时将该字段改名，让编译器帮助你查找引用点。

​		将该字段声明为 private。

​		复查，确保找出所有引用点。

​		编译，测试。

​		使用本项重构时，你必须小心对待 “ 在构造函数中使用设值函数 ” 的情况。一般说来，设值函数被认为应该在对象创建后才使用，所以初始化过程中的行为有可能与设值函数的行为不同。这种情况下，我也许在构造函数中直接访问字段，要不就是单独另建一个初始化函数。

## 8.2. Replace Data Value with Object（以对象取代数据值）

​		你有一个数据项，需要与其他数据和行为一起使用才有意义。

​		**将数据项变成对象。**

### 动机

​		开发初期，你往往决定以简单的数据项表示简单的情况。但是，随着开发的进行，你可能会发现，这些简单数据项不再那么简单了。比如说，一开始你可能会用一个字符串来表示 “ 电话号码 ” 概念，但是随后你就会发现，电话号码需要 “ 格式化 ”、“ 抽取区号 ” 之类的特殊行为。如果这样的数据项只有一两个，你还可以把相关函数放进数据项所属的对象里；但是 Duplicate Code 坏味道和 Feature Envy 坏味道很快就会从代码中散发出来。当这些坏味道开始出现，你就应该将数据值变成对象。

### 做法

​		为待替换数值新建一个类，在其中声明一个 final 字段，其类型和源类中的待替换数值类型一样。然后在新类中加入这个字段的取值函数，再加上一个接受此字段为参数的构造函数。

​		编译。

​		将源类中的待替换数值字段的类型改为前面新建的类。

​		修改源类中该字段的取值函数，令它调用新类的取值函数。

​		如果源类构造函数中用到这个待替换字段（多半是赋值动作），我们就修改构造函数，令它改用新类的构造函数来对字段进行赋值动作。

修改源类中待替换字段的设值函数，令它为新类创建一个实例。

​		编译，测试。

​		现在，你有可能需要对新类使用	Change Value to Reference (179)（将值对象改为引用对象）。

​		值对象应该是不可修改内容的。

## 8.3. Change Value to Reference（将值对象改为引用对象）

​		你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象。

​		**将这个值对象变成引用对象。**

### 动机

​		在许多系统中，你都可以对对象做一个有用的分类：引用对象和值对象。前者就像 “ 客户 ”、“ 账户 ” 这样的东西，每个对象都代表真实世界中的一个实物，你可以直接以相等操作符（==，用来检验对象同一性）检查两个对象是否相等。后者则是像 “ 日期 ”、“ 钱 ” 这样的东西，它们完全由其所含的数据值来定义，你并不在意副本的存在，系统中或许存在成百上千个内容为 “ 1/1/2000 ” 的 “ 日期 ” 对象。当然，你也需要知道两个值对象是否相等，所以你需要覆写 equals()（ 以及 hashCode() ）。

​		要在引用对象和值对象之间做选择有时并不容易。有时候，你会从一个简单的值对象开始，在其中保存少量不可修改的数据。而后，你可能会希望给这个对象加入一些可修改数据，并确保对任何一个对象的修改都能影响到所有引用此一对象的地方。这时候你就需要将这个对象变成一个引用对象。

### 做法

​		使用 Replace Constructor with Factory Method(304)（以工厂函数取代构造函数）。

​		编译，测试。

​		决定由什么对象负责提供访问新对象的途径。

​		可能是一个静态字典或一个注册表对象。

​		你也可以使用多个对象作为新对象的访问点。

​		决定这些引用对象应该预先创建好，或是应该动态创建。

​		如果这些引用对象是预先创建好的，而你必须从内存中将它们读取出来，那么就得确保它们在被需要的时候能够被及时加载。

​		修改工厂函数，令它返回引用对象。

​		如果对象是预先创建好的，你就需要考虑：万一有人索求一个其实并不存在的对象，要如何处理错误？

​		你可能希望对工厂函数使用 Rename Method (273)（函数改名），使其传达这样的信息：它返回的是一个既存对象。

​		编译，测试。

## 8.4. Change Reference to Value（将引用对象改为值对象）

​		你有一个引用对象，很小且不可变，而且不易管理。

​		**将它变成一个值对象。**

### 动机

​		正如我在 Change Value to Reference (179)（将值对象改为引用对象）中所说，要在引用对象和值对象之间做选择，有时并不容易。作出选择后，你常会需要一条回头路。

​		如果引用对象开始变得难以使用，也许就应该将它改为值对象。引用对象必须被某种方式控制，你总是必须向其控制者请求适当的引用对象。它们可能造成内存区域之间错综复杂的关联。在分布系统和并发系统中，不可变的值对象特别有用，因为你无需考虑它们的同步问题。

​		值对象有一个非常重要的特性：它们应该是不可变的。无论何时，只要你调用同一对象的同一个查询函数，都应该得到同样结果。如果保证了这一点，就可以放心地以多个对象表示同一个事物。如果值对象是可变的，你就必须确保对某一对象的修改会自动更新其他 “ 代表相同事物 ” 的对象。这太痛苦了，与其如此还不如把它变成引用对象。

​		这里有必要澄清一下 “ 不可变 ”（immutable）的意思。如果你以 Money 类表示 “ 钱 ” 的概念，其中有 “ 币种 ” 和 “ 金额 ” 两条信息，那么 Money 对象通常是一个不可变的值对象。这并非意味你的薪资不能改变，而是意味：如果要改变你的薪资，就需要使用另一个 Money 对象来取代现有的 Money 对象，而不是在现有的 Money 对象上修改。你和 Money 对象之间的关系可以改变，但 Money 对象自身不能改变。

### 做法

​		检查重构目标是否为不可变对象，或是否可修改为不可变对象。

​		如果该对象目前还不是不可变的，就使用 Remove Setting Method (300)（移除设值函数），直到它成为不可变的为止。

​		如果无法将该对象修改为不可变的，就放弃使用本项重构。

​		建立 equals() 和 hashCode()。

​		编译，测试。

​		考虑是否可以删除工厂函数，并将构造函数声明为 public。

​		要把一个引用对象变成值对象，关键动作是：检查它是否不可变。如果不是，就不能使用本项重构，因为可变的值对象会造成烦人的别名问题。

## 8.5. Replace Array with Object（以对象取代数组）

​		你有一个数组，其中的元素各自代表不同的东西。

​		**以对象替换数组。对于数组中的每个元素，以一个字段来表示。**

### 动机

​		数组是一种常见的用以组织数据的结构。不过，它们应该只用于 “ 以某种顺序容纳一组相似对象 ”。有时候你会发现，一个数组容纳了多种不同对象，这会给用户带来麻烦，因为他们很难记住像 “ 数组的第一个元素是人名 ” 这样的约定。对象就不同了，你可以运用字段名称和函数名称来传达这样的信息，因此你无需死记它，也无需依赖注释。而且如果使用对象，你还可以将信息封装起来，并使用 Move Method (142)（搬移函数）为它加上相关行为。

### 做法

​		新建一个类表示数组所拥有的信息，并在其中以一个 public 字段保存原先的数组。

​		修改数组的所有用户，让它们改用新类的实例。

​		编译，测试。

​		逐一为数组元素添加取值/设值函数。根据元素的用途，为这些访问函数命名。修改客户端代码，让它们通过访问函数取用数组内的元素。每次修改后，编译并测试。

​		当所有对数组的直接访问都转而调用访问函数后，将新类中保存该数组的字段声明为 private。

​		编译。

​		对于数组内的每一个元素，在新类中创建一个类型相当的字段。修改该元素的访问函数，令它改用上述的新建字段。

​		每修改一个元素，编译并测试。

​		数组的所有元素都有了相应字段之后，删除该数组。

## 8.6. Duplicate Observed Data（复制“被监视数据”）

​		你有一些领域数据置身于 GUI 控件中，而领域函数需要访问这些数据。

​		**将该数据复制到一个领域对象中。建立一个 Observer 模式，用以同步领域对象和 GUI 对象内的重复数据。**

### 动机

​		一个分层良好的系统，应该将处理用户界面和处理业务逻辑的代码分开。之所以这样做，原因有以下几点：

1. 你可能需要使用不同的用户界面来表现相同的业务逻辑，如果同时承担两种责任，用户界面会变得过分复杂；
2. 与 GUI 隔离之后，领域对象的维护和演化都会更容易，你甚至可以让不同的开发者负责不同部分的开发。

​		尽管可以轻松地将 “ 行为 ” 划分到不同部位，“ 数据 ” 却往往不能如此。同一项数据有可能既需要内嵌于 GUI 控件，也需要保存于领域模型里。自从 MVC（Model-View-Controller，模型 - 视图 - 控制器 ）模式出现后，用户界面框架都使用多层系统来提供某种机制，使你不但可以提供这类数据，并保持它们同步。

​		如果你遇到的代码是以两层方式开发，业务逻辑被内嵌于用户界面之中，你就有必要将行为分离出来。其中的主要工作就是函数的分解和搬移。但数据就不同了：你不能仅仅只是移动数据，必须将它复制到新的对象中，并提供相应的同步机制。

### 做法

​		修改展现类，使其成为领域类的 Observer。

​		如果尚未有领域类，就建立一个。

​		如果没有 “ 从展现类到领域类 ” 的关联，就将领域类保存于展现类的一个字段中。

​		针对 GUI 类中的领域数据，使用 Self Encapsulate Field (171)（自封装字段）。

​		编译，测试。

​		在事件处理函数中调用设值函数，直接更新 GUI 组件。

​		在事件处理函数中放一个设值函数，利用它将 GUI 组件更新为领域数据的当前值。当然这其实没有必要，你只不过是拿它的值设定它自己。但是这样使用设值函数，便是允许其中的任何动作得以于日后被执行起来，这是这一步骤的意义所在。

​		进行这个改变时，对于组件，不要使用取值函数，应该直接取用，因为稍后我们将修改取值函数，使其从领域对象（而非 GUI 组件）取值。设值函数也将做类似修改。

​		确保测试代码能够触发新添加的事件处理机制。

​		编译，测试。

​		在领域类中定义数据及其相关访问函数。

​		确保领域类中的设值函数能够触发 Observer 模式的通报机制。

​		对于被观察的数据，在领域类中使用与展现类所用的相同类型（通常是字符串）来保存。后续重构中你可以自由改变这个数据类型。

​		修改展现类中的访问函数，将它们的操作对象改为领域对象（而非 GUI 组件）。

​		修改 Observer 的 update()，使其从相应的领域对象中将所需数据复制给	GUI	组件。

​		编译，测试。

## 8.7. Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）

​		两个类都需要使用对方特性，但其间只有一条单向连接。

​		**添加一个反向指针，并使修改函数能够同时更新两条连接。**

### 动机

​		开发初期，你可能会在两个类之间建立一条单向连接，使其中一个类可以引用另一个类。随着时间推移，你可能发现被引用类需要得到其引用者以便进行某些处理。也就是说，它需要一个反向指针。但指针是一种单向连接，你不可能反向操作它。通常你可以绕道而行，虽然会耗费一些计算时间，成本还算合理，然后你可以在被引用类中建立一个函数专门负责此一行为。但是，有时候想绕过这个问题并不容易，此时就需要建立双向引用关系，或称为反向指针。如果使用不当，反向指针很容易造成混乱；但只要你习惯了这种手法，它们其实并不是太复杂。

​		“ 反向指针 ” 手法有点棘手，所以在你能够自如运用之前，应该有相应的测试。通常我不花心思去测试访问函数，因为普通访问函数的风险没有高到需要测试的地步，但本重构要求测试访问函数，所以它是极少数需要添加测试的重构手法之一。

​		本重构运用反向指针实现双向关联。其他技术（例如连接对象）需要其他重构手法。

### 做法

​		在被引用类中增加一个字段，用以保存反向指针。

​		决定由哪个类 —— 引用端还是被引用端 —— 控制关联关系。

​		在被控端建立一个辅助函数，其命名应该清楚指出它的有限用途。

​		如果既有的修改函数在控制端，让它负责更新反向指针。

​		如果既有的修改函数在被控端，就在控制端建立一个控制函数，并让既有的修改函数调用这个新建的控制函数。

​		需要决定由哪一个类负责控制关联关系。我比较喜欢让单个类来操控，因为这样就可以将所有处理关联关系的逻辑集中安置于一地。我将按照下列步骤做出这一决定。

1. 如果两者都是引用对象，而其间的关联是 “ 一对多 ” 关系，那么就由 “ 拥有单一引用 ” 的那一方承担 “ 控制者 ” 角色。以本例而言，如果一个客户可拥有多份定单，那么就由 Order 类（定单）来控制关联关系。
2. 如果某个对象是组成另一对象的部件，那么由后者负责控制关联关系。
3. 如果两者都是引用对象 s，而其间的关联是 “ 多对多 ” 关系，那么随便其中哪个对象来控制关联关系，都无所谓。

## 8.8. Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）

​		两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。

​		**去除不必要的关联。**

### 动机

​		双向关联很有用，但你也必须为它付出代价，那就是维护双向连接、确保对象被正确创建和删除而增加的复杂度。而且，由于很多程序员并不习惯使用双向关联，它往往成为错误之源。

​		大量的双向连接也很容易造成 “ 僵尸对象 ”：某个对象本来已经该死亡了，却仍然保留在系统中，因为对它的引用还没有完全清除。

​		此外，双向关联也迫使两个类之间有了依赖：对其中任一个类的任何修改，都可能引发另一个类的变化。如果这两个类位于不同的包，这种依赖就是包与包之间的相依。过多的跨包依赖会造就紧耦合系统，使得任何一点小小改动都可能造成许多无法预知的后果。

​		只有在真正需要双向关联的时候，才应该使用它。如果发现双向关联不再有存在价值，就应该去掉其中不必要的一条关联。

### 做法

​		找出保存 “ 你想去除的指针 ” 的字段，检查它的每一个用户，判断是否可以去除该指针。

​		不但要检查直接访问点，也要检查调用这些直接访问点的函数。

​		考虑有无可能不通过指针取得被引用对象。如果有可能，你就可以对取值函数使用 Substitute Algorithm (139)（替换算法），从而让客户在没有指针的情况下也可以使用该取值函数。

​		对于使用该字段的所有函数，考虑将被引用对象作为参数传进去。

​		如果客户使用了取值函数，先运用 Self Encapsulate Field (171)（自封装字段）将待删除字段自我封装起来，然后使用 Substitute Algorithm (139)（替换算法）对付取值函数，令它不再使用该字段。然后编译、测试。

​		如果客户并未使用取值函数，那就直接修改待删除字段的所有被引用点：改以其他途径获得该字段所保存的对象。每次修改后，编译并测试。

​		如果已经没有任何函数使用待删除字段，移除所有对该字段的更新逻辑，然后移除该字段。

​		如果有许多地方对此字段赋值，先运用 Self Encapsulate Field (171)（自封装字段）使这些地点改用同一个设值函数。编译、测试。而后将这个设值函数的本体清空。再编译、再测试。如果这些都可行，就可以将此字段和其设值函数，连同对设值函数的所有调用，全部移除。

​		编译，测试。

## 8.9. Replace Magic Number with Symbolic Constant（以字面常量取代魔法数）

​		你有一个字面数值，带有特别含义。

​		**创造一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量。**

### 动机

​		在计算科学中，魔法数（magic number）是历史最悠久的不良现象之一。所谓魔法数是指拥有特殊意义，却又不能明确表现出这种意义的数字。如果你需要在不同的地点引用同一个逻辑数，魔法数会让你烦恼不己，因为一旦这些数发生改变，你就必须在程序中找到所有魔法数，并将它们全部修改一遍，这简直就是一场噩梦。就算你不需要修改，要准确指出每个魔法数的用途，也会让你颇费脑筋。

​		许多语言都允许你声明常量。常量不会造成任何性能开销，却可以大大提高代码的可读性。

​		进行本项重构之前，你应该先寻找其他替换方案。你应该观察魔法数如何被使用，而后你往往会发现一种更好的使用方式。如果这个魔法数是个类型码，请考虑使用 Replace Type Code with Class (218)（以类取代类型码）；如果这个魔法数代表一个数组的长度，请在遍历该数组的时候，改用Array.length()。

### 做法

​		声明一个常量，令其值为原本的魔法数值。

​		找出这个魔法数的所有引用点。

​		检查是否可以使用这个新声明的常量来替换该魔法数。如果可以，便以此常量替换之。

​		编译。

​		所有魔法数都被替换完毕后，编译并测试。此时整个程序应该运转如常，就像没有做任何修改一样。

​		有个不错的测试办法：检查现在的程序是否可以被你轻松地修改常量值（这可能意味某些预期结果将有所改变，以配合这一新值。实际工作中并非总是可以进行这样的测试）。如果可行，这就是一个不错的手法。

## 8.10. Encapsulate Field（封装字段）

​		你的类中存在一个 public 字段。

​		**将它声明为 private，并提供相应的访问函数。**

### 动机

​		面向对象的首要原则之一就是封装，或者称为 “ 数据隐藏 ”。按此原则，你绝不应该将数据声明为 public，否则其他对象就有可能访问甚至修改这项数据，而拥有该数据的对象却毫无察觉。于是，数据和行为就被分开了 ——  这可不是件好事。

​		数据声明为 public 被看做是一种不好的做法，因为这样会降低程序的模块化程度。数据和使用该数据的行为如果集中在一起，一旦情况发生变化，代码的修改就会比较简单，因为需要修改的代码都集中于同一块地方，而不是星罗棋布地散落在整个程序中。

​		Encapsulate Field (206)（封装字段）是封装过程的第一步。通过这项重构手法，你可以将数据隐藏起来，并提供相应的访问函数。但它毕竟只是第一步。如果一个类除了访问函数外不能提供其他行为，它终究只是一个哑吧类。这样的类并不能享受对象技术带来的好处。而你知道，浪费任何一个对象都是很不好的。实施 Encapsulate Field (206)（封装字段）之后，我会尝试寻找用到新建访问函数的代码，看看是否可以通过简单的 Move Method (142)（搬移函数）轻快地将它们移到新对象去。

### 做法

​		为 public 字段提供取值 / 设值函数。

​		找到这个类以外使用该字段的所有地点。如果客户只是读取该字段，就把引用替换为对取值函数的调用；如果客户修改了该字段值，就将此引用点替换为对设值函数的调用。

​		如果这个字段是个对象，而客户只不过是调用该对象的某个函数，那么无论该函数是否改变对象状态，都只能算是读取该字段。只有当客户为该字段赋值时，才能将其替换为设值函数。

​		每次修改之后，编译并测试。

​		将字段的所有用户修改完毕后，把字段声明为 private。

​		编译，测试。

## 8.11. Encapsulate Collection（封装集合）

​		有个函数返回一个集合。

​		**让这个函数返回该集合的一个只读副本，并在这个类中提供添加 / 移除集合元素的函数。**

### 动机

​		我们常常会在一个类中使用集合（collection，可能是array、list、set 或 vector）来保存一组实例。这样的类通常也会提供针对该集合的取值 / 设值函数。

​		但是，集合的处理方式应该和其他种类的数据略有不同。取值函数不该返回集合自身，因为这会让用户得以修改集合内容而集合拥有者却一无所悉。这也会对用户暴露过多对象内部数据结构的信息。如果一个取值函数确实需要返回多个值，它应该避免用户直接操作对象内所保存的集合，并隐藏对象内与用户无关的数据结构。至于如何做到这一点，视你使用的 Java  版本不同而有所不同。

​		另外，不应该为这整个集合提供一个设值函数，但应该提供用以为集合添加 / 移除元素的函数。这样，集合拥有者（对象）就可以控制集合元素的添加和移除。

​		如果你做到以上几点，集合就被很好地封装起来了，这便可以降低集合拥有者和用户之间的耦合度。

### 做法

​		加入为集合添加 / 移除元素的函数。

​		将保存集合的字段初始化为一个空集合。

​		编译。

​		找出集合设值函数的所有调用者。你可以修改那个设值函数，让它使用上述新建立的 “ 添加 / 移除元素 ” 函数；也可以直接修改调用端，改让它们调用上述新建立的 “ 添加 / 移除元素 ” 函数。

​		两种情况下需要用到集合设值函数：(1)集合为空时；(2)准备将原有集合替换为另一个集合时。

​		你或许会想运用 Rename Method (273)（函数改名）为集合设值函数改名：从 setXxx() 改为 initializeXxx() 或 replaceXxx()。

​		编译，测试。

​		找出所有 “ 通过取值函数获得集合并修改其内容 ” 的函数。逐一修改这些函数，让它们改用添加 / 移除函数。每次修改后，编译并测试。

​		修改完上述所有 “ 通过取值函数获得集合并修改集合内容 ” 的函数后，修改取值函数自身，使它返回该集合的一个只读副本。

​		在 Java 2 中，你可以使用 Collection.unmodifiableXxx() 得到该集合的只读副本。

​		在 Java l.1 中，你应该返回集合的一份副本。

​		编译，测试。

​		找出取值函数的所有用户，从中找出应该存在于集合所属对象内的代码。运用 Extract Method (110)（提炼函数）和 Move Method (142)（搬移函数）将这些代码移到宿主对象去。

​		如果你使用 Java 2，那么本项重构到此为止。如果你使用 Java l.1，那么用户也许会喜欢使用枚举。为了提供这个枚举，你应该像如下这样做。

​		修改现有取值函数的名字，然后添加一个新取值函数，使其返回一个枚举。找出旧取值函数的所有被使用点，将它们都改为使用新取值函数。

​		如果这一步跨度太大，你可以先使用 Rename Method (273)（函数改名）修改原取值函数的名称；再建立一个新取值函数用以返回枚举；最后再修改所有调用者，使其调用新取值函数。

​		编译，测试。

## 8.12. Replace Record with Data Class（以数据类取代记录）

​		你需要面对传统编程环境中的记录结构。

​		**为该记录创建一个 “ 哑 ” 数据对象。**

### 动机

​		记录型结构是许多编程环境的共同性质。有一些理由使它们被带进面向对象程序之中：你可能面对的是一个遗留程序，也可能需要通过一个传统 API 来与记录结构交流，或是处理从数据库读出的记录。这些时候你就有必要创建一个接口类，用以处理这些外来数据。最简单的做法就是先建立一个看起来类似外部记录的类，以便日后将某些字段和函数搬移到这个类之中。一个不太常见但非常令人注目的情况是：数组中的每个位置上的元素都有特定含义，这种情况下应该使用 Replace Array with Object (186)（以对象取代数据）。

### 做法

​		新建一个类，表示这个记录。

​		对于记录中的每一项数据，在新建的类中建立对应的一个 private 字段，并提供相应的取值 / 设值函数。

​		现在，你拥有了一个 “ 哑 ” 数据对象。这个对象现在还没有任何有用的行为，但是更进一步的重构会解决这个问题。

## 8.13. Replace Type Code with Class（以类取代类型码）

​		类之中有一个数值类型码，但它并不影响类的行为。

​		**以一个新的类替换该数值类型码。**

### 动机

​		在以 C 为基础的编程语言中，类型码或枚举值很常见。如果带着一个有意义的符号名，类型码的可读性还是不错的。问题在于，符号名终究只是个别名，编译器看见的、进行类型检验的，还是背后那个数值。任何接受类型码作为参数的函数，所期望的实际上是一个数值，无法强制使用符号名。这会大大降低代码的可读性，从而成为 bug 之源。

​		如果把那样的数值换成一个类，编译器就可以对这个类进行类型检验。只要为这个类提供工厂函数，你就可以始终保证只有合法的实例才会被创建出来，而且它们都会被传递给正确的宿主对象。

​		但是，在使用 Replace Type Code with Class (218)（以类取代类型码）之前，你应该先考虑类型码的其他替换方式。只有当类型码是纯粹数据时（ 也就是类型码不会在 switch 语句中引起行为变化时 ），你才能以类来取代它。 Java 只能以整数作为 switch 语句的判断依据，不能使用任意类，因此那种情况下不能够以类替换类型码。更重要的是：任何 switch 语句都应该运用 Replace Conditional with Polymorphism (255)（以多态取代条件表达式）去掉。为了进行那样的重构，你首先必须运用 Replace Type Code with Subclasses (223)（以子类取代类型码）或 Replace Type Code with State/Strategy (227)（以 State/Strategy 取代类型码 ），把类型码处理掉。

​		即使一个类型码不会因其数值的不同而引起行为上的差异，宿主类中的某些行为还是有可能更适合置放于类型码类中，因此你还应该留意是否有必要使用 Move Method (142)（搬移函数）将一两个函数搬过去。

### 做法

​		为类型码建立一个类。

​		这个类需要一个用以记录类型码的字段，其类型应该和类型码相同，并应该有对应的取值函数。此外还应该用一组静态变量保存允许被创建的实例，并以一个静态函数根据原本的类型码返回合适的实例。

​		修改源类实现，让它使用上述新建的类。

​		维持原先以类型码为基础的函数接口，但改变静态字段，以新建的类产生代码。然后，修改类型码相关函数，让它们也从新建的类中获取类型码。

## 8.14. Replace Type Code with Subclasses（以子类取代类型码）

​		你有一个不可变的类型码，它会影响类的行为。

​		**以子类取代这个类型码。**

### 动机

​		如果你面对的类型码不会影响宿主类的行为，可以使用 Replace Type Code with Class (218)（以类取代类型码）来处理它们。但如果类型码会影响宿主类的行为，那么最好的办法就是借助多态来处理变化行为。

​		像 switch 这样的条件表达式。这种条件表达式可能有两种表现形式：switch 语句或者 if-then-else 结构。不论哪种形式，它们都是检查类型码值，并根据不同的值执行不同的动作。这种情况下，你应该以 Replace Conditional with Polymorphism (255)（以多态取代条件表达式）进行重构。但为了能够顺利进行那样的重构，首先应该将类型码替换为可拥有多态行为的继承体系。这样的一个继承体系应该以类型码的宿主类为基类，并针对每一种类型码各建立一个子类。

​		为建立这样的继承体系，最简单的办法就是 Replace Type Code with Subclasses (223)（以子类取代类型码）：以类型码的宿主类为基类，针对每种类型码建立相应的子类。

​		但是以下两种情况你不能那么做：

1. 类型码值在对象创建之后发生了改变；
2. 由于某些原因，类型码宿主类已经有了子类。如果你恰好面临这两种情况之一，就需要使用 Replace Type Code with State/Strategy (227)（以 State/Strategy 取代类型码）。

​		Replace Type Code with Subclasses (223)（以子类取代类型码）的主要作用其实是搭建一个舞台，让 Replace Conditional with Polymorphism (255)（以多态取代条件表达式）得以一展身手。如果宿主类中并没有出现条件表达式，那么 Replace Type Code with Class (218)（以类取代类型码）更合适，风险也比较低。

​		使用 Replace Type Code with Subclasses (223)（以子类取代类型码）的另一个原因就是，宿主类中出现了 “ 只与具备特定类型码之对象相关 ” 的特性。完成本项重构之后，你可以使用 Push Down Method (328)（函数下移）和 Push Down Field (329)（字段下移）将这些特性推到合适的子类去，以彰显它们只与特定情况相关这一事实。

​		Replace Type Code with Subclasses (223)（以子类取代类型码）的好处在于：它把 “ 对不同行为的了解 ” 从类用户那儿转移到了类自身。如果需要再加入新的行为变化，只需添加一个子类就行了。如果没有多态机制，就必须找到所有条件表达式，并逐一修改它们。因此，如果未来还有可能加入新行为，这项重构将特别有价值。

### 做法

​		使用 Self Encapsulate Field (171)（自封装字段）将类型码自我封装起来。

​		如果类型码被传递给构造函数，就需要将构造函数换成工厂函数。

​		为类型码的每一个数值建立一个相应的子类。在每个子类中覆写类型码的取值函数，使其返回相应的类型码值。

​		这个值被硬编码于 return 句中（ 例如，return 1 ）。这看起来很肮脏，但只是权宜之计。当所有 case 子句都被替换后，问题就解决了。

​		每建立一个新的子类，编译并测试。

​		从超类中删掉保存类型码的字段。将类型码访问函数声明为抽象函数。

​		编译，测试。

## 8.15. Replace Type Code with State/Strategy（ 以State/Strategy 取代类型码）

​		你有一个类型码，它会影响类的行为，但你无法通过继承手法消除它。

​		**以状态对象取代类型码。**

### 动机

​		本项重构和 Replace Type Code with Subclasses (223)（以子类取代类型码）很相似，但如果 “ 类型码的值在对象生命期中发生变化 ” 或 “ 其他原因使得宿主类不能被继承 ”，你也可以使用本重构。本重构使用 State 模式或 Strategy 模式。

​		State 模式和 Strategy 模式非常相似，因此无论你选择其中哪一个，重构过程都是相同的。“ 选择哪一个模式 ” 并非问题关键所在，你只需要选择更适合特定情境的模式就行了。如果你打算在完成本项重构之后再以 Replace Conditional with Polymorphism (255)（以多态取代条件表达式）简化一个算法，那么选择 Strategy 模式比较合适；如果你打算搬移与状态相关的数据，而且你把新建对象视为一种变迁状态，就应该选择使用 State 模式。

### 做法

​		使用 Self Encapsulate Field (171)（自封装字段）将类型码自我封装起来。

​		新建一个类，根据类型码的用途为它命名。这就是一个状态对象。

​		为这个新类添加子类，每个子类对应一种类型码。

​		比起逐一添加，一次性加入所有必要的子类可能更简单些。

​		在超类中建立一个抽象的查询函数，用以返回类型码。在每个子类中覆写该函数，返回确切的类型码。

​		编译。

​		在源类中建立一个字段，用以保存新建的状态对象。

​		调整源类中负责查询类型码的函数，将查询动作转发给状态对象。

​		调整源类中为类型码设值的函数，将一个恰当的状态对象子类赋值给 “ 保存状态对象 ” 的那个字段。

​		编译，测试。

## 8.16. Replace Subclass with Fields（以字段取代子类）

​		你的各个子类的唯一差别只在 “ 返回常量数据 ” 的函数身上。

​		**修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类。**

### 动机

​		建立子类的目的，是为了增加新特性或变化其行为。有一种变化行为被称为 “ 常量函数 ”（constant method），它们会返回一个硬编码的值。这东西有其用途：你可以让不同的子类中的同一个访问函数返回不同的值。你可以在超类中将访问函数声明为抽象函数，并在不同的子类中让它返回不同的值。

​		尽管常量函数有其用途，但若子类中只有常量函数，实在没有足够的存在价值。你可以在超类中设计一个与常量函数返回值相应的字段，从而完全去除这样的子类。如此一来就可以避免因继承而带来的额外复杂性。

### 做法

​		对所有子类使用 Replace Constructor with Factory Method (304)（以工厂函数取代构造函数）。

​		如果有任何代码直接引用子类，令它改而引用超类。

​		针对每个常量函数，在超类中声明一个 final 字段。

​		为超类声明一个 protected 构造函数，用以初始化这些新增字段。

​		新建或修改子类构造函数，使它调用超类的新增构造函数。

​		编译，测试。

​		在超类中实现所有常量函数，令它们返回相应字段值，然后将该函数从子类中删掉。

​		每删除一个常量函数，编译并测试。

​		子类中所有的常量函数都被删除后，使用 Inline Method (117)（内联函数）将子类构造函数内联到超类的工厂函数中。

​		编译，测试。

​		将子类删掉。

​		编译，测试。

​		重复 “ 内联构造函数、删除子类 ” 过程，直到所有子类都被删除。
