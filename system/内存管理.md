#  内存管理



## 5. 存储器管理

### 5.1. 存储器的层次

　　在存储层次中，层次越高（越接近 CPU），存储介质的访问速度越快，价格越高，存储容量也越少。

![](image/存储器层次.jpg)

* 主存储器：简称内存或主存，是计算机系统中的主要部件，用来保存进程运行时的程序和数据，也称可执行存储器。
* 寄存器：寄存器与处理机的速度，寄存器的字长一般是 32 或是 64 位。
* 高速缓存：介于寄存器和主存储器之间的存储器，主要用来备份内存中常用的数据，以减少处理机对内存的访问次数，这样可以大幅的提高速度。
* 磁盘缓存：由于磁盘的 I/O 速度远低于内存的速度，所以用磁盘缓存来暂时存放一些磁盘数据和信息，它本身并不是一种实际存在的存储器，而是利用内存中的部分存储空间暂时存访一些信息。

### 5.2. 程序的装入和链接

![](image/程序的装入和链接.jpg)

### 5.3. 连续分配存储管理方式

* 地址重定位：指将逻辑地址变换成物理地址的过程。分为静态重定位和动态重定位。
* 存储管理方案：分区存储管理（固定分区、可变分区、可重定位分区）、分页存储管理（将一个进程的地址空间划分为若干个大小相等的区域，成为页，相应地，将主存空间划分成与页相同大小的若干个物理块，称为块。至少需要两次访问主存）、分块存储管理、段页式存储管理（地址结构：段号+段内页号+页内地址）、虚拟存储管理。

　　可变分区请求和释放主要算法：最佳适应算法、最差适应算法、首此适应算法，循环首次适应算法。

　　快表：在页式存储管理中将当前最活跃的少数几页的物理块号保存在高速存储器中，用以提高页式存储管理的性能。（不能两次访问主存）

　　页面置换算法：最佳置换算法（最长时间内不再被访问的页面置换出去）、先进先出置换算法、最近最少未使用置换算法、最近未用置换算法。





　　要解决的两个问题：

1. 每个进程代码中使用的地址可能相同。解决思路：对代码中的地址重定向（加个基地址）。
2. 物理内存可能比较小，不能同时放很多进程进来。解决思路：把要运行的代码移到内存，暂时不用的代码移到磁盘，即交换（swap），内存置换。

### 分段

　　一个程序分成多个段（每个段特性不同为了方便管理，例如代码段只读、数据段等等），当然这都是逻辑上的。

　　管理段的结构叫做段表，段表保存在进程的 PCB 中。

![](image/进程段表.png)

### 页表

　　把程序按段分对程序员是友好的，但是如果物理存储也按段存，则会导致大块的内存碎片，例如现在需要分个 10M 的段但是连续的存储空间只有 8M/9M/5M 三个。解决办法：（将段打散存到页中）不要对内存仅从连续的分配，将内存划分成 1 页 1 页 ，按页分配，一页 4kb 大小，最多浪费的也就 4kb。这样不会有内存碎片，也不会出现没有符合要求大小的内存可以申请的情况，因为可以打散了分散到一页一页中。

　　整个系统的页表就是多级页表（这个整个系统的多级页表简单来说就是把物理地址都进行了按页划分，保存了每页的基地址（对应下图中的页框号））。程序向系统申请内存时，系统就会把哪几个页框号分给程序的某个段，程序再把它段 0 中的第 3 页数据放到页框 6 中。

![](image/页1.png)

![](image/页2.png)

　　说明：进程需要有自己的 “ 页表 ”，里面映射的双方是程序的逻辑地址中的页号和系统分给这段程序的页框号。

#### 段页结合的内存管理

　　实际在内存管理中的段页结合如下图，页号加偏移称为虚拟地址，MMU 负载从虚拟地址到物理地址的转换，同时页负责权限检查。

![](image/段页结合.png)

　　上面解决了每个进程代码中使用的地址可能相同，系统给每个进程分配基地址，进程保存在 PCB 中。

#### 请求调页内存换入

　　CPU 对数据进行请求时，才会进行映射（虚拟内存到物理内存）。

![](image/请求的时候才映射.png)

　　例如进程 1 正在运行，进行映射拿数据，查页表发现页框号中没有数据或有进程 2 的数据，则需要页表调入内存。

![](image/页表调入内存.png)

#### 内存换出

　　有页表需要调入，那么谁调出。

　　页面置换算法：

1. 最佳置换算法（Optimal）：一种理论的算法，选择淘汰的页面是以后一定不再使用的页面（理想化的），该算法无法实现，只能作为其他算法好坏的一个评价对比。

2. 先进先出（FIFO）算法：总是最先淘汰最先进去的页面，该算法容易实现。缺点：通常程序调入内存的西安候顺序和程序执行的先后顺序不一致，导致缺页率高。

3. 最近最久未使用算法 LRU：算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间 t，每次置换的时候把 t 值最大的页面置换出去（实现方面可以采用寄存器或者栈的方式实现）。

4. 时钟算法 clock（也被称为是最近未使用算法 NRU）：页面设置一个访问位 R，并将页面链接为一个环形队列，页面被访问的时候访问位设置 R 为 1。页面置换的时候，如果当前指针所指页面访问 R 为 0，那么置换，否则将其置为 0，循环直到遇到一个访问位为 0 的页面。

   但是这个方法优缺点：缺页比较少的时候（最近没有使用淘汰中的 “最近” 太长了）。所有的 R 都为 1（很少变成 0），每次都要转一圈才能找到换出去的页，退化成 FIFO，效率不高。

   改进：双指针，一个快，一个慢，像时钟一样（定时清除 R 位）（更像 clock），快时钟做 R 的清 0 定时清 0，等到慢指针转到这里的时候 R=0，说明在定时时间片内没有被访问，该页可以被替换了。

## 参考文章

1. [操作系统基础知识总结整理](https://blog.csdn.net/Song_JiangTao/article/details/79670805)
2. [操作系统基础知识总结（重要）](https://www.cnblogs.com/xdyixia/p/9274909.html)
3. [计算机操作系统](https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机操作系统 - 目录.md)
