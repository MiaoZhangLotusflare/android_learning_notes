#  死锁

#### 4.1.12. 死锁

　　两个以上的进程互相要求双方释放已经占用的资源导致无法继续运行下去的现象。

　　在两个或多个并发进程中，如果每个进程持有某种资源而又等待别的进程进程释放它或他们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待地一种状态。

　　例如：一个系统有一台扫描仪 R1，一台刻录机 R2，有两个进程 P1、P2，他们都准备将骚猫的文档刻录到 CD 上，P1 先请求 R1 成功，P2 先请求 R2 并成功，后来，P1 又请求 R2，但却因为已经分配而阻塞，P2 请求 R1，也因分配而阻塞，此时，双方都被阻塞，都希望双方释放自己所需的资源，但又谁都不能得到自己所需的资源而继续进程，从而一直占用自己所占的资源，就形成死锁。

#### 4.1.13. 可抢占性资源和不可抢占性资源

　　前者：某进程获得这类资源后，该资源可以在被其他进程或系统抢占。

　　后者：一旦系统将资源分配给一个进程以后，就不能把它强行收回，只能等它用完自行释放。

#### 4.1.14. 产生死锁的原因

1. 竞争不可抢占性资源。
2. 进程运行推进的顺序不合适。
3. 竞争可消耗资源。

　　如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因抢夺优先的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。

#### 4.1.15. 产生死锁的四个必要条件：互斥条件、请求与保持条件、不可剥夺条件、循环等待条件。

![](image/死锁必要条件.png)

1. 互斥条件：一个资源一次只能被一个进程使用。

   每个资源要么已经分配给了一个进程，要么就是可用的

2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

   已经得到了某个资源的进程可以再请求新的资源。

3. 不剥夺条件：进程已获取的资源，在未使用完之前，不能强行剥夺。

   已经分配给一个进程的资源不能强制性地被抢占，它只能被占用它地进程显式地释放。

4. 循环等待条件：若干进程之间形成一种头尾相连的循环等待资源关系。

   有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占用的资源。

　　这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

#### 4.1.16. 解决死锁的 4 种处理策略

　　鸵鸟策略（即不理睬策略）、预防策略、避免策略、检测与解除策略。

1. 预防死锁：破坏产生死锁的 4 个必要条件中的一个或者多个；实现起来比较简单，但是如果限制过于严格会降低系统资源利用率以及吞吐量。
2. 避免死锁：在资源的动态分配中，防止系统进入不安全状态（可能产生死锁的状态）-如银行家算法。
3. 检测死锁：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大。
4. 解除死锁：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大。

　　死锁忽略：Windows、Linux 个人版都不做死锁处理，直接忽略，大不了重启就好了，小概率事件，代价可以接受。

#### 4.1.17. 死锁预防

　　预先静态分配法（破坏不可剥夺条件）、资源有序分配法（将资源分类按顺序排列，保证不形成环路）。

#### 4.1.18. 死锁避免

　　银行家算法（对每个资源请求进行检测，确保安全。需要很大的系统开销）。

#### 4.1.19. 死锁解除

　　资源剥夺法、撤销进程法。

## 处理方法

　　主要有以下四种方法：

* 鸵鸟策略
* 死锁检测与死锁恢复
* 死锁预防
* 死锁避免

## 鸵鸟策略

　　把头埋在沙子里，假装根本没发生问题。

　　因为解决死锁问题的代码很高，因此托辗策略这种不采取任务措施的方案会获得更高的性能。

　　当发生死锁的时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

　　大多数操作系统，包括 Unix、Linux 和 Windows ，处理死锁问题的办法仅仅时忽略它。

## 死锁检测与死锁恢复

　　不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

### 1. 每种类型一个资源的死锁检测

![](image/每种类型一个资源的死锁检测.png)

　　上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。

　　图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。

　　每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现的，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记过的节点，就表示有向图存在环，也就是检测到死锁的发生。

### 2. 每种类型多个资源的死锁检测

![](image/每种类型多个资源的死锁检测.png)

　　上图中，有三个进程四个资源，每个数据代表的含义如下：

* E 向量：资源总量
* A 向量：资源剩余量
* C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量。
* R 矩阵：每个进程请求的资源数量

### 3. 死锁恢复



## 死锁预防

## 死锁避免



## 参考文章

1. [操作系统基础知识总结整理](https://blog.csdn.net/Song_JiangTao/article/details/79670805)
2. [操作系统基础知识总结（重要）](https://www.cnblogs.com/xdyixia/p/9274909.html)
3. [计算机操作系统](https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机操作系统 - 目录.md)
