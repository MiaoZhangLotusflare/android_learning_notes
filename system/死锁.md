#  死锁

#### 4.1.12. 死锁

　　两个以上的进程互相要求双方释放已经占用的资源导致无法继续运行下去的现象。

　　在两个或多个并发进程中，如果每个进程持有某种资源而又等待别的进程进程释放它或他们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待地一种状态。

　　例如：一个系统有一台扫描仪 R1，一台刻录机 R2，有两个进程 P1、P2，他们都准备将骚猫的文档刻录到 CD 上，P1 先请求 R1 成功，P2 先请求 R2 并成功，后来，P1 又请求 R2，但却因为已经分配而阻塞，P2 请求 R1，也因分配而阻塞，此时，双方都被阻塞，都希望双方释放自己所需的资源，但又谁都不能得到自己所需的资源而继续进程，从而一直占用自己所占的资源，就形成死锁。

#### 4.1.13. 可抢占性资源和不可抢占性资源

　　前者：某进程获得这类资源后，该资源可以在被其他进程或系统抢占。

　　后者：一旦系统将资源分配给一个进程以后，就不能把它强行收回，只能等它用完自行释放。

#### 4.1.14. 产生死锁的原因

1. 竞争不可抢占性资源。
2. 进程运行推进的顺序不合适。
3. 竞争可消耗资源。

　　如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因抢夺优先的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。

#### 4.1.15. 产生死锁的四个必要条件：互斥条件、请求与保持条件、不可剥夺条件、循环等待条件。

![](image/死锁必要条件.png)

1. 互斥条件：一个资源一次只能被一个进程使用。

   每个资源要么已经分配给了一个进程，要么就是可用的

2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

   已经得到了某个资源的进程可以再请求新的资源。

3. 不剥夺条件：进程已获取的资源，在未使用完之前，不能强行剥夺。

   已经分配给一个进程的资源不能强制性地被抢占，它只能被占用它地进程显式地释放。

4. 循环等待条件：若干进程之间形成一种头尾相连的循环等待资源关系。

   有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占用的资源。

　　这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

#### 4.1.16. 解决死锁的 4 种处理策略

　　鸵鸟策略（即不理睬策略）、预防策略、避免策略、检测与解除策略。

1. 预防死锁：破坏产生死锁的 4 个必要条件中的一个或者多个；实现起来比较简单，但是如果限制过于严格会降低系统资源利用率以及吞吐量。
2. 避免死锁：在资源的动态分配中，防止系统进入不安全状态（可能产生死锁的状态）-如银行家算法。
3. 检测死锁：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大。
4. 解除死锁：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大。

　　死锁忽略：Windows、Linux 个人版都不做死锁处理，直接忽略，大不了重启就好了，小概率事件，代价可以接受。

#### 4.1.17. 死锁预防

　　预先静态分配法（破坏不可剥夺条件）、资源有序分配法（将资源分类按顺序排列，保证不形成环路）。

#### 4.1.18. 死锁避免

　　银行家算法（对每个资源请求进行检测，确保安全。需要很大的系统开销）。

#### 4.1.19. 死锁解除

　　资源剥夺法、撤销进程法。

## 处理方法

　　主要有以下四种方法：

* 鸵鸟策略
* 死锁检测与死锁恢复
* 死锁预防
* 死锁避免

## 鸵鸟策略

　　把头埋在沙子里，假装根本没发生问题。

　　因为解决死锁问题的代码很高，因此托辗策略这种不采取任务措施的方案会获得更高的性能。

　　当发生死锁的时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

　　大多数操作系统，包括 Unix、Linux 和 Windows ，处理死锁问题的办法仅仅时忽略它。

## 死锁检测与死锁恢复

　　不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

### 1. 每种类型一个资源的死锁检测

![](image/每种类型一个资源的死锁检测.png)

　　上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。

　　图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。

　　每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现的，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记过的节点，就表示有向图存在环，也就是检测到死锁的发生。

### 2. 每种类型多个资源的死锁检测

![](image/每种类型多个资源的死锁检测.png)

　　上图中，有三个进程四个资源，每个数据代表的含义如下：

* E 向量：资源总量
* A 向量：资源剩余量
* C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量。
* R 矩阵：每个进程请求的资源数量

　　进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = ( 2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = ( 4 2 2 1)。P1 也可以执行。所有进程都可以顺利执行，没有死锁。

　　算法总结如下：

　　每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。

1. 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。
2. 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。
3. 如果没有这样一个进程，算法终止。

### 3. 死锁恢复

* 利用抢占资源
* 利用回滚恢复
* 通过杀死进程恢复

## 死锁预防

　　在程序运行之前预防发生死锁。

### 1. 破坏互斥条件

　　例如假脱机打印技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印守护进程。

### 2. 破坏占有和等待条件

　　一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。

### 3. 破坏不可抢占条件

### 4. 破坏环路等待

　　给资源同一编号，进程只能按编号顺序来请求资源。

## 死锁避免

　　在程序运行时避免发生死锁。

### 1. 安全状态

![](image/安全状态.png)

　　图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。

　　从图 a 开始出发，先让 B 拥有的所有的资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态是安全的。

　　定义：如果没有死锁发生，并且及时所有进程突然请求对资源的最大需求，页仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。

　　安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着坐参考对比。

### 2. 单个资源的银行家算法

　　一个小城镇的应行家，他向一群客户分别承诺了一定的带宽额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。

![](image/单个资源的银行家算法.png)

　　上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。

### 3. 多个资源的银行家算法

![](image/多个资源的银行家算法.png)

　　上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配的资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。

　　检查一个状态是否安全的算法如下：

* 朝朝右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。
* 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。
* 重复以上两步，直到所有进程都标记为终止，则状态是安全的。

　　如果一个状态不是安全的，需要拒绝进入这个状态。

## 参考文章

1. [操作系统基础知识总结整理](https://blog.csdn.net/Song_JiangTao/article/details/79670805)
2. [操作系统基础知识总结（重要）](https://www.cnblogs.com/xdyixia/p/9274909.html)
3. [计算机操作系统](https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机操作系统 - 目录.md)
