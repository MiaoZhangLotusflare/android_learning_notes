#  进程与线程

## 进程

　　进程是资源分配的基本单位。

　　进程控制块（Process Control Block，PCB）描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

　　下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。

![](image/进程.png)

## 线程

　　线程是独立调度的基本单位。

　　一个进程中可以由多个线程，它们共享进程资源。

　　QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其他事件。

![](image/thread.png)

　　进程是具有一定独立功能的程序关于某个数据集合上地一次运行活动，是系统进行资源分配和调度的一个独立单位。

　　线程是进程的一个实体，是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器、一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源，也有就绪、运行、阻塞三态。

　　一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。

#### 多进程的组织形式包括下面 3 个关键部分

1. PCB（Process Control Block）：用来记录进程信息的数据结构（管理进程的核心，包含了 PID 等进程的所有关键信息）。
2. 进程的状态：（1）就绪状态，（2）执行状态，（3）阻塞状态（多线程时也是这些状态）。
3. 队列：就绪队列，等待（阻塞）队列。

#### 4.1.1. PCB

　　为了便于系统描述和管理进程，在 OS 的核心位每个进程专门定义了一个数据结构，进程控制块 PCB。PCB 是进程的唯一标志。

#### 4.1.2. 区别

1. 简而言之，一个程序至少有一个进程，一个进程至少有一个线程。
2. 线程的划分尺度小于进程，使得多线程程序的并发性高。
3. 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
4. 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
5. 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

#### 4.1.3. 优缺点

　　线程执行开销小，单不利于资源的管理和保护；而进程正相反。同时，线程适合于在 SMP 机器上运行，而进程则可以跨机器迁移。

#### 4.1.4. 程序顺序执行的特征

1. 顺序性：每一操作必须在下一操作开始之前结束。
2. 封闭性：程序运行时独占全机资源，资源的状态（除初始状态外）只有本程序才能改变，程序一旦执行，其结果不受外界影响。
3. 可再现性：程序执行环境和初始条件相同，重复执行时，结果相同。

#### 4.1.5. 程序并发执行的特征

1. 间断性：程序并发运行时，共享系统资源，为完成统一任务相互合作，会形成相互制约关系，导致并发程序具有 “ 执行-暂停-执行 ” 这种间断性的活动规律。
2. 失去封闭性：程序并发执行时，资源状态由多个程序改变，某程序执行时，会收到其他程序影响，失去封闭性。
3. 不可再现性：失去封闭性，导致失去可再现性。

#### 4.1.6. 进程的特征

1. 结构特征：程序段、相关数据段和 PCB 三部分构成进程实体。
2. 动态性：进程实体的一次执行过程，具有生命期，而程序是有序指令集合，是静态的。
3. 并发性：多个进程同时存于内存，在一段时间内同时运行。
4. 独立性：进程实体是一个能独立运行、独立分配资源和独立接收调度的基本单位。
5. 异步性：进程按各自独立的、不可预知的速度向前推进。

#### 4.1.7. 进程的状态

　　三态模型（左图）、五态模型（右图）

![](image/进程的状态.png)

　　处于就绪状态的进程，在调度程序为之分配了处理及之后便开始执行，就绪 -> 执行。

　　正在执行的进程如果因为分配它的时间片已经用完，而被剥夺处理器，执行 -> 就绪。

　　如果因为某种原因致使当前的进程执行受阻，使之不能执行。执行 -> 阻塞。

![](image/ProcessState.png)

* 就绪状态（ready）：等待被调度。
* 运行状态（running）
* 阻塞状态（waiting）：等待资源。

　　应该注意以下内容：

* 只有就绪态和运行态可以互相转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
* 阻塞状态时缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，减少 CPU 时间会从运行态转换为就绪态。

#### 4.1.8. 进程间的通信（同步与互斥）

　　由于多个进程可以并发执行，所以进程间必然存在资源共享和相互合作的问题。进程通信是指各个进程交换信息的过程。

　　同步时合作进程间直接制约问题，互斥是申请临界资源进程间的间接制约问题。（临界资源（Critical Resource,CR）：在同一时间只能供一个进程使用的资源，例如：打印机、磁带机等硬件资源）。

　　临界区管理 4 条原则：（临界区：每个进程中访问临界资源的那段代码）

1. 有空即进。
2. 无空则等。
3. 有限等待：要求访问临界区的进程，保证有限时间内进入临界区，避免死等。
4. 让权等待：进程不能进入临界区时，应立即释放处理机，避免忙等。

#### 4.1.9. 信号量机制

　　信号量机制：即利用 PV 操作来对信号量进行处理。

　　信号量（Semaphore）的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程。信号量的值与相应资源的使用情况有关。

　　当它的值大于 0 时，表示当前可用资源的数量。

　　当它的值小于 0 时，其绝对值表示等待使用该资源的进程个数。

　　注意，信号量的值仅能由 PV 操作来改变。

　　一般来说，信号量 S>= 0 时，S 表示可用资源的数量。执行一次 P 操作意味着请求分配一个单位资源，因此 S 的值减 1；当 S < 0 时，表示已经没有可用资源，请求者必须等待别的进程释放该类资源，它才能运行下去。而执行一个 V 操作意味着释放一个单位资源，因此 S 的值加 1；若 S <= 0，表示有某些进程正在等待该资源，因此要环形一个等待状态的进程，使之运行下去。 

#### 4.1.10. 进程调度：如何分配 CPU

　　调度方法分为可剥夺和不可剥夺两种。即当有更高优先级的进程到来时，是否可以将正在运行进程的 CPU 分配给高优先级的进程，可以则为可剥夺，否则为不可剥夺的。

　　在某些操作系统中，一个作业从提交到完成需要经历高、中、低三级调度。

1. 高级调度：又称长调度或作业调度。它决定处于输入中的哪个后备作业可以调入主系统做好运行的准备，成为一个或一组就绪进程。系统中一个作业（程序）只需经过一次高级调度。
2. 中级调度：又称短程调度或对换调度。它决定处于交换区中的就绪进程哪个可以调入内存，以便直接参与对 CPU 的竞争。在内存资源紧张时，为了将进程调入内存，必须将内存中处于阻塞状态的进程调出交换区，以便为调入进程腾出空间。
3. 低级调度：又称短程调度或进程调度。它决定处于内存中的就绪进程中的哪个可以占用 CPU。最活跃、最重要的调度程序，对系统影响也是最大的。

#### 

#### 4.1.11. 常见的进程调度算法

　　先来先服务（FCFS）、短作业优先、时间片轮转（固定时间片、可变时间片）、优先级调度（静态优先级、动态优先级）、多级反馈调度（时间片轮转+优先级调度）。

　　CPU 调度算法（在就绪序列中怎么挑选进程让 CPU 执行）。

　　先了解两个概念：

* 周转时间：从开始申请执行任务到执行任务完成。
* 响应时间：从开始申请执行任务到开始执行任务。

1. 先来先服务调度算法 FCFS：按作业或者进程到达的先后顺序依次调度；（平均周转时间可能会很长）
2. 短作业优先调度算法 SJF：算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行（周转时间段，但是响应时间长）。
3. 高相应比算法 HRN：响应比 = （等待时间+要求服务时间）/要求服务时间；
4. 时间片轮转调度 RR：按到达的先后对进程放入队列中，然后给队首进程分配 CPU 时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环；（响应时间可以得到保证）。
5. 多级反馈队列调度算法：目前工人较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按 FCFS 放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二个调度仍然没有完成，放入第三队列尾部...。只有当前一个队列为空时才会去调度下一个队列的进程。





　　不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

### 1. 批处理系统

　　批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

#### 1.1. 先来先服务 first-come first-serverd（FCFE）

　　非抢占式的调度算法，按照请求的顺序进行调度。

　　有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

#### 1.2. 短作业优先 shortest job first（SJF）

　　非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

　　长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

#### 1.3. 最短剩余时间优先 shortest remaining time next（SRTN）

　　最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

### 2. 交互式系统

　　交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快读地进行响应。

#### 2.1. 时间片轮转

　　将所有就绪进程按 FCFS 地原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序并停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

　　时间片轮转算法的效率和时间片的大小有很大关系：

* 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
* 而如果时间片太长，那么实时性就不能得到保证。



#### 2.2. 优先级调度

　　为每个进程分配一个优先级，按优先级进行调度。

　　为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

#### 2.3. 多级反馈队列

　　一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

　　多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1、2、4、8...。进程在



### 3. 实时系统



#### 进程的分类

https://www.cnblogs.com/xdyixia/p/9257160.html

#### 线程

　　线程有自己的 TCB （thread control block 线程控制块），只负责这条流程的信息，包括 PC 程序计数器，SP 栈、State 状态、寄存器、线程 id。

　　线程有内核级线程和用户级线程，一般说的都是用户级线程，内核级线程由内核管理。

　　补充小知识：

1. 只有内核级线程才能发挥多核性能，因为内核级线程共用一套 MMU（即内存映射表），统一分配核 1 核 2 （即有多个 CPU，可以一个 CPU 执行一个内核级线程），进程无法发挥多核性能，因为进程切换都得切 MMU。
2. 为什么需要内核级线程？如果只有用户级线程，在内核中只能看到进程，所以当用户级线程中一个线程进行 IO 读写阻塞时，内核会将该线程所在的进程直接切换。例如当用浏览器打开网页，这个进程中有下载数据线程，有显示数据线程，当数据下载读写阻塞时，内核直接切到 qq（这些切换是指在 CPU 上运行的程序）。

![](image/线程.png)



#### 进程和线程的区别

　　进程是系统进行资源调度和分配的基本单位；线程是 CPU 调度的基本单位。

　　进程 = 资源（包括寄存器值，PCB，内存映射表）+TCB（栈结构）。

　　线程 = TCB（栈结构）。

　　线程的资源是共享的。

　　进程间的资源是分隔独立的，内存映射表不同，占用物理内存地址是分隔的。

　　线程的切换只是切换 PC，切换了 TCB（栈结构）。

　　进程的切换不仅要切换 PC，还包括切换资源，即切换内存引射表。

1. 拥有资源

   进程时资源分赔的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

2. 调度

   线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

3. 系统开销

   由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保护及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器的内容，开销很小。

4. 通信方面

   线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

#### 进程间通信方式

**https://www.cnblogs.com/xdyixia/p/9257668.html** Unix

#### 进程间同步

　　经典的进程同步问题：生产者-消费者问题；哲学家进餐问题；读者-写者问题。

　　同步的解决方案：管程、信号量。

#### 4.1.20. 池

　　所谓池的概念，一般是指应用提前向内核批量申请资源，用于接下来的使用和回收，减少资源的初始化和销毁次数等开销，以达到提高系统性能的目标。

　　内存池：真正使用钱申请一片内存区域，有新需求时取出其中一部分使用，不够用时再重新申请新内存。

　　进程池：应用预先创建一组子进程，所有子进程运行相同代码，拥有相同属性，比如 PGID 和优先级等。

　　常见两种工作方式：

1. 主进程通过随机或 round robin 算法来选择子进程作为新任务的服务进程；
2. 通过一个共享队列来进行同步，所有子进程从该队列中获取任务，不过同时只能有一个子进程能成功获得新任务处理权。

　　线程持：主要应用于任务小而多，处理时间短的场景，比如简单网页请求等。

## 参考文章

1. [操作系统基础知识总结整理](https://blog.csdn.net/Song_JiangTao/article/details/79670805)
2. [操作系统基础知识总结（重要）](https://www.cnblogs.com/xdyixia/p/9274909.html)
3. [计算机操作系统](https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机操作系统 - 目录.md)
