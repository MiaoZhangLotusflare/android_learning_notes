#  进程与线程

## 1. 程序

### 1.1. 程序顺序执行的特征

1. 顺序性：每一操作必须在下一操作开始之前结束。
2. 封闭性：程序运行时独占全机资源，资源的状态（除初始状态外）只有本程序才能改变，程序一旦执行，其结果不受外界影响。
3. 可再现性：程序执行环境和初始条件相同，重复执行时，结果相同。

### 1.2. 程序并发执行的特征

1. 间断性：程序并发运行时，共享系统资源，为完成同一任务相互合作，会形成相互制约关系，导致并发程序具有 “ 执行 - 暂停 - 执行 ” 这种间断性的活动规律。
2. 失去封闭性：程序并发执行时，资源状态由多个程序改变，某程序执行时，会受到其他程序影响，失去封闭性。
3. 不可再现性：失去封闭性，导致失去可再现性。

## 2. 进程

　　进程是具有一定独立功能的程序关于某个数据集合上地一次运行活动，是系统进行资源分配和调度的一个独立基本单位。

　　下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。

![](image/进程.png)

### 2.1. 进程的特征

1. 结构特征：程序段、相关数据段和 PCB 三部分构成进程实体。
2. 动态性：进程实体的一次执行过程，具有生命期，而程序是有序指令集合，是静态的。
3. 并发性：多个进程同时存于内存，在一段时间内同时运行。
4. 独立性：进程实体是一个能独立运行、独立分配资源和独立接收调度的基本单位。
5. 异步性：进程按各自独立的、不可预知的速度向前推进。

### 2.2. 多进程的组织形式包括下面 3 个关键部分

1. PCB（Process Control Block）：进程控制块，用来记录进程信息的数据结构（管理进程的核心，包含了 PID 等进程的所有关键信息）。

   描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

2. 进程的状态：

   * （1）就绪状态
   * （2）执行状态
   * （3）阻塞状态（多线程时也是这些状态）

3. 队列：就绪队列，等待（阻塞）队列。

#### 2.2.1. PCB

　　为了便于系统描述和管理进程，在 OS 的核心为每个进程专门定义了一个数据结构，进程控制块 PCB。PCB 是进程的唯一标志。

#### 2.2.2. 进程的状态

　　三态模型（左图）、五态模型（右图）

![](image/进程的状态.png)

* 就绪状态（ready）：等待被调度。
* 运行状态（running）
* 阻塞状态（waiting）：等待资源。

　　处于就绪状态的进程，在调度程序为之分配了处理机之后便开始执行，就绪 -> 执行。

　　正在执行的进程如果因为分配它的时间片已经用完，而被剥夺处理器，执行 -> 就绪。

　　如果因为某种原因致使当前的进程执行受阻，使之不能执行。执行 -> 阻塞。

　　应该注意以下内容：

* 只有就绪态和运行态可以互相转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
* 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，减少 CPU 时间会从运行态转换为就绪态。

## 3. 线程

　　线程是进程的一个实体，是 CPU 独立调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器、一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源，也有就绪、运行、阻塞三态。

　　一个进程中可以有多个线程，它们共享进程资源。

　　QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其他事件。

![](image/thread.png)

　　一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。

　　线程有自己的 TCB （thread control block 线程控制块），只负责这条流程的信息，包括 PC 程序计数器，SP 栈、State 状态、寄存器、线程 id。

### 3.1. 线程分类

　　线程有内核级线程和用户级线程，一般说的都是用户级线程，内核级线程由内核管理。

　　补充小知识：

1. 只有内核级线程才能发挥多核性能，因为内核级线程共用一套 MMU（即内存映射表），统一分配核 1 核 2 （即有多个 CPU，可以一个 CPU 执行一个内核级线程），进程无法发挥多核性能，因为进程切换都得切 MMU。
2. 为什么需要内核级线程？如果只有用户级线程，在内核中只能看到进程，所以当用户级线程中一个线程进行 IO 读写阻塞时，内核会将该线程所在的进程直接切换。例如当用浏览器打开网页，这个进程中有下载数据线程，有显示数据线程，当数据下载读写阻塞时，内核直接切到 qq（这些切换是指在 CPU 上运行的程序）。

![](image/线程.png)

## 4. 进程与线程

### 4.1. 区别

1. 拥有资源

   进程是资源分配调度的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

   进程 = 资源（包括寄存器值，PCB，内存映射表）+ TCB（栈结构）。

2. 调度

   线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

   线程 = TCB（栈结构）。

3. 系统开销

   由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保护及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器的内容，开销很小。

   线程的切换只是切换 PC，切换了 TCB（栈结构）。

   进程的切换不仅要切换 PC，还包括切换资源，即切换内存映射表。

4. 通信方面

   进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。

   线程的资源是共享的。

   进程间的资源是分隔独立的，内存映射表不同，占用物理内存地址是分隔的。

   线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

5. 执行过程

   线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

6. 其他

   一个程序至少有一个进程，一个进程至少有一个线程。

   线程的划分尺度小于进程，使得多线程程序的并发性高。

　　从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，用来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

### 4.2. 优缺点

　　线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在 SMP 机器上运行，而进程则可以跨机器迁移。

## 5. 进程调度：如何分配 CPU

　　调度方法分为可剥夺和不可剥夺两种。即当有更高优先级的进程到来时，是否可以将正在运行进程的 CPU 分配给高优先级的进程，可以则为可剥夺，否则为不可剥夺的。

　　在某些操作系统中，一个作业从提交到完成需要经历高、中、低三级调度。

1. 高级调度：又称长调度或作业调度。它决定处于输入中的哪个后备作业可以调入主系统做好运行的准备，成为一个或一组就绪进程。系统中一个作业（程序）只需经过一次高级调度。
2. 中级调度：又称短程调度或对换调度。它决定处于交换区中的就绪进程哪个可以调入内存，以便直接参与对 CPU 的竞争。在内存资源紧张时，为了将进程调入内存，必须将内存中处于阻塞状态的进程调出交换区，以便为调入进程腾出空间。
3. 低级调度：又称短程调度或进程调度。它决定处于内存中的就绪进程中的哪个可以占用 CPU。最活跃、最重要的调度程序，对系统影响也是最大的。

### 5.1. 调度算法

　　CPU 调度算法：在就绪序列中怎么挑选进程让 CPU 执行。

　　先了解两个概念：

* 周转时间：从开始申请执行任务到执行任务完成。
* 响应时间：从开始申请执行任务到开始执行任务。

　　不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

#### 5.1.1. 批处理系统

　　批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

##### 5.1.1.1. 先来先服务 first-come first-serverd（FCFE）

　　非抢占式的调度算法，按作业或者进程到达的先后顺序依次调度。

　　平均周转时间可能会很长，有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

##### 5.1.1.2. 短作业优先 shortest job first（SJF）

　　非抢占式的调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行。

　　周转时间短，但是响应时间长，长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

##### 5.1.1.3. 最短剩余时间优先 shortest remaining time next（SRTN）

　　最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程，否则新的进程等待。

##### 5.1.1.4. 高响应比优先

　　高响应比算法 HRN：响应比 = （等待时间+要求服务时间）/要求服务时间；

　　按照高相应比的顺序进行调度，可以防止等待时间过长的任务饿死。

#### 5.1.2. 交互式系统

　　交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

##### 5.1.2.1. 时间片轮转 RR

　　将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。响应时间可以得到保证。

　　时间片轮转算法的效率和时间片的大小有很大关系：

* 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
* 如果时间片太长，那么实时性就不能得到保证。

##### 5.1.2.2. 优先级调度

　　为每个进程分配一个优先级，按优先级进行调度。

　　为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

##### 5.1.2.3. 多级反馈队列

　　多级反馈队列调度算法：目前公认较好的调度算法。设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按 FCFS 放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二个调度仍然没有完成，放入第三队列尾部...。只有当前一个队列为空时才会去调度下一个队列的进程。

　　一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

　　多级反馈队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1、2、4、8...。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

　　每个队列优先权也不同，最上面的优先级最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

　　可以将这种调度算法看成时间片轮转调度算法和优先级调度算法的结合。

![](image/多级反馈队列.png)

#### 5.1.3. 实时系统

　　实时系统要求一个请求在一个确定时间内得到响应。

　　分为硬实时和软实时，前者必须满足绝对的截至时间，后者可以容忍一定的超时。

## 6. 进程同步

　　经典的进程同步问题：生产者-消费者问题；哲学家进餐问题；读者-写者问题。

　　同步的解决方案：管程、信号量。

### 6.1. 临界区

　　对临界资源进行访问的那段代码称为临界区。

　　为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

### 6.2. 同步与互斥

　　同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。

　　互斥：多个进程在同一时刻只有一个进程能进入临界区。

### 6.3. 信号量 Semaphore

　　信号量机制：即利用 PV 操作来对信号量进行处理。

　　信号量（Semaphore）的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程。信号量的值与相应资源的使用情况有关。

　　当它的值大于 0 时，表示当前可用资源的数量。

　　当它的值小于 0 时，其绝对值表示等待使用该资源的进程个数。

　　注意，信号量的值仅能由 PV 操作来改变。

　　 P 和 V 操作，也就是常见的 down 和 up 操作：

* P：如果信号量大于 0，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
* V：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

　　P和 V 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

　　一般来说，信号量 S >= 0 时，S 表示可用资源的数量。执行一次 P 操作意味着请求分配一个单位资源，因此 S 的值减 1；当 S < 0 时，表示已经没有可用资源，请求者必须等待别的进程释放该类资源，它才能运行下去。而执行一个 V 操作意味着释放一个单位资源，因此 S 的值加 1；若 S <= 0，表示有某些进程正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去。 

　　如果信号量的取值只能为 0 或者 1，那么就成为了互斥量（Mutex），0 表示临界区已经加锁，1 表示临界区解锁。

### 6.4. 管程

　　使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。

　　管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其他进程永远不能使用管程。

　　管程引入了条件变量以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

## 7. 进程通信

　　进程通信是一种手段，而进程同步是一种目的。也就是说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

　　由于多个进程可以并发执行，所以进程间必然存在资源共享和相互合作的问题。进程通信是指各个进程交换信息的过程。

　　同步是合作进程间直接制约问题，互斥是申请临界资源进程间的间接制约问题。

　　临界资源（Critical Resource,CR）：在同一时间只能供一个进程使用的资源，例如：打印机、磁带机等硬件资源。

　　临界区：每个进程中访问临界资源的那段代码。

　　临界区管理 4 条原则：

1. 有空即进。
2. 无空则等。
3. 有限等待：要求访问临界区的进程，保证有限时间内进入临界区，避免死等。
4. 让权等待：进程不能进入临界区时，应立即释放处理机，避免忙等。

　　进程同步与进程通信很容易混淆，它们的区别在于：

* 进程同步：控制多个进程按一定顺序执行。
* 进程通信：进程间传输信息。

　　进程间通信的手段有：管道、FIFO（命名管道）、消息队列、信号量、共享存储、套接字。

### 7.1. 管道

　　管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。

　　它具有以下限制：

* 只支持半双工通信（单向交替传输）；
* 只能在父子进程或者兄弟进程中使用。

![](image/管道.png)

### 7.2. FIFO

　　也称为命名管道，去除了管道只能在父子进程中使用的限制。

　　FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。

![](image/FIFO.png)

### 7.3. 消息队列

　　相比于 FIFO，消息队列具有以下有点：

1. 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
2. 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
3. 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

### 7.4. 信号量

　　它是一个计数器，用于为多个进程提供对共享数据对象的访问。

### 7.5. 共享存储

　　允许多个进程共享一个给定的存储区。因为数据不需要再进程之间复制，所以这是最快的一种 IPC。

　　需要使用信号量来同步对共享存储的访问。

　　多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。

### 7.6. 套接字

　　与其他通信机制不同的是，它可用于不用机器间的进程通信。

## 8. 池

　　所谓池的概念，一般是指应用提前向内核批量申请资源，用于接下来的使用和回收，减少资源的初始化和销毁次数等开销，以达到提高系统性能的目标。

　　内存池：真正使用前申请一片内存区域，有新需求时取出其中一部分使用，不够用时再重新申请新内存。

　　进程池：应用预先创建一组子进程，所有子进程运行相同代码，拥有相同属性，比如 PGID 和优先级等。

　　常见两种工作方式：

1. 主进程通过随机或 round robin 算法来选择子进程作为新任务的服务进程；
2. 通过一个共享队列来进行同步，所有子进程从该队列中获取任务，不过同时只能有一个子进程能成功获得新任务处理权。

　　线程池：主要应用于任务小而多，处理时间短的场景，比如简单网页请求等。

## 9. 参考文章

1. [操作系统基础知识总结整理](https://blog.csdn.net/Song_JiangTao/article/details/79670805)
2. [操作系统基础知识总结（重要）](https://www.cnblogs.com/xdyixia/p/9274909.html)
3. [计算机操作系统](https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机操作系统 - 目录.md)
