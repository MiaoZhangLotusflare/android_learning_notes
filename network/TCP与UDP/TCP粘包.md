# TCP 粘包

## 1. 长连接与短链接

### 1.1. 长连接

　　Client 方与 Server 方先建立通讯连接，连接建立后不断开，然后再进行报文发送和接收。

### 1.2. 短连接

　　Client 方与 Server 进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此种方式常用于一点对多点通讯，比如多个 Client 连接一个 Server。

## 2. 什么时候需要考虑粘包问题

1. 如果利用 TCP 每次发送数据，就与对方建立连接，然后双方发送完一段数据后，就关闭连接，这样就不会出现粘包问题（因为只有一种包结构，类似于 HTTP 协议）。关闭连接主要要双方都发送 close 连接（参考 TCP 关闭连接）。

   如： A 需要发送一段字符串给 B，那么 A 与 B 建立连接，然后发送双方都默认好的协议字符如 “hello give me sth abour yourself”，然后 B 收到报文后，就将缓冲区数据接收，然后关闭连接，这样粘包问题不用考虑到，因为大家都知道是发送一段字符。

2. 如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就 ok，也不用考虑粘包。

3. 如果双方建立连接，需要在连接后一段时间内发送不同结构数据，如连接后，有好几种结构：

   1. hello give me sth abour yourself
   2. Don't give me sth abour yourself

   那这样的话，如果发送方连续发送这两个包出去，接收方一次接收可能会是 "hello give me sth abour yourselfDon't give me sth abour yourself"，这样接收方就无法分辨了到底是要干嘛了，因为协议没有规定这样的字符串，所以要处理把它分包，怎么分也需要双方组织一个比较好的包结构，所以一般可能会在头加一个数据长度之类的包，以确保接收。

## 3. 粘包出现的原因

　　在流传输中出现，UDP 不会出现粘包，因为它有消息边界。

1. 发送端需要等缓冲区满才发送出去，造成粘包。
2. 接收方不及时接收缓冲区的包，造成多个包接收。

## 4. 解决办法

　　为了避免粘包问题，可采取以下几种措施：

1. 一是对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP 提供了强制数据立即传送的操作指令 push，TCP 软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；
2. 二是对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；
3. 三是由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。

　　以上提到的三种措施，都有不足之处：

1. 第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。
2. 第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，还是导致粘包。
3. 第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。

　　而对于解决粘包问题，基于 TCP 开发的通讯程序，有个很重要的问题需要解决，就是封包和拆包。

### 4.1. 为什么基于 TCP 的通讯程序需要进行封包和拆包

　　TCP 是个 “ 流 ” 协议，所谓流，就是没有界限的一串数据，是连成一片的，其间是没有分界线的。但一般通讯程序开发是需要定义一个个相互独立的数据包的，比如用于登录的数据包、用于注销的数据包。由于 TCP " 流 " 的特性以及网络状况，在进行数据传输时会出现以下几种情况。

　　假设连续调用两次 send 分别发送两端数据 data1 和 data2，在接收端有以下几种接收情况：

1. 先接收到 data1，然后接收到 data2；
2. 先接收到 data1 的部分数据，然后接收到 data1 余下的部分以及 data2 的全部；
3. 先接收到了 data1 的全部数据和 data2 的部分数据，然后接收到了 data2 的余下的数据。
4. 一次性接收到了 data1 和 data2 的全部数据。

　　对于 2、3、4 的情况就是经常说的 “ 粘包 ”，就需要把接收到的数据进行拆包，拆成一个独立的数据包。为了拆包就必须在发送端进行封包。

　　另：对于 UDP 来说就不存在拆包的问题，因为 UDP 是个 “ 数据包 ” 协议，也就是两段数据间是有界限的，在接收端要么接收不到数据要么就是接收一个完整的一段数据，不会少接收也不会多接收。

### 4.2. 为什么会出现 2、3、4 的情况

　　“ 粘包 ” 可能发生在发送端也可发生在接收端。

1. 由 Nagle 算法造成的发送端的粘包：Nagle 算法是一种改善网络传输效率的算法。简单的说，当提交一段数据给 TCP 发送时，TCP 并不立刻发送此段数据，而是等待一小段时间，看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去。这是对 Nagle 算法一个简单的解释，像 3 和 4 的情况就有可能是 Nagle 算法造成的。
2. 接收端接收不及时造成的接收端粘包：TCP 会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把 TCP 的数据取出来，就会造成 TCP 缓冲区中存放了几段数据。

## 5. 怎样封包和拆包

　　在遇到 “ 粘包 ” 的问题时，有一个笨办法就是：通过在两次 send 之间调用 sleep 来休眠一小段时间来解决。这个解决方法的缺点是显而易见的，使传输效率大大降低，而且也并不可靠。然后通过应答得方式来解决，尽管在大多数时候是可行的，但是不能解决像 2 的那种情况，而且采用应答方式增加了通讯量，加重了网络负荷。最后就是对数据包进行封包和拆包的操作。

### 5.1. 封包

　　封包就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了。包头其实上是个大小固定的结构体，其中有个结构体成员变量表示包体的长度，这是个很重要的变量，其他的结构体成员可根据需要自己定义。

　　根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。

### 5.2. 拆包

　　对于拆包目前最常用的是以下两种方式：

#### 5.2.1. 动态缓冲区暂存方式

　　之所以说缓冲区是动态的是因为当需要缓冲的数据长度超出缓冲区的长度时会增大缓冲区长度。

　　大概过程描述如下：

1. 为每一个连接动态分配一个缓冲区，同时把此缓冲区和 SOCKET 关联，常用的是通过结构体关联。
2. 当接收到数据时首先把此段数据存放在缓存区中。
3. 判断缓冲区中的数据长度是否够一个包头的长度，如不够，则不进行拆包操作。
4. 根据包头数据解析出里面代表包体长度的变量。
5. 判断缓冲存区除包头外的数据长度是否够一个包体的长度，如不够，则不进行拆包操作。
6. 取出整个数据包。这里的 “ 取 ” 的意思是不光从缓冲区中拷贝出数据包，而且要把此数据包从缓冲区中删除掉。删除的办法就是把此包后面的数据移动到缓冲区的起始地址。

　　这个方法有两个缺点：1. 为每个连接动态分配一个缓冲区增大了内存的使用。2. 有三个地方需要拷贝数据，一个地方是把数据存放在缓冲区，一个地方是把完整的数据包从缓冲区取出来，一个地方是把数据包从缓冲区中删除。

　　对于这些缺点，可以采用环形缓冲来改进。但是这种改进方法还是不能解决第一个缺点以及第一个数据拷贝，只能解决第三个地方的数据拷贝（这个地方是拷贝数据最多的地方），第 2 种拆包方式会解决这两个问题。

　　环形缓冲实现方式是定义两个指针，分别指向有效数据的头和尾。在存放数据和删除数据时只是进行头尾指针的移动。

#### 5.2.2.  利用底层的缓冲区来进行拆包

　　由于 TCP 也维护了一个缓冲区，所以完全可以利用 TCP 的缓冲区来缓存数据，这样一来就不需要为每一个连接分配一个缓冲区了。另一方面 recv 或者 wsarecv 都有一个参数，用来表示要接收多少长度的数据，利用这两个条件就可以对第一种方法进行优化。

　　对于阻塞 SOCKET 来说，可以利用一个循环来接收包头长度的数据，然后解析出代表包体长度的那个变量，再用一个循环来接收包体长度的数据。

　　对于非阻塞的 SOCKET，比如完成端口，可以提交接收包头长度的数据的请求，然后判断接收的数据长度是否等于包头长度，若等于，则提交接收包体长度的数据的请求，若不等于则提交接收剩余数据的请求。当接收包体时，采用类似的方法。

　　一个包没有固定长度，以太网限制在 46-1500 字节，1500 就是以太网的 MTU，超过这个量，TCP 会为 IP 数据包设置偏移量进行分片传输，现在一般可允许应用层设置 8k （NTFS 系）的缓冲区，8k 的数据由底层分片，而应用看来只是一次发送。windows 的缓冲区经验值是 4k，Socket 本身分为两种，流（TCP）和数据报（UDP）。

1. 通信长度，这个是自己决定的，没有系统强迫要发多大的包，实际应该根据需求和网络状况来决定。

   对于 TCP ，这个长度可以大点，但要知道，Socket 内部默认的收发缓冲区大小大概是 8K，可以用 SetSockOpt 来改变。

   但对于 UDP 而言，就不要太大，一般在 1024 至 10K。

   注意一点，无论发多大的包，IP 层和链路层都会把包进行分片发送，一般局域网就是 1500 左右，广域网就只有几十字节。分片后的包将经过不同的路由到达接收方，对于 UDP 而言，要是其中一个分片丢失，那么接收方的 IP 层将把这个发送包丢弃，这就形成丢包。

   显然，要是一个 UDP 发包很大，它被分片后，链路层丢失分片的几率就很大，这个 UDP 包，就很容易丢失，但是太小又影响效率。

   配置这个值，最好可以根据不同的环境来调整到最佳状态。

   send() 函数返回了实际发送的长度，在网络不断的情况下，它绝不会返回（发送失败的）错误，最多就是返回 0。

   对于 TCP 可以自己写一个循环发送。当 send 函数返回 SOCKET_ERROR 时，才标志着有错误。

   但对于 UDP ，不要写循环发送，否则将给接收带来极大的麻烦。所以 UDP 需要用 SetSockOpt 来改变 Socket 内部 Buffer 的大小，以能容纳发包。

   明确一点，TCP 作为流，发包是不会整包到达的，而是源源不断的到，那接收方就必须组包。

   而 UDP 作为消息或数据报，它一定是整包到达接收方。

2. 关于接收，一般的发包都有包边界，首要的就是这个包的长度要让接收方知道，于是就有个包头信息。

   对于 TCP，接收方先收这个包头信息，然后再收包数据。一次收齐整个包也可以，可要对结果是否收齐进行验证。这也就完成了组包过程。UDP 只能整包接收。

   要是提供的接收 Buffer 过小，TCP 将返回实际接收的长度，余下的还可以收，而 UDP 不同的是，余下的数据被丢弃并返回 WSAEMSGSIZE 错误。

   注意 TCP，要是提供的 Buffer 很大，那么可能收到的就是多个发包，必须分离它们，还有就是当 Buffer 太小，而一次收不完 Socket 内部的数据，那么 Socket 接收事件（OnReceive），可能不会再触发。使用事件方式进行接收时，密切注意这点。这些特性就是体现了流和数据报的区别。

## 6. 参考文章

3. [TCP粘包分析](https://blog.csdn.net/m0_37947204/article/details/80490512)