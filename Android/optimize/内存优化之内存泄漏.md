# 内存优化之内存泄漏

#### Android 内存管理
　　Android 应用层是由 java 开发的，Android 的 davlik 虚拟机与 jvm 也类似，只不过它是基于寄存器的。在 java 中，通过 new 为对象分配内存，所有对象在 java 堆内分配空间；而内存的释放是由垃圾收集器（GC）来回收的。Java 采用了有向图的原理。Java 将引用关系考虑为图的有向边，有向边从应用者指向引用对象。线程对象可以作为有向图的起始订点，该图就是从起始顶点（GC roots）开始的一棵树，根顶点可以到达的对象都是有效对象，GC 不会回收这些对象。如果某个对象（连通子图）与这个根顶点不可达，那么认为这个对象不再被引用，可以被 GC 回收。

　　内存溢出就是要求分配的内存超出了系统能给的，系统不能满足需求，于是产生溢出。

#### 内存溢出（out of memory）
1. 由于程序的失误，长期保持某些资源（如 Context） 的引用，垃圾回收器就无法回收它，当然该对象占用的内存就无法被使用，这就造成内存泄漏。

　　Android 中常见就是 Activity 被引用在调用 fnish 之后却没有释放，第二次打开 activity 又重新创建，这样的内存泄漏不断的发生，则会导致内存的溢出。

　　Android 的每个应用程序都会使用一个专有的 Dalvik 虚拟机实例来运行，它是由 Zygote 服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。Android 为不同类型的进程分配了不同的内存使用上限，如果程序在运行过程中出现了内存泄漏的而造成应用进程使用的内存超过了这个上限，则会被系统视为内存泄漏，从而被 kill 掉，而不会影响其他进程。

2. 占用内存较多的对象

　　保存了多个耗用内存过大的对象（如 Bitmap）或加载单个超大的图片，造成内存超出限制。

#### 内存泄漏（memeory leak）
　　有些对象只有有限的生命周期，当它们的任务完成之后，它们将被垃圾回收。如果在对象的生命周期本该结束的时候，这个对象还被一系列的引用，这就会导致内存泄漏。随着泄露的累积，app 将消耗完内存。

　　比如，在 Activity.onDestory() 被调用之后，view 树以及相关的 bitmap 都应该被垃圾回收。如果一个正在运行的后台线程继续持有这个 Activity 的引用，那么相关的内存将不会被回收，这最终将导致 OutOfMemoryError 崩溃。

　　memory leak 最终会导致 out of memory!

###### 内存泄漏的原因
　　当向系统申请分配内存进行使用（new），可是使用完了以后却不归还（delete），结果申请到的那块内存自己也不能再访问（也许把地址弄丢了），而系统也不能再次将它分配给需要的程序。

1. 资源对象没关闭
>如 Cursor、File 等资源，他们会在 finalize 中关闭，但这样效率太低，容易造成内存泄漏；SQLiteCursor ，当数据量大的时候容易泄漏。
2. 使用 Adapter 时，没有使用系统缓存的 converView。
3. 没有及时调用 recycler() 释放不再使用的 bitmap。
4. 使用 application 的 Context 来替代 activity 相关的 context。
> 不要让生命周期长于  Activity 的对象持有 Activity 的引用。
5. 广播注册没取消造成内存泄漏。
6. Handler 应该声明为静态对象，并在其内部类中保存一个对外部类的弱引用。

## Android 的内存管理机制

#### 共享内存
　　Android 系统通过下面几种方式来实现共享内存：
* Android 应用的进程都是从一个叫做 Zygote 的进程 fork 出来的。Zygote 进程在系统启动并且载入通用的 framewaork 的代码与资源之后开始启动。为了启动一个新的程序进程，系统会 fork Zygote 进程生成一个新的进程，然后在新的进程中加载并运行应用程序的代码。这使得大多数的 RAM pages 被用来分配给 framework 的代码，同时使得 RAM 资源能够在应用的所有进程之间进行共享。
* 大多数 static 的数据被 mmapped 到一个进程中。这不仅仅使得同样的数据能够在进程间进行共享，而且使得它能够在需要的时候被 paged out。常见的 static 数据包括 Dalvik Code、app resources、so 文件等。
* 大多数情况下，Android 通过显式的分配共享内存数据（例如 ashmem 或者 gralloc）来实现动态 RAM 区域能够在不同进程之间进行共享的机制。例如，Window Surface 在 App 与 Screen Compositor 之间使用共享的内存，Cursor Buffers 在 Content Provider 与 Clients 之间共享内存。

#### 分配与回收内存
* 每一个进程的 Dalvik heap 都反映了使用内存的占用范围。这就是通常逻辑意义上提到的 Davlik Heap Size，它可以随着需要进行增长，但是增长行为会有一个系统为它设置的上限。
* 逻辑上讲的 Heap Size 和实际物理意义上使用的内存大小是不对等的，Proportional Set Size(PSS)记录了应用程序自身占用以及和其他进程进行共享的内存。
* Android 系统并不会对 Heap 中空闲内存区域做碎片整理。系统仅仅在新的内存分配之前判断 Heap 的尾端剩余空间是否足够，如果空间不够会触发 gc 操作，从而腾出更多空闲的内存空间。在 Android 的高级系统版本里面针对 Heap 空间有一个 Generational Heap Memory 的模型，最近分配的对象会存放在 Young Generation 区域，当这个对象在这个区域停留的时间达到一定程度，它会被移动到 Old Generation，最后累积一定时间再移动到 Permanent Generation 区域。系统会内存中不同的内存数据类型分别执行不同的 gc 操作。例如，刚分配到 Young Generation 区域的对象通常更容易被销毁回收，同时在 Young Generation 区域的 gc 操作速度会比 Old Generation 区域的 gc 操作速度更快。

　　每个 Generation 的内存区域都有固定的大小，随着新的对象陆续被分配到此区域，当这些对象总的大小快达到这一级别内存区域的阈值时，会触发 GC 的操作，以便腾出空间来存放其他新的对象。

　　通常情况下，GC 发生的时候，所有的线程都是会被暂停的。执行 GC 所占用的时间和它发生在哪一个 Generation 也有关系，Young Generation 中的每次 GC 操作时间是最短的，Old Generation 其次，Permanent Generation 最长。执行时间的长短也和当前 Generation 中的对象数量有关。

#### 限制应用的内存



## 参考文章
[Android 内存溢出和内存泄漏的区别](https://blog.csdn.net/u013435893/article/details/50608190)
[Android内存优化之OOM](http://hukai.me/android-performance-oom/)


[[译]Android内存泄漏的八种可能（上）](https://www.jianshu.com/p/ac00e370f83d)
[[译]Android防止内存泄漏的八种方法（下）](https://www.jianshu.com/p/c5ac51d804fa)

