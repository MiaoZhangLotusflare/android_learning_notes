# 内存优化之内存泄漏

#### Android 内存管理
　　Android 应用层是由 java 开发的，Android 的 davlik 虚拟机与 jvm 也类似，只不过它是基于寄存器的。在 java 中，通过 new 为对象分配内存，所有对象在 java 堆内分配空间；而内存的释放是由垃圾收集器（GC）来回收的。Java 采用了有向图的原理。Java 将引用关系考虑为图的有向边，有向边从应用者指向引用对象。线程对象可以作为有向图的起始订点，该图就是从起始顶点（GC roots）开始的一棵树，根顶点可以到达的对象都是有效对象，GC 不会回收这些对象。如果某个对象（连通子图）与这个根顶点不可达，那么认为这个对象不再被引用，可以被 GC 回收。

　　内存溢出就是要求分配的内存超出了系统能给的，系统不能满足需求，于是产生溢出。

#### 内存溢出（out of memory）
1. 由于程序的失误，长期保持某些资源（如 Context） 的引用，垃圾回收器就无法回收它，当然该对象占用的内存就无法被使用，这就造成内存泄漏。

　　Android 中常见就是 Activity 被引用在调用 fnish 之后却没有释放，第二次打开 activity 又重新创建，这样的内存泄漏不断的发生，则会导致内存的溢出。

　　Android 的每个应用程序都会使用一个专有的 Dalvik 虚拟机实例来运行，它是由 Zygote 服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。Android 为不同类型的进程分配了不同的内存使用上限，如果程序在运行过程中出现了内存泄漏的而造成应用进程使用的内存超过了这个上限，则会被系统视为内存泄漏，从而被 kill 掉，而不会影响其他进程。

2. 占用内存较多的对象

　　保存了多个耗用内存过大的对象（如 Bitmap）或加载单个超大的图片，造成内存超出限制。

#### 内存泄漏（memeory leak）
　　有些对象只有有限的生命周期，当它们的任务完成之后，它们将被垃圾回收。如果在对象的生命周期本该结束的时候，这个对象还被一系列的引用，这就会导致内存泄漏。随着泄露的累积，app 将消耗完内存。

　　比如，在 Activity.onDestory() 被调用之后，view 树以及相关的 bitmap 都应该被垃圾回收。如果一个正在运行的后台线程继续持有这个 Activity 的引用，那么相关的内存将不会被回收，这最终将导致 OutOfMemoryError 崩溃。

　　memory leak 最终会导致 out of memory!

###### 内存泄漏的原因
　　当向系统申请分配内存进行使用（new），可是使用完了以后却不归还（delete），结果申请到的那块内存自己也不能再访问（也许把地址弄丢了），而系统也不能再次将它分配给需要的程序。

1. 资源对象没关闭
>如 Cursor、File 等资源，他们会在 finalize 中关闭，但这样效率太低，容易造成内存泄漏；SQLiteCursor ，当数据量大的时候容易泄漏。
2. 使用 Adapter 时，没有使用系统缓存的 converView。
3. 没有及时调用 recycler() 释放不再使用的 bitmap。
4. 使用 application 的 Context 来替代 activity 相关的 context。
> 不要让生命周期长于  Activity 的对象持有 Activity 的引用。
5. 广播注册没取消造成内存泄漏。
6. Handler 应该声明为静态对象，并在其内部类中保存一个对外部类的弱引用。

## Android 的内存管理机制

#### 共享内存
　　Android 系统通过下面几种方式来实现共享内存：
* Android 应用的进程都是从一个叫做 Zygote 的进程 fork 出来的。Zygote 进程在系统启动并且载入通用的 framewaork 的代码与资源之后开始启动。为了启动一个新的程序进程，系统会 fork Zygote 进程生成一个新的进程，然后在新的进程中加载并运行应用程序的代码。这使得大多数的 RAM pages 被用来分配给 framework 的代码，同时使得 RAM 资源能够在应用的所有进程之间进行共享。
* 大多数 static 的数据被 mmapped 到一个进程中。这不仅仅使得同样的数据能够在进程间进行共享，而且使得它能够在需要的时候被 paged out。常见的 static 数据包括 Dalvik Code、app resources、so 文件等。
* 大多数情况下，Android 通过显式的分配共享内存数据（例如 ashmem 或者 gralloc）来实现动态 RAM 区域能够在不同进程之间进行共享的机制。例如，Window Surface 在 App 与 Screen Compositor 之间使用共享的内存，Cursor Buffers 在 Content Provider 与 Clients 之间共享内存。

#### 分配与回收内存
* 每一个进程的 Dalvik heap 都反映了使用内存的占用范围。这就是通常逻辑意义上提到的 Davlik Heap Size，它可以随着需要进行增长，但是增长行为会有一个系统为它设置的上限。
* 逻辑上讲的 Heap Size 和实际物理意义上使用的内存大小是不对等的，Proportional Set Size(PSS)记录了应用程序自身占用以及和其他进程进行共享的内存。
* Android 系统并不会对 Heap 中空闲内存区域做碎片整理。系统仅仅在新的内存分配之前判断 Heap 的尾端剩余空间是否足够，如果空间不够会触发 gc 操作，从而腾出更多空闲的内存空间。在 Android 的高级系统版本里面针对 Heap 空间有一个 Generational Heap Memory 的模型，最近分配的对象会存放在 Young Generation 区域，当这个对象在这个区域停留的时间达到一定程度，它会被移动到 Old Generation，最后累积一定时间再移动到 Permanent Generation 区域。系统会内存中不同的内存数据类型分别执行不同的 gc 操作。例如，刚分配到 Young Generation 区域的对象通常更容易被销毁回收，同时在 Young Generation 区域的 gc 操作速度会比 Old Generation 区域的 gc 操作速度更快。

　　每个 Generation 的内存区域都有固定的大小，随着新的对象陆续被分配到此区域，当这些对象总的大小快达到这一级别内存区域的阈值时，会触发 GC 的操作，以便腾出空间来存放其他新的对象。

　　通常情况下，GC 发生的时候，所有的线程都是会被暂停的。执行 GC 所占用的时间和它发生在哪一个 Generation 也有关系，Young Generation 中的每次 GC 操作时间是最短的，Old Generation 其次，Permanent Generation 最长。执行时间的长短也和当前 Generation 中的对象数量有关。

#### 限制应用的内存
* 为了整个 Android 系统的内存控制需要，Android 系统为每一个应用程序都设置了一个硬性的 Dalvik Heap Size 最大限制阈值，这个阈值在不同的设备上会因为 RAM 大小不同而各有差异。如果你的应用占用内存空间已经接近这个阈值，此时再尝试分配内存的话，很容易引起 OutOfMemoryError 的错误。
* ActivityManager.getMemoryClass() 可以用来查询当前应用的 Heap Size 阈值，这个方法会返回一个整数，表明你的应用的 Heap Size 阈值是多少 Mb(megabates)。

#### 应用切换操作
* Android 系统并不会在用户切换应用的时候做交换内存的操作。Android 会把那些不包含 Foreground 组件的应用进程放到 LRU Cache 中。例如，当用户开始开启了一个应用，系统会为它创建一个进程，但是当用户离开这个应用，此进程并不会立即被销毁，而是会被放到系统的 Cache 当中，如果用户后台再切换回到这个应用，此进程就能够被马上完整的恢复。从而实现应用的快速切换。
* 如果你的应用中有一个被缓存的进程，这个进程会占用一定的内存空间，它会对系统的整体性能有影响。因此当系统开始进入 Low Memory 的状态时，它会由系统根据 LRU 的规则与应用的优先级，内存占用情况以及其他因素的影响综合评估之后决定是否被杀死。

## OOM(OutOfMemory)
　　使用 getMemoryClass() 的方法可以得到 Dalvik Heap 的阈值。

#### 查看内存使用情况
* 使用命令 `adb shell dumpsys meminfo -a 包名`。
* 通过 Android Studio 的 Memory Monitor 查看内存中 Dalvik Heap 的实时变化。

#### 发生 OOM 的条件
　　关于 Native Heap、Dalvik Heap、Pss 等内存管理机制比较复杂，通过不同的内存分配方式（malloc/mmap/JNIEnv/etc）对不同的对象（bitmap,etc）进行操作会因为 Android 系统版本的差异而产生不同的行为，对 Native Heap 与 Dalvik Heap 以及 OOM 的判断条件都会有所影响。在 2.x 的系统上，可以看到 Heap Size 的 total 值明显超过了通过 getMemoryClass() 获取到的阈值而不会发生 OOM 的情况，那么针对 2.x 与 4.x 的 Android 系统，到底是如何判断会发生 OOM 呢？

* Android 2.x 系统 GC LOG 中的 dalvik allocated + external allocated + 新分配的大小 >= getMemoryClass() 值的时候就会发生 OOM。例如，假设有这么一段 Dalvik 输出的 GC LOG：GC_FOR_MALLOC free 2k,13% free 32586K/37455K,external 8989K/10356K,paused 20ms,那么 32586+8989+（新分配）=65550>64M时，就会发生 OOM。
* Android 4.x 系统 Android 4.x 的系统废除了 external 的计数器，类似 bitmap 的分配改到 dalvik 的 java heap 中申请，只要 allocated + 新分配的内存 >= getMemoryClass() 的时候就会发生 OOM。

#### 如何避免 OOM 总结
　　可以从四个方面着手，首先是减少对象的内存占用，其次是内存对象的重复利用，然后是避免对象的内存泄漏，最后是内存使用策略优化。

##### 减少对象的内存占用
　　避免 OOM 的第一步就是要尽量减少新分配出来的对象占用内存的大小，尽量使用更加轻量的对象。

###### 1.使用更加轻量的数据结构
　　例如，可以考虑使用 ArrayMap/SparseArray 而不是 HashMap 等传统数据结构，HashMap 相比起 Android 系统专门为移动操作系统编写的 ArrayMap 容器，大多数情况下，都显示效率低下，更占内存。通常的 HashMap 的实现方式更加消耗内存，因为它需要一个额外的实例对象来记录 Mapping 操作。另外，SparseArray 更加高效在于它们避免了对 key 与 value 的 autobox 自动装箱，并且避免了装箱后的解箱。

###### 2.避免在 Android 里面使用 Enum
　　Android 官方培训课程提到过“Enum often require more than twice as much memory as static constants.You should strictly avoid using enums on Android.”，所以请避免在 Android 里面使用到枚举。

###### 3.减少 Bitmap 对象的内存占用
　　Bitmap 是一个极容易消耗内存的大胖子，减少创建出来的 Bitmap 的内存占用是很重要的，通常来说有下面 2 个措施：
* inSampleSize：缩放比例，在把图片载入内存之前，需要先计算出一个合适的缩放比例，避免不必要的大图载入。
* decode format：解码格式，选择 ARGB_8888/RBG_565/ARGB_4444/ALPHA_8，存在很大差异。

###### 4.使用更小的图片
　　在设计给资源图片的时候，需要特别留意这张图片是否存在可以压缩的空间，是否可以使用一张更小的图片。尽量使用更小的图片不仅仅可以减少内存的使用，还可以避免出现大量的 InflationException。假设有一张很大的图片被 XML 文件直接引用，很有可能在初始化视图的时候就会因为内存不足而发生 InflationException，这个问题的根本原因其实是发生了 OOM。

##### 内存对象的重复利用
　　大多数对象的复用，最终实施的方案都是利用对象池技术，要么是在编写代码的时候显式的在程序里面去创建对象池，然后处理好复用的实现逻辑，要么就是利用系统框架既有的某些复用特性达到减少对象的重复创建，从而减少内存的分配与回收。

###### 1.复用系统自带资源
　　Android 系统本身内置了很多的资源，例如字符串/颜色/图片/动画/样式以及简单布局等等，这些资源都可以在应用程序中直接引用。这样做不仅仅可以减少应用程序的自身负重，减少 APK 的大小，另外还可以一定程度上减少内存的开销，复用性更好。但是也有必要留意 Android 系统的版本差异性，对那些不同系统版本上表现存在很大差异，不符合需求的情况，还是需要应用程序自身内置进去。

###### 2.注意在 ListView/GridView 等出现大量重复子组件的视图里面对 ConvertView 的复用
　　使用 ListView 与 GirdView 注意组件的复用，减少组件的创建。

###### 3.Bitmap 对象的复用
* 在 ListView 与 GirdViwe 等显示大量图片的空间里面需要使用 LRU 的机制来缓存处理好的 Bitmap。












## 参考文章
[Android 内存溢出和内存泄漏的区别](https://blog.csdn.net/u013435893/article/details/50608190)
[Android内存优化之OOM](http://hukai.me/android-performance-oom/)


[[译]Android内存泄漏的八种可能（上）](https://www.jianshu.com/p/ac00e370f83d)
[[译]Android防止内存泄漏的八种方法（下）](https://www.jianshu.com/p/c5ac51d804fa)

