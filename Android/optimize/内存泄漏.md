# 内存泄漏

## Android 内存管理

　　Android 应用层是由 java 开发的，Android 的 davlik 虚拟机与 jvm 也类似，只不过它是基于寄存器的。在 java 中，通过 new 为对象分配内存，所有对象在 java 堆内分配空间；而内存的释放是由垃圾收集器（GC）来回收的。Java 采用了有向图的原理。Java 将引用关系考虑为图的有向边，有向边从应用者指向引用对象。线程对象可以作为有向图的起始顶点，该图就是从起始顶点（GC roots）开始的一棵树，根顶点可以到达的对象都是有效对象，GC 不会回收这些对象。如果某个对象（连通子图）与这个根顶点不可达，那么认为这个对象不再被引用，可以被 GC 回收。

## Android 的内存管理机制

　　Android 系统的 Dalvik 虚拟机扮演了常规的内存垃圾自动回收的角色，Android 系统没有为内存提供交换区，它使用 paging 与 memory-mapping(mmaping) 的机制来管理内存。

#### 共享内存

　　Android 系统通过下面几种方式来实现共享内存：

* Android 应用的进程都是从一个叫做 Zygote 的进程 fork 出来的。Zygote 进程在系统启动并且载入通用的 framewaork 的代码与资源之后开始启动。为了启动一个新的程序进程，系统会 fork Zygote 进程生成一个新的进程，然后在新的进程中加载并运行应用程序的代码。这使得大多数的 RAM pages 被用来分配给 framework 的代码，同时使得 RAM 资源能够在应用的所有进程之间进行共享。
* 大多数 static 的数据被 mmapped 到一个进程中。这不仅仅使得同样的数据能够在进程间进行共享，而且使得它能够在需要的时候被 paged out。常见的 static 数据包括 Dalvik Code、app resources、so 文件等。
* 大多数情况下，Android 通过显式的分配共享内存数据（例如 ashmem 或者 gralloc）来实现动态 RAM 区域能够在不同进程之间进行共享的机制。例如，Window Surface 在 App 与 Screen Compositor 之间使用共享的内存，Cursor Buffers 在 Content Provider 与 Clients 之间共享内存。

#### 分配与回收内存

* 每一个进程的 Dalvik heap 都反映了使用内存的占用范围。这就是通常逻辑意义上提到的 Davlik Heap Size，它可以随着需要进行增长，但是增长行为会有一个系统为它设置的上限。
* 逻辑上讲的 Heap Size 和实际物理意义上使用的内存大小是不对等的，Proportional Set Size(PSS)记录了应用程序自身占用以及和其他进程进行共享的内存。
* Android 系统并不会对 Heap 中空闲内存区域做碎片整理。系统仅仅在新的内存分配之前判断 Heap 的尾端剩余空间是否足够，如果空间不够会触发 gc 操作，从而腾出更多空闲的内存空间。在 Android 的高级系统版本里面针对 Heap 空间有一个 Generational Heap Memory 的模型，最近分配的对象会存放在 Young Generation 区域，当这个对象在这个区域停留的时间达到一定程度，它会被移动到 Old Generation，最后累积一定时间再移动到 Permanent Generation 区域。系统会根据内存中不同的内存数据类型分别执行不同的 gc 操作。例如，刚分配到 Young Generation 区域的对象通常更容易被销毁回收，同时在 Young Generation 区域的 gc 操作速度会比 Old Generation 区域的 gc 操作速度更快。

　　每个 Generation 的内存区域都有固定的大小，随着新的对象陆续被分配到此区域，当这些对象总的大小快达到这一级别内存区域的阈值时，会触发 GC 的操作，以便腾出空间来存放其他新的对象。

　　通常情况下，GC 发生的时候，所有的线程都是会被暂停的。执行 GC 所占用的时间和它发生在哪一个 Generation 也有关系，Young Generation 中的每次 GC 操作时间是最短的，Old Generation 其次，Permanent Generation 最长。执行时间的长短也和当前 Generation 中的对象数量有关。

#### 限制应用的内存

* 为了整个 Android 系统的内存控制需要，Android 系统为每一个应用程序都设置了一个硬性的 Dalvik Heap Size 最大限制阈值，这个阈值在不同的设备上会因为 RAM 大小不同而各有差异。如果应用占用内存空间已经接近这个阈值，此时再尝试分配内存的话，很容易引起 OutOfMemoryError 的错误。
* ActivityManager.getMemoryClass() 可以用来查询当前应用的 Heap Size 阈值，这个方法会返回一个整数，表明应用的 Heap Size 阈值是多少 Mb(megabates)。

#### 应用切换操作

* Android 系统并不会在用户切换应用的时候做交换内存的操作。Android 会把那些不包含 Foreground 组件的应用进程放到 LRU Cache 中。例如，当用户开始开启了一个应用，系统会为它创建一个进程，但是当用户离开这个应用，此进程并不会立即被销毁，而是会被放到系统的 Cache 当中，如果用户后台再切换回到这个应用，此进程就能够被马上完整的恢复。从而实现应用的快速切换。
* 如果应用中有一个被缓存的进程，这个进程会占用一定的内存空间，它会对系统的整体性能有影响。因此当系统开始进入 Low Memory 的状态时，它会由系统根据 LRU 的规则、应用的优先级、内存占用情况以及其他因素的影响综合评估之后决定是否被杀死。

## 内存泄漏（memeory leak）

　　有些对象只有有限的生命周期，当它们的任务完成之后，它们将被垃圾回收器回收。如果在对象的生命周期本该结束的时候，这个对象还被一系列的引用，这就会导致内存泄漏。随着泄露的累积，app 将消耗完内存。

　　比如，在 Activity.onDestory() 被调用之后，view 树以及相关的 bitmap 都应该被垃圾回收。如果一个正在运行的后台线程继续持有这个 Activity 的引用，那么相关的内存将不会被回收，这最终将导致 OutOfMemoryError 崩溃。

　　memory leak 最终会导致 out of memory!

### 内存泄漏的原因

　　当向系统申请分配内存进行使用（new），可是使用完了以后却不归还（delete），结果申请到的那块内存自己也不能再访问（也许把地址弄丢了），而系统也不能再次将它分配给需要的程序。

#### 1. 资源对象没关闭

　　如 Cursor、File 等资源，它们会在 finalize 中关闭，但这样效率太低，容易造成内存泄漏；SQLiteCursor ，当数据量大的时候容易泄漏。

#### 2. 使用 Adapter 时，没有使用系统缓存的 converView。

#### 3. 没有及时调用 recycler() 释放不再使用的 bitmap。

#### 4. 使用 application 的 Context 来替代 activity 相关的 context。

　　不要让生命周期长于  Activity 的对象持有 Activity 的引用。

#### 5. 广播注册没取消造成内存泄漏。

#### 6. Handler 应该声明为静态对象，并在其内部类中保存一个对外部类的弱引用。

## 内存泄漏的八种可能

　　Java 是垃圾回收语言的一种，其优点是开发者无需特意管理内存分配，降低了应用由于局部故障（segmentation fault）导致奔溃，同时防止未释放的内存把堆栈（heap）挤爆的可能，所以写出来的代码更为安全。

　　不幸的是，在 Java 中仍存在很多容易导致内存泄漏的逻辑可能（logincal leak）。如果不小心，Android 应用很容易浪费掉未释放的内存，最终导致内存用光的错误排除（out-of_memory，OOM）。

　　一般内存泄漏（traditional memory leak）的原因是：忘记释放分配的内存导致的（Cursor 忘记关闭等）。逻辑内存泄漏（logic memory leak）的原因是：当应用不再需要这个对象，但仍未释放该对象的所有引用。

　　如果持有对象的强引用，垃圾回收器是无法载内存中回收这个对象。

　　在 Android 开发中，最容易引起的内存泄漏问题的是 Context。比如 Activity 的 Context，就是包含大量的内存引用，例如 View Hierarchies 和其他资源。一旦泄漏了 Context，也意味着泄漏它指向的所有对象。Android 机器内存有限，太多的内存泄漏容易导致 OOM。

　　检测逻辑内存泄漏需要主观判断，特别是对象的生命周期并不清晰。幸运的是，Activity 有着明确的生命周期，很容易发现泄漏的原因。Activity.onDestory() 被视为 Activity 生命的结束，程序上来看，它应该被销毁了，或者 Android 系统需要回收这些内存（当内存不够时，Android 会回收看不见的 Activity）。如果这个方法执行完，在堆栈中仍存在持有该 Activity 的强引用，垃圾回收器就无法把它标记为已回收的内存，而目的却是要回收它。最终的结果就是 Activity 存活在它的生命周期之外。

　　Activity 是重量级对象，应该让 Android 系统来处理它。然而，逻辑内存泄漏总是在不经意间发生。在 Android 中，导致潜在内存泄漏的陷阱不外乎两种：

1. 全局进程（process-global）的 static 变量。这个无视应用的状态，持有 Activity 的强引用的变量。
2. 活在 Activity 生命周期之外的线程。没有清空对 Activity 的强引用。

　　最严重的情况就是泄漏 Activity 对象，因为它占用了大量系统内存。不管内存泄漏的代码表现形式如何，其核心问题在于：在 Activity 生命周期之外仍持有其引用。

### 1. Static Activities

　　在类中定义了静态 Activity 变量，把当前运行的 Activity 实例赋值于这个静态变量。

　　如果这个静态变量在 Activity 生命周期结束后没有清空，就导致内存泄漏。因为 static 变量是贯穿这个应用的生命周期的，所以被泄漏的 Activity 就会一直存在于应用的进程中，不会被垃圾回收器回收。

```java
private static Activity activity;
```

　　类似的情况会发生在单例模式中，如果 Activity 经常被用到，那么在内存中保存一个实例是很使用的。但是，强制延长 Activity 的生命周期是相当危险而且不必要的，无论如何都不能这么做。

#### 解决方法

　　解决方法是需要正确的释放引用让垃圾回收机制在它被销毁的同时将其回收。Android 袁旭开发者控制引用的 "强度"。Activity 对象泄漏是由于需要被销毁时，仍然被强引用着，只要强引用存在就无法被回收。可以用弱引用代理强引用。

　　弱引用不会阻止对象的内存释放，所以即使有弱引用的存在，该对象也可以被回收。

```java
private static WeakReference<Activity> activityReference;
```

### 2. Static Views

　　如果一个 View 初始化耗费大量资源，而且在一个 Activity 生命周期内保存不变，那可以把它变成 static，加载到视图树上（View Hierachy），像这样，当 Activity 被销毁时，应当释放资源（把 static view 置为 null 即可，但是还是不建议用 static view 的方法）。

```java
private static View view;
```

#### 解决方法

　　View 持有其宿主 Activity 的引用，导致的问题与 Activity 一样严重。

　　弱引用是个有效的解决方法，然而还有另一种方法：在生命周期结束时清除引用，在 Activity#onDestory() 方法把引用置空。

```java
@Override
public void onDestroy() {
    super.onDestroy();
    if (view != null) {
        view = null;
    }
}
```

### 3. Inner Classes

　　假设 Activity 中有个内部类，这样做可以提高可读性和封装性。

　　加入创建了一个内部类，而且持有一个静态变量的引用，这样就会很容易内存泄漏（销毁的时候置空）。

```java
private static Object inner;
```

　　内部类的优势之一就是可以访问外部类，不幸的是，导致内存泄漏的原因就是内部类持有外部类实例的强引用。

#### 解决方法

　　内部类和上面的两种情况相似，开发者必须注意少用非静态内部类。因为非静态内部类持有外部类的隐式引用，容易导致意料之外的泄漏。然而内部类可以访问外部类的私有变量，主要注意引用的生命周期，就可以避免以为的发生。

　　解决方法就是避免静态变量，普通的持有内部类的成员变量就可以了。

```java
private Object inner;
```

### 4. Anonymous Classes

　　和内部类相似的，匿名内部类也维护了外部类的引用，所以内存泄漏很容易发生。

　　比如在 Activity 中定义了匿名的 AsyncTask。当异步任务在后台执行耗时任务期间，Activity 不幸被销毁了（用户退出、系统回收等），这个被 AsyncTask 持有的 Activity 实例就不会被垃圾回收期回收，直到异步任务结束。

#### 解决方法

　　AsyncTask、Handler、Thread 全部都是因为匿名类导致的。匿名类时特殊的内部类-写法更为简洁。

　　当需要一次性特殊的子类时，Java 提供的语法糖能让表达式最少化。这样写法很容易导致泄漏。

　　如使用内部类一样，只要不跨越生命周期，内部类时完全没问题的。但是，这些类时用于产生后台线程的，这些 Java 线程是全局的，而且持有创建者的引用（即匿名类的引用），而匿名类又持有外部类的引用。线程是可能长时间运行的，所以一直持有 Activity 的引用导致当销毁时无法回收。

　　这些是不能通过移除静态成员变量解决的，因为线程是与应用生命周期相关的。为了避免泄漏，必须舍弃简洁偷懒的写法，把子类声明为静态内部类。

　　静态内部类不持有外部的引用，打破了链式引用。

　　如果坚持使用匿名类，只要在生命周期结束时中断线程就可以。

```java
private Thread thread;

@Override
public void onDestroy() {
    super.onDestroy();
    if (thread != null) {
        thread.interrupt();
    }
}
```



### 5. Handler

　　当用匿名类 Handler 执行匿名的 Runnable，Runnable 内部类会持有外部类的隐式引用，被传递到 Handler 的消息队列 MessageQueue 中，在 Message 消息没有被处理之前，Activity 实例不会被销毁了，于是导致内存泄漏了。

#### 解决方法

　　同 Anonymous Classes 的解决方法。

### 6. Threads

　　匿名类 Thread 会持有外部类的隐式引用，在 Thread 的 run 没有运行完，Activity 实例不会被销毁，于是导致内存泄漏。

#### 解决方法

　　同 Anonymous Classes 的解决方法。

### 7. TimerTask

　　TimerTask 与 Thread 相同的道理。

　　只要是匿名类的实例，不管是不是在工作线程，都会持有 Activity 的引用，导致内存泄漏。

#### 解决方法

　　同 Anonymous Classes 的解决方法。

### 8. Sensor Manager

　　通过 Context.getSystemService(int name) 可以获取系统服务。

　　这些服务工作在各自的进程中，帮助应用处理后台任务，处理硬件交互。

　　如果需要使用这些服务，可以注册监听器，这回导致服务持有了 Context 的引用，如果在 Activity 销毁的时候没有注销这些监听器，会导致内存泄漏。

```java
void registerListener() {
    SensorManager sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
    Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ALL);
    sensorManager.registerListener(this, sensor, SensorManager.SENSOR_DELAY_FASTEST);
}
```

　　使用 Android 系统服务不当容易导致泄漏，为了 Activity 与服务交互，把 Activity 作为监听器，引用链在传递事件和回调中形成了。

　　主要 Activity 维持注册监听状态，引用就会一直持有，内存就不会被释放。

#### 解决方法

　　在 Activity 结束时注销监听器。

```java
@Override
public void onDestroy() {
    super.onDestroy();
    if (sensor != null) {
        unregisterListener();
    }
}

void unregisterListener() {
    sensorManager.unregisterListener(this, sensor);
}
```



## 总结



　　内存泄漏容易导致吃光设备的内存使垃圾回收处理更为频发，甚至最坏的情况会导致 OOM。垃圾回收的操作使很昂贵的，会导致肉眼可见的卡顿。所以，实例化的时候注意持有的引用链，并经常进行内存泄漏检查。


## 参考文章
1. [Android 内存溢出和内存泄漏的区别](https://blog.csdn.net/u013435893/article/details/50608190)
2. [[译]Android内存泄漏的八种可能（上）](https://www.jianshu.com/p/ac00e370f83d)
3. [[译]Android防止内存泄漏的八种方法（下）](https://www.jianshu.com/p/c5ac51d804fa)

